// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: s2clientprotocol/sc2api.proto

#ifndef PROTOBUF_INCLUDED_s2clientprotocol_2fsc2api_2eproto
#define PROTOBUF_INCLUDED_s2clientprotocol_2fsc2api_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "s2clientprotocol/common.pb.h"
#include "s2clientprotocol/data.pb.h"
#include "s2clientprotocol/debug.pb.h"
#include "s2clientprotocol/error.pb.h"
#include "s2clientprotocol/query.pb.h"
#include "s2clientprotocol/raw.pb.h"
#include "s2clientprotocol/score.pb.h"
#include "s2clientprotocol/spatial.pb.h"
#include "s2clientprotocol/ui.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_s2clientprotocol_2fsc2api_2eproto 

namespace protobuf_s2clientprotocol_2fsc2api_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[61];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_s2clientprotocol_2fsc2api_2eproto
namespace SC2APIProtocol {
class Action;
class ActionDefaultTypeInternal;
extern ActionDefaultTypeInternal _Action_default_instance_;
class ActionChat;
class ActionChatDefaultTypeInternal;
extern ActionChatDefaultTypeInternal _ActionChat_default_instance_;
class ActionError;
class ActionErrorDefaultTypeInternal;
extern ActionErrorDefaultTypeInternal _ActionError_default_instance_;
class ActionObserverCameraFollowPlayer;
class ActionObserverCameraFollowPlayerDefaultTypeInternal;
extern ActionObserverCameraFollowPlayerDefaultTypeInternal _ActionObserverCameraFollowPlayer_default_instance_;
class ActionObserverCameraFollowUnits;
class ActionObserverCameraFollowUnitsDefaultTypeInternal;
extern ActionObserverCameraFollowUnitsDefaultTypeInternal _ActionObserverCameraFollowUnits_default_instance_;
class ActionObserverCameraMove;
class ActionObserverCameraMoveDefaultTypeInternal;
extern ActionObserverCameraMoveDefaultTypeInternal _ActionObserverCameraMove_default_instance_;
class ActionObserverPlayerPerspective;
class ActionObserverPlayerPerspectiveDefaultTypeInternal;
extern ActionObserverPlayerPerspectiveDefaultTypeInternal _ActionObserverPlayerPerspective_default_instance_;
class ChatReceived;
class ChatReceivedDefaultTypeInternal;
extern ChatReceivedDefaultTypeInternal _ChatReceived_default_instance_;
class InterfaceOptions;
class InterfaceOptionsDefaultTypeInternal;
extern InterfaceOptionsDefaultTypeInternal _InterfaceOptions_default_instance_;
class LocalMap;
class LocalMapDefaultTypeInternal;
extern LocalMapDefaultTypeInternal _LocalMap_default_instance_;
class Observation;
class ObservationDefaultTypeInternal;
extern ObservationDefaultTypeInternal _Observation_default_instance_;
class ObserverAction;
class ObserverActionDefaultTypeInternal;
extern ObserverActionDefaultTypeInternal _ObserverAction_default_instance_;
class PlayerCommon;
class PlayerCommonDefaultTypeInternal;
extern PlayerCommonDefaultTypeInternal _PlayerCommon_default_instance_;
class PlayerInfo;
class PlayerInfoDefaultTypeInternal;
extern PlayerInfoDefaultTypeInternal _PlayerInfo_default_instance_;
class PlayerInfoExtra;
class PlayerInfoExtraDefaultTypeInternal;
extern PlayerInfoExtraDefaultTypeInternal _PlayerInfoExtra_default_instance_;
class PlayerResult;
class PlayerResultDefaultTypeInternal;
extern PlayerResultDefaultTypeInternal _PlayerResult_default_instance_;
class PlayerSetup;
class PlayerSetupDefaultTypeInternal;
extern PlayerSetupDefaultTypeInternal _PlayerSetup_default_instance_;
class PortSet;
class PortSetDefaultTypeInternal;
extern PortSetDefaultTypeInternal _PortSet_default_instance_;
class Request;
class RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class RequestAction;
class RequestActionDefaultTypeInternal;
extern RequestActionDefaultTypeInternal _RequestAction_default_instance_;
class RequestAvailableMaps;
class RequestAvailableMapsDefaultTypeInternal;
extern RequestAvailableMapsDefaultTypeInternal _RequestAvailableMaps_default_instance_;
class RequestCreateGame;
class RequestCreateGameDefaultTypeInternal;
extern RequestCreateGameDefaultTypeInternal _RequestCreateGame_default_instance_;
class RequestData;
class RequestDataDefaultTypeInternal;
extern RequestDataDefaultTypeInternal _RequestData_default_instance_;
class RequestDebug;
class RequestDebugDefaultTypeInternal;
extern RequestDebugDefaultTypeInternal _RequestDebug_default_instance_;
class RequestGameInfo;
class RequestGameInfoDefaultTypeInternal;
extern RequestGameInfoDefaultTypeInternal _RequestGameInfo_default_instance_;
class RequestJoinGame;
class RequestJoinGameDefaultTypeInternal;
extern RequestJoinGameDefaultTypeInternal _RequestJoinGame_default_instance_;
class RequestLeaveGame;
class RequestLeaveGameDefaultTypeInternal;
extern RequestLeaveGameDefaultTypeInternal _RequestLeaveGame_default_instance_;
class RequestObservation;
class RequestObservationDefaultTypeInternal;
extern RequestObservationDefaultTypeInternal _RequestObservation_default_instance_;
class RequestObserverAction;
class RequestObserverActionDefaultTypeInternal;
extern RequestObserverActionDefaultTypeInternal _RequestObserverAction_default_instance_;
class RequestPing;
class RequestPingDefaultTypeInternal;
extern RequestPingDefaultTypeInternal _RequestPing_default_instance_;
class RequestQuickLoad;
class RequestQuickLoadDefaultTypeInternal;
extern RequestQuickLoadDefaultTypeInternal _RequestQuickLoad_default_instance_;
class RequestQuickSave;
class RequestQuickSaveDefaultTypeInternal;
extern RequestQuickSaveDefaultTypeInternal _RequestQuickSave_default_instance_;
class RequestQuit;
class RequestQuitDefaultTypeInternal;
extern RequestQuitDefaultTypeInternal _RequestQuit_default_instance_;
class RequestReplayInfo;
class RequestReplayInfoDefaultTypeInternal;
extern RequestReplayInfoDefaultTypeInternal _RequestReplayInfo_default_instance_;
class RequestRestartGame;
class RequestRestartGameDefaultTypeInternal;
extern RequestRestartGameDefaultTypeInternal _RequestRestartGame_default_instance_;
class RequestSaveMap;
class RequestSaveMapDefaultTypeInternal;
extern RequestSaveMapDefaultTypeInternal _RequestSaveMap_default_instance_;
class RequestSaveReplay;
class RequestSaveReplayDefaultTypeInternal;
extern RequestSaveReplayDefaultTypeInternal _RequestSaveReplay_default_instance_;
class RequestStartReplay;
class RequestStartReplayDefaultTypeInternal;
extern RequestStartReplayDefaultTypeInternal _RequestStartReplay_default_instance_;
class RequestStep;
class RequestStepDefaultTypeInternal;
extern RequestStepDefaultTypeInternal _RequestStep_default_instance_;
class Response;
class ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
class ResponseAction;
class ResponseActionDefaultTypeInternal;
extern ResponseActionDefaultTypeInternal _ResponseAction_default_instance_;
class ResponseAvailableMaps;
class ResponseAvailableMapsDefaultTypeInternal;
extern ResponseAvailableMapsDefaultTypeInternal _ResponseAvailableMaps_default_instance_;
class ResponseCreateGame;
class ResponseCreateGameDefaultTypeInternal;
extern ResponseCreateGameDefaultTypeInternal _ResponseCreateGame_default_instance_;
class ResponseData;
class ResponseDataDefaultTypeInternal;
extern ResponseDataDefaultTypeInternal _ResponseData_default_instance_;
class ResponseDebug;
class ResponseDebugDefaultTypeInternal;
extern ResponseDebugDefaultTypeInternal _ResponseDebug_default_instance_;
class ResponseGameInfo;
class ResponseGameInfoDefaultTypeInternal;
extern ResponseGameInfoDefaultTypeInternal _ResponseGameInfo_default_instance_;
class ResponseJoinGame;
class ResponseJoinGameDefaultTypeInternal;
extern ResponseJoinGameDefaultTypeInternal _ResponseJoinGame_default_instance_;
class ResponseLeaveGame;
class ResponseLeaveGameDefaultTypeInternal;
extern ResponseLeaveGameDefaultTypeInternal _ResponseLeaveGame_default_instance_;
class ResponseObservation;
class ResponseObservationDefaultTypeInternal;
extern ResponseObservationDefaultTypeInternal _ResponseObservation_default_instance_;
class ResponseObserverAction;
class ResponseObserverActionDefaultTypeInternal;
extern ResponseObserverActionDefaultTypeInternal _ResponseObserverAction_default_instance_;
class ResponsePing;
class ResponsePingDefaultTypeInternal;
extern ResponsePingDefaultTypeInternal _ResponsePing_default_instance_;
class ResponseQuickLoad;
class ResponseQuickLoadDefaultTypeInternal;
extern ResponseQuickLoadDefaultTypeInternal _ResponseQuickLoad_default_instance_;
class ResponseQuickSave;
class ResponseQuickSaveDefaultTypeInternal;
extern ResponseQuickSaveDefaultTypeInternal _ResponseQuickSave_default_instance_;
class ResponseQuit;
class ResponseQuitDefaultTypeInternal;
extern ResponseQuitDefaultTypeInternal _ResponseQuit_default_instance_;
class ResponseReplayInfo;
class ResponseReplayInfoDefaultTypeInternal;
extern ResponseReplayInfoDefaultTypeInternal _ResponseReplayInfo_default_instance_;
class ResponseRestartGame;
class ResponseRestartGameDefaultTypeInternal;
extern ResponseRestartGameDefaultTypeInternal _ResponseRestartGame_default_instance_;
class ResponseSaveMap;
class ResponseSaveMapDefaultTypeInternal;
extern ResponseSaveMapDefaultTypeInternal _ResponseSaveMap_default_instance_;
class ResponseSaveReplay;
class ResponseSaveReplayDefaultTypeInternal;
extern ResponseSaveReplayDefaultTypeInternal _ResponseSaveReplay_default_instance_;
class ResponseStartReplay;
class ResponseStartReplayDefaultTypeInternal;
extern ResponseStartReplayDefaultTypeInternal _ResponseStartReplay_default_instance_;
class ResponseStep;
class ResponseStepDefaultTypeInternal;
extern ResponseStepDefaultTypeInternal _ResponseStep_default_instance_;
class SpatialCameraSetup;
class SpatialCameraSetupDefaultTypeInternal;
extern SpatialCameraSetupDefaultTypeInternal _SpatialCameraSetup_default_instance_;
}  // namespace SC2APIProtocol
namespace google {
namespace protobuf {
template<> ::SC2APIProtocol::Action* Arena::CreateMaybeMessage<::SC2APIProtocol::Action>(Arena*);
template<> ::SC2APIProtocol::ActionChat* Arena::CreateMaybeMessage<::SC2APIProtocol::ActionChat>(Arena*);
template<> ::SC2APIProtocol::ActionError* Arena::CreateMaybeMessage<::SC2APIProtocol::ActionError>(Arena*);
template<> ::SC2APIProtocol::ActionObserverCameraFollowPlayer* Arena::CreateMaybeMessage<::SC2APIProtocol::ActionObserverCameraFollowPlayer>(Arena*);
template<> ::SC2APIProtocol::ActionObserverCameraFollowUnits* Arena::CreateMaybeMessage<::SC2APIProtocol::ActionObserverCameraFollowUnits>(Arena*);
template<> ::SC2APIProtocol::ActionObserverCameraMove* Arena::CreateMaybeMessage<::SC2APIProtocol::ActionObserverCameraMove>(Arena*);
template<> ::SC2APIProtocol::ActionObserverPlayerPerspective* Arena::CreateMaybeMessage<::SC2APIProtocol::ActionObserverPlayerPerspective>(Arena*);
template<> ::SC2APIProtocol::ChatReceived* Arena::CreateMaybeMessage<::SC2APIProtocol::ChatReceived>(Arena*);
template<> ::SC2APIProtocol::InterfaceOptions* Arena::CreateMaybeMessage<::SC2APIProtocol::InterfaceOptions>(Arena*);
template<> ::SC2APIProtocol::LocalMap* Arena::CreateMaybeMessage<::SC2APIProtocol::LocalMap>(Arena*);
template<> ::SC2APIProtocol::Observation* Arena::CreateMaybeMessage<::SC2APIProtocol::Observation>(Arena*);
template<> ::SC2APIProtocol::ObserverAction* Arena::CreateMaybeMessage<::SC2APIProtocol::ObserverAction>(Arena*);
template<> ::SC2APIProtocol::PlayerCommon* Arena::CreateMaybeMessage<::SC2APIProtocol::PlayerCommon>(Arena*);
template<> ::SC2APIProtocol::PlayerInfo* Arena::CreateMaybeMessage<::SC2APIProtocol::PlayerInfo>(Arena*);
template<> ::SC2APIProtocol::PlayerInfoExtra* Arena::CreateMaybeMessage<::SC2APIProtocol::PlayerInfoExtra>(Arena*);
template<> ::SC2APIProtocol::PlayerResult* Arena::CreateMaybeMessage<::SC2APIProtocol::PlayerResult>(Arena*);
template<> ::SC2APIProtocol::PlayerSetup* Arena::CreateMaybeMessage<::SC2APIProtocol::PlayerSetup>(Arena*);
template<> ::SC2APIProtocol::PortSet* Arena::CreateMaybeMessage<::SC2APIProtocol::PortSet>(Arena*);
template<> ::SC2APIProtocol::Request* Arena::CreateMaybeMessage<::SC2APIProtocol::Request>(Arena*);
template<> ::SC2APIProtocol::RequestAction* Arena::CreateMaybeMessage<::SC2APIProtocol::RequestAction>(Arena*);
template<> ::SC2APIProtocol::RequestAvailableMaps* Arena::CreateMaybeMessage<::SC2APIProtocol::RequestAvailableMaps>(Arena*);
template<> ::SC2APIProtocol::RequestCreateGame* Arena::CreateMaybeMessage<::SC2APIProtocol::RequestCreateGame>(Arena*);
template<> ::SC2APIProtocol::RequestData* Arena::CreateMaybeMessage<::SC2APIProtocol::RequestData>(Arena*);
template<> ::SC2APIProtocol::RequestDebug* Arena::CreateMaybeMessage<::SC2APIProtocol::RequestDebug>(Arena*);
template<> ::SC2APIProtocol::RequestGameInfo* Arena::CreateMaybeMessage<::SC2APIProtocol::RequestGameInfo>(Arena*);
template<> ::SC2APIProtocol::RequestJoinGame* Arena::CreateMaybeMessage<::SC2APIProtocol::RequestJoinGame>(Arena*);
template<> ::SC2APIProtocol::RequestLeaveGame* Arena::CreateMaybeMessage<::SC2APIProtocol::RequestLeaveGame>(Arena*);
template<> ::SC2APIProtocol::RequestObservation* Arena::CreateMaybeMessage<::SC2APIProtocol::RequestObservation>(Arena*);
template<> ::SC2APIProtocol::RequestObserverAction* Arena::CreateMaybeMessage<::SC2APIProtocol::RequestObserverAction>(Arena*);
template<> ::SC2APIProtocol::RequestPing* Arena::CreateMaybeMessage<::SC2APIProtocol::RequestPing>(Arena*);
template<> ::SC2APIProtocol::RequestQuickLoad* Arena::CreateMaybeMessage<::SC2APIProtocol::RequestQuickLoad>(Arena*);
template<> ::SC2APIProtocol::RequestQuickSave* Arena::CreateMaybeMessage<::SC2APIProtocol::RequestQuickSave>(Arena*);
template<> ::SC2APIProtocol::RequestQuit* Arena::CreateMaybeMessage<::SC2APIProtocol::RequestQuit>(Arena*);
template<> ::SC2APIProtocol::RequestReplayInfo* Arena::CreateMaybeMessage<::SC2APIProtocol::RequestReplayInfo>(Arena*);
template<> ::SC2APIProtocol::RequestRestartGame* Arena::CreateMaybeMessage<::SC2APIProtocol::RequestRestartGame>(Arena*);
template<> ::SC2APIProtocol::RequestSaveMap* Arena::CreateMaybeMessage<::SC2APIProtocol::RequestSaveMap>(Arena*);
template<> ::SC2APIProtocol::RequestSaveReplay* Arena::CreateMaybeMessage<::SC2APIProtocol::RequestSaveReplay>(Arena*);
template<> ::SC2APIProtocol::RequestStartReplay* Arena::CreateMaybeMessage<::SC2APIProtocol::RequestStartReplay>(Arena*);
template<> ::SC2APIProtocol::RequestStep* Arena::CreateMaybeMessage<::SC2APIProtocol::RequestStep>(Arena*);
template<> ::SC2APIProtocol::Response* Arena::CreateMaybeMessage<::SC2APIProtocol::Response>(Arena*);
template<> ::SC2APIProtocol::ResponseAction* Arena::CreateMaybeMessage<::SC2APIProtocol::ResponseAction>(Arena*);
template<> ::SC2APIProtocol::ResponseAvailableMaps* Arena::CreateMaybeMessage<::SC2APIProtocol::ResponseAvailableMaps>(Arena*);
template<> ::SC2APIProtocol::ResponseCreateGame* Arena::CreateMaybeMessage<::SC2APIProtocol::ResponseCreateGame>(Arena*);
template<> ::SC2APIProtocol::ResponseData* Arena::CreateMaybeMessage<::SC2APIProtocol::ResponseData>(Arena*);
template<> ::SC2APIProtocol::ResponseDebug* Arena::CreateMaybeMessage<::SC2APIProtocol::ResponseDebug>(Arena*);
template<> ::SC2APIProtocol::ResponseGameInfo* Arena::CreateMaybeMessage<::SC2APIProtocol::ResponseGameInfo>(Arena*);
template<> ::SC2APIProtocol::ResponseJoinGame* Arena::CreateMaybeMessage<::SC2APIProtocol::ResponseJoinGame>(Arena*);
template<> ::SC2APIProtocol::ResponseLeaveGame* Arena::CreateMaybeMessage<::SC2APIProtocol::ResponseLeaveGame>(Arena*);
template<> ::SC2APIProtocol::ResponseObservation* Arena::CreateMaybeMessage<::SC2APIProtocol::ResponseObservation>(Arena*);
template<> ::SC2APIProtocol::ResponseObserverAction* Arena::CreateMaybeMessage<::SC2APIProtocol::ResponseObserverAction>(Arena*);
template<> ::SC2APIProtocol::ResponsePing* Arena::CreateMaybeMessage<::SC2APIProtocol::ResponsePing>(Arena*);
template<> ::SC2APIProtocol::ResponseQuickLoad* Arena::CreateMaybeMessage<::SC2APIProtocol::ResponseQuickLoad>(Arena*);
template<> ::SC2APIProtocol::ResponseQuickSave* Arena::CreateMaybeMessage<::SC2APIProtocol::ResponseQuickSave>(Arena*);
template<> ::SC2APIProtocol::ResponseQuit* Arena::CreateMaybeMessage<::SC2APIProtocol::ResponseQuit>(Arena*);
template<> ::SC2APIProtocol::ResponseReplayInfo* Arena::CreateMaybeMessage<::SC2APIProtocol::ResponseReplayInfo>(Arena*);
template<> ::SC2APIProtocol::ResponseRestartGame* Arena::CreateMaybeMessage<::SC2APIProtocol::ResponseRestartGame>(Arena*);
template<> ::SC2APIProtocol::ResponseSaveMap* Arena::CreateMaybeMessage<::SC2APIProtocol::ResponseSaveMap>(Arena*);
template<> ::SC2APIProtocol::ResponseSaveReplay* Arena::CreateMaybeMessage<::SC2APIProtocol::ResponseSaveReplay>(Arena*);
template<> ::SC2APIProtocol::ResponseStartReplay* Arena::CreateMaybeMessage<::SC2APIProtocol::ResponseStartReplay>(Arena*);
template<> ::SC2APIProtocol::ResponseStep* Arena::CreateMaybeMessage<::SC2APIProtocol::ResponseStep>(Arena*);
template<> ::SC2APIProtocol::SpatialCameraSetup* Arena::CreateMaybeMessage<::SC2APIProtocol::SpatialCameraSetup>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace SC2APIProtocol {

enum ResponseCreateGame_Error {
  ResponseCreateGame_Error_MissingMap = 1,
  ResponseCreateGame_Error_InvalidMapPath = 2,
  ResponseCreateGame_Error_InvalidMapData = 3,
  ResponseCreateGame_Error_InvalidMapName = 4,
  ResponseCreateGame_Error_InvalidMapHandle = 5,
  ResponseCreateGame_Error_MissingPlayerSetup = 6,
  ResponseCreateGame_Error_InvalidPlayerSetup = 7,
  ResponseCreateGame_Error_MultiplayerUnsupported = 8
};
bool ResponseCreateGame_Error_IsValid(int value);
const ResponseCreateGame_Error ResponseCreateGame_Error_Error_MIN = ResponseCreateGame_Error_MissingMap;
const ResponseCreateGame_Error ResponseCreateGame_Error_Error_MAX = ResponseCreateGame_Error_MultiplayerUnsupported;
const int ResponseCreateGame_Error_Error_ARRAYSIZE = ResponseCreateGame_Error_Error_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResponseCreateGame_Error_descriptor();
inline const ::std::string& ResponseCreateGame_Error_Name(ResponseCreateGame_Error value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResponseCreateGame_Error_descriptor(), value);
}
inline bool ResponseCreateGame_Error_Parse(
    const ::std::string& name, ResponseCreateGame_Error* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResponseCreateGame_Error>(
    ResponseCreateGame_Error_descriptor(), name, value);
}
enum ResponseJoinGame_Error {
  ResponseJoinGame_Error_MissingParticipation = 1,
  ResponseJoinGame_Error_InvalidObservedPlayerId = 2,
  ResponseJoinGame_Error_MissingOptions = 3,
  ResponseJoinGame_Error_MissingPorts = 4,
  ResponseJoinGame_Error_GameFull = 5,
  ResponseJoinGame_Error_LaunchError = 6,
  ResponseJoinGame_Error_FeatureUnsupported = 7,
  ResponseJoinGame_Error_NoSpaceForUser = 8,
  ResponseJoinGame_Error_MapDoesNotExist = 9,
  ResponseJoinGame_Error_CannotOpenMap = 10,
  ResponseJoinGame_Error_ChecksumError = 11,
  ResponseJoinGame_Error_NetworkError = 12,
  ResponseJoinGame_Error_OtherError = 13
};
bool ResponseJoinGame_Error_IsValid(int value);
const ResponseJoinGame_Error ResponseJoinGame_Error_Error_MIN = ResponseJoinGame_Error_MissingParticipation;
const ResponseJoinGame_Error ResponseJoinGame_Error_Error_MAX = ResponseJoinGame_Error_OtherError;
const int ResponseJoinGame_Error_Error_ARRAYSIZE = ResponseJoinGame_Error_Error_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResponseJoinGame_Error_descriptor();
inline const ::std::string& ResponseJoinGame_Error_Name(ResponseJoinGame_Error value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResponseJoinGame_Error_descriptor(), value);
}
inline bool ResponseJoinGame_Error_Parse(
    const ::std::string& name, ResponseJoinGame_Error* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResponseJoinGame_Error>(
    ResponseJoinGame_Error_descriptor(), name, value);
}
enum ResponseRestartGame_Error {
  ResponseRestartGame_Error_LaunchError = 1
};
bool ResponseRestartGame_Error_IsValid(int value);
const ResponseRestartGame_Error ResponseRestartGame_Error_Error_MIN = ResponseRestartGame_Error_LaunchError;
const ResponseRestartGame_Error ResponseRestartGame_Error_Error_MAX = ResponseRestartGame_Error_LaunchError;
const int ResponseRestartGame_Error_Error_ARRAYSIZE = ResponseRestartGame_Error_Error_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResponseRestartGame_Error_descriptor();
inline const ::std::string& ResponseRestartGame_Error_Name(ResponseRestartGame_Error value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResponseRestartGame_Error_descriptor(), value);
}
inline bool ResponseRestartGame_Error_Parse(
    const ::std::string& name, ResponseRestartGame_Error* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResponseRestartGame_Error>(
    ResponseRestartGame_Error_descriptor(), name, value);
}
enum ResponseStartReplay_Error {
  ResponseStartReplay_Error_MissingReplay = 1,
  ResponseStartReplay_Error_InvalidReplayPath = 2,
  ResponseStartReplay_Error_InvalidReplayData = 3,
  ResponseStartReplay_Error_InvalidMapData = 4,
  ResponseStartReplay_Error_InvalidObservedPlayerId = 5,
  ResponseStartReplay_Error_MissingOptions = 6,
  ResponseStartReplay_Error_LaunchError = 7
};
bool ResponseStartReplay_Error_IsValid(int value);
const ResponseStartReplay_Error ResponseStartReplay_Error_Error_MIN = ResponseStartReplay_Error_MissingReplay;
const ResponseStartReplay_Error ResponseStartReplay_Error_Error_MAX = ResponseStartReplay_Error_LaunchError;
const int ResponseStartReplay_Error_Error_ARRAYSIZE = ResponseStartReplay_Error_Error_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResponseStartReplay_Error_descriptor();
inline const ::std::string& ResponseStartReplay_Error_Name(ResponseStartReplay_Error value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResponseStartReplay_Error_descriptor(), value);
}
inline bool ResponseStartReplay_Error_Parse(
    const ::std::string& name, ResponseStartReplay_Error* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResponseStartReplay_Error>(
    ResponseStartReplay_Error_descriptor(), name, value);
}
enum ResponseReplayInfo_Error {
  ResponseReplayInfo_Error_MissingReplay = 1,
  ResponseReplayInfo_Error_InvalidReplayPath = 2,
  ResponseReplayInfo_Error_InvalidReplayData = 3,
  ResponseReplayInfo_Error_ParsingError = 4,
  ResponseReplayInfo_Error_DownloadError = 5
};
bool ResponseReplayInfo_Error_IsValid(int value);
const ResponseReplayInfo_Error ResponseReplayInfo_Error_Error_MIN = ResponseReplayInfo_Error_MissingReplay;
const ResponseReplayInfo_Error ResponseReplayInfo_Error_Error_MAX = ResponseReplayInfo_Error_DownloadError;
const int ResponseReplayInfo_Error_Error_ARRAYSIZE = ResponseReplayInfo_Error_Error_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResponseReplayInfo_Error_descriptor();
inline const ::std::string& ResponseReplayInfo_Error_Name(ResponseReplayInfo_Error value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResponseReplayInfo_Error_descriptor(), value);
}
inline bool ResponseReplayInfo_Error_Parse(
    const ::std::string& name, ResponseReplayInfo_Error* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResponseReplayInfo_Error>(
    ResponseReplayInfo_Error_descriptor(), name, value);
}
enum ResponseSaveMap_Error {
  ResponseSaveMap_Error_InvalidMapData = 1
};
bool ResponseSaveMap_Error_IsValid(int value);
const ResponseSaveMap_Error ResponseSaveMap_Error_Error_MIN = ResponseSaveMap_Error_InvalidMapData;
const ResponseSaveMap_Error ResponseSaveMap_Error_Error_MAX = ResponseSaveMap_Error_InvalidMapData;
const int ResponseSaveMap_Error_Error_ARRAYSIZE = ResponseSaveMap_Error_Error_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResponseSaveMap_Error_descriptor();
inline const ::std::string& ResponseSaveMap_Error_Name(ResponseSaveMap_Error value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResponseSaveMap_Error_descriptor(), value);
}
inline bool ResponseSaveMap_Error_Parse(
    const ::std::string& name, ResponseSaveMap_Error* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResponseSaveMap_Error>(
    ResponseSaveMap_Error_descriptor(), name, value);
}
enum ActionChat_Channel {
  ActionChat_Channel_Broadcast = 1,
  ActionChat_Channel_Team = 2
};
bool ActionChat_Channel_IsValid(int value);
const ActionChat_Channel ActionChat_Channel_Channel_MIN = ActionChat_Channel_Broadcast;
const ActionChat_Channel ActionChat_Channel_Channel_MAX = ActionChat_Channel_Team;
const int ActionChat_Channel_Channel_ARRAYSIZE = ActionChat_Channel_Channel_MAX + 1;

const ::google::protobuf::EnumDescriptor* ActionChat_Channel_descriptor();
inline const ::std::string& ActionChat_Channel_Name(ActionChat_Channel value) {
  return ::google::protobuf::internal::NameOfEnum(
    ActionChat_Channel_descriptor(), value);
}
inline bool ActionChat_Channel_Parse(
    const ::std::string& name, ActionChat_Channel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ActionChat_Channel>(
    ActionChat_Channel_descriptor(), name, value);
}
enum Status {
  launched = 1,
  init_game = 2,
  in_game = 3,
  in_replay = 4,
  ended = 5,
  quit = 6,
  unknown = 99
};
bool Status_IsValid(int value);
const Status Status_MIN = launched;
const Status Status_MAX = unknown;
const int Status_ARRAYSIZE = Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* Status_descriptor();
inline const ::std::string& Status_Name(Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    Status_descriptor(), value);
}
inline bool Status_Parse(
    const ::std::string& name, Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Status>(
    Status_descriptor(), name, value);
}
enum Difficulty {
  VeryEasy = 1,
  Easy = 2,
  Medium = 3,
  MediumHard = 4,
  Hard = 5,
  Harder = 6,
  VeryHard = 7,
  CheatVision = 8,
  CheatMoney = 9,
  CheatInsane = 10
};
bool Difficulty_IsValid(int value);
const Difficulty Difficulty_MIN = VeryEasy;
const Difficulty Difficulty_MAX = CheatInsane;
const int Difficulty_ARRAYSIZE = Difficulty_MAX + 1;

const ::google::protobuf::EnumDescriptor* Difficulty_descriptor();
inline const ::std::string& Difficulty_Name(Difficulty value) {
  return ::google::protobuf::internal::NameOfEnum(
    Difficulty_descriptor(), value);
}
inline bool Difficulty_Parse(
    const ::std::string& name, Difficulty* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Difficulty>(
    Difficulty_descriptor(), name, value);
}
enum PlayerType {
  Participant = 1,
  Computer = 2,
  Observer = 3
};
bool PlayerType_IsValid(int value);
const PlayerType PlayerType_MIN = Participant;
const PlayerType PlayerType_MAX = Observer;
const int PlayerType_ARRAYSIZE = PlayerType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PlayerType_descriptor();
inline const ::std::string& PlayerType_Name(PlayerType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PlayerType_descriptor(), value);
}
inline bool PlayerType_Parse(
    const ::std::string& name, PlayerType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PlayerType>(
    PlayerType_descriptor(), name, value);
}
enum Alert {
  NuclearLaunchDetected = 1,
  NydusWormDetected = 2
};
bool Alert_IsValid(int value);
const Alert Alert_MIN = NuclearLaunchDetected;
const Alert Alert_MAX = NydusWormDetected;
const int Alert_ARRAYSIZE = Alert_MAX + 1;

const ::google::protobuf::EnumDescriptor* Alert_descriptor();
inline const ::std::string& Alert_Name(Alert value) {
  return ::google::protobuf::internal::NameOfEnum(
    Alert_descriptor(), value);
}
inline bool Alert_Parse(
    const ::std::string& name, Alert* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Alert>(
    Alert_descriptor(), name, value);
}
enum Result {
  Victory = 1,
  Defeat = 2,
  Tie = 3,
  Undecided = 4
};
bool Result_IsValid(int value);
const Result Result_MIN = Victory;
const Result Result_MAX = Undecided;
const int Result_ARRAYSIZE = Result_MAX + 1;

const ::google::protobuf::EnumDescriptor* Result_descriptor();
inline const ::std::string& Result_Name(Result value) {
  return ::google::protobuf::internal::NameOfEnum(
    Result_descriptor(), value);
}
inline bool Result_Parse(
    const ::std::string& name, Result* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Result>(
    Result_descriptor(), name, value);
}
// ===================================================================

class Request : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.Request) */ {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Request(Request&& from) noexcept
    : Request() {
    *this = ::std::move(from);
  }

  inline Request& operator=(Request&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();

  enum RequestCase {
    kCreateGame = 1,
    kJoinGame = 2,
    kRestartGame = 3,
    kStartReplay = 4,
    kLeaveGame = 5,
    kQuickSave = 6,
    kQuickLoad = 7,
    kQuit = 8,
    kGameInfo = 9,
    kObservation = 10,
    kAction = 11,
    kObsAction = 21,
    kStep = 12,
    kData = 13,
    kQuery = 14,
    kSaveReplay = 15,
    kReplayInfo = 16,
    kAvailableMaps = 17,
    kSaveMap = 18,
    kPing = 19,
    kDebug = 20,
    REQUEST_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Request* internal_default_instance() {
    return reinterpret_cast<const Request*>(
               &_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Request* other);
  friend void swap(Request& a, Request& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Request* New() const final {
    return CreateMaybeMessage<Request>(NULL);
  }

  Request* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Request>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Request* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SC2APIProtocol.RequestCreateGame create_game = 1;
  bool has_create_game() const;
  void clear_create_game();
  static const int kCreateGameFieldNumber = 1;
  private:
  const ::SC2APIProtocol::RequestCreateGame& _internal_create_game() const;
  public:
  const ::SC2APIProtocol::RequestCreateGame& create_game() const;
  ::SC2APIProtocol::RequestCreateGame* release_create_game();
  ::SC2APIProtocol::RequestCreateGame* mutable_create_game();
  void set_allocated_create_game(::SC2APIProtocol::RequestCreateGame* create_game);

  // optional .SC2APIProtocol.RequestJoinGame join_game = 2;
  bool has_join_game() const;
  void clear_join_game();
  static const int kJoinGameFieldNumber = 2;
  private:
  const ::SC2APIProtocol::RequestJoinGame& _internal_join_game() const;
  public:
  const ::SC2APIProtocol::RequestJoinGame& join_game() const;
  ::SC2APIProtocol::RequestJoinGame* release_join_game();
  ::SC2APIProtocol::RequestJoinGame* mutable_join_game();
  void set_allocated_join_game(::SC2APIProtocol::RequestJoinGame* join_game);

  // optional .SC2APIProtocol.RequestRestartGame restart_game = 3;
  bool has_restart_game() const;
  void clear_restart_game();
  static const int kRestartGameFieldNumber = 3;
  private:
  const ::SC2APIProtocol::RequestRestartGame& _internal_restart_game() const;
  public:
  const ::SC2APIProtocol::RequestRestartGame& restart_game() const;
  ::SC2APIProtocol::RequestRestartGame* release_restart_game();
  ::SC2APIProtocol::RequestRestartGame* mutable_restart_game();
  void set_allocated_restart_game(::SC2APIProtocol::RequestRestartGame* restart_game);

  // optional .SC2APIProtocol.RequestStartReplay start_replay = 4;
  bool has_start_replay() const;
  void clear_start_replay();
  static const int kStartReplayFieldNumber = 4;
  private:
  const ::SC2APIProtocol::RequestStartReplay& _internal_start_replay() const;
  public:
  const ::SC2APIProtocol::RequestStartReplay& start_replay() const;
  ::SC2APIProtocol::RequestStartReplay* release_start_replay();
  ::SC2APIProtocol::RequestStartReplay* mutable_start_replay();
  void set_allocated_start_replay(::SC2APIProtocol::RequestStartReplay* start_replay);

  // optional .SC2APIProtocol.RequestLeaveGame leave_game = 5;
  bool has_leave_game() const;
  void clear_leave_game();
  static const int kLeaveGameFieldNumber = 5;
  private:
  const ::SC2APIProtocol::RequestLeaveGame& _internal_leave_game() const;
  public:
  const ::SC2APIProtocol::RequestLeaveGame& leave_game() const;
  ::SC2APIProtocol::RequestLeaveGame* release_leave_game();
  ::SC2APIProtocol::RequestLeaveGame* mutable_leave_game();
  void set_allocated_leave_game(::SC2APIProtocol::RequestLeaveGame* leave_game);

  // optional .SC2APIProtocol.RequestQuickSave quick_save = 6;
  bool has_quick_save() const;
  void clear_quick_save();
  static const int kQuickSaveFieldNumber = 6;
  private:
  const ::SC2APIProtocol::RequestQuickSave& _internal_quick_save() const;
  public:
  const ::SC2APIProtocol::RequestQuickSave& quick_save() const;
  ::SC2APIProtocol::RequestQuickSave* release_quick_save();
  ::SC2APIProtocol::RequestQuickSave* mutable_quick_save();
  void set_allocated_quick_save(::SC2APIProtocol::RequestQuickSave* quick_save);

  // optional .SC2APIProtocol.RequestQuickLoad quick_load = 7;
  bool has_quick_load() const;
  void clear_quick_load();
  static const int kQuickLoadFieldNumber = 7;
  private:
  const ::SC2APIProtocol::RequestQuickLoad& _internal_quick_load() const;
  public:
  const ::SC2APIProtocol::RequestQuickLoad& quick_load() const;
  ::SC2APIProtocol::RequestQuickLoad* release_quick_load();
  ::SC2APIProtocol::RequestQuickLoad* mutable_quick_load();
  void set_allocated_quick_load(::SC2APIProtocol::RequestQuickLoad* quick_load);

  // optional .SC2APIProtocol.RequestQuit quit = 8;
  bool has_quit() const;
  void clear_quit();
  static const int kQuitFieldNumber = 8;
  private:
  const ::SC2APIProtocol::RequestQuit& _internal_quit() const;
  public:
  const ::SC2APIProtocol::RequestQuit& quit() const;
  ::SC2APIProtocol::RequestQuit* release_quit();
  ::SC2APIProtocol::RequestQuit* mutable_quit();
  void set_allocated_quit(::SC2APIProtocol::RequestQuit* quit);

  // optional .SC2APIProtocol.RequestGameInfo game_info = 9;
  bool has_game_info() const;
  void clear_game_info();
  static const int kGameInfoFieldNumber = 9;
  private:
  const ::SC2APIProtocol::RequestGameInfo& _internal_game_info() const;
  public:
  const ::SC2APIProtocol::RequestGameInfo& game_info() const;
  ::SC2APIProtocol::RequestGameInfo* release_game_info();
  ::SC2APIProtocol::RequestGameInfo* mutable_game_info();
  void set_allocated_game_info(::SC2APIProtocol::RequestGameInfo* game_info);

  // optional .SC2APIProtocol.RequestObservation observation = 10;
  bool has_observation() const;
  void clear_observation();
  static const int kObservationFieldNumber = 10;
  private:
  const ::SC2APIProtocol::RequestObservation& _internal_observation() const;
  public:
  const ::SC2APIProtocol::RequestObservation& observation() const;
  ::SC2APIProtocol::RequestObservation* release_observation();
  ::SC2APIProtocol::RequestObservation* mutable_observation();
  void set_allocated_observation(::SC2APIProtocol::RequestObservation* observation);

  // optional .SC2APIProtocol.RequestAction action = 11;
  bool has_action() const;
  void clear_action();
  static const int kActionFieldNumber = 11;
  private:
  const ::SC2APIProtocol::RequestAction& _internal_action() const;
  public:
  const ::SC2APIProtocol::RequestAction& action() const;
  ::SC2APIProtocol::RequestAction* release_action();
  ::SC2APIProtocol::RequestAction* mutable_action();
  void set_allocated_action(::SC2APIProtocol::RequestAction* action);

  // optional .SC2APIProtocol.RequestObserverAction obs_action = 21;
  bool has_obs_action() const;
  void clear_obs_action();
  static const int kObsActionFieldNumber = 21;
  private:
  const ::SC2APIProtocol::RequestObserverAction& _internal_obs_action() const;
  public:
  const ::SC2APIProtocol::RequestObserverAction& obs_action() const;
  ::SC2APIProtocol::RequestObserverAction* release_obs_action();
  ::SC2APIProtocol::RequestObserverAction* mutable_obs_action();
  void set_allocated_obs_action(::SC2APIProtocol::RequestObserverAction* obs_action);

  // optional .SC2APIProtocol.RequestStep step = 12;
  bool has_step() const;
  void clear_step();
  static const int kStepFieldNumber = 12;
  private:
  const ::SC2APIProtocol::RequestStep& _internal_step() const;
  public:
  const ::SC2APIProtocol::RequestStep& step() const;
  ::SC2APIProtocol::RequestStep* release_step();
  ::SC2APIProtocol::RequestStep* mutable_step();
  void set_allocated_step(::SC2APIProtocol::RequestStep* step);

  // optional .SC2APIProtocol.RequestData data = 13;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 13;
  private:
  const ::SC2APIProtocol::RequestData& _internal_data() const;
  public:
  const ::SC2APIProtocol::RequestData& data() const;
  ::SC2APIProtocol::RequestData* release_data();
  ::SC2APIProtocol::RequestData* mutable_data();
  void set_allocated_data(::SC2APIProtocol::RequestData* data);

  // optional .SC2APIProtocol.RequestQuery query = 14;
  bool has_query() const;
  void clear_query();
  static const int kQueryFieldNumber = 14;
  private:
  const ::SC2APIProtocol::RequestQuery& _internal_query() const;
  public:
  const ::SC2APIProtocol::RequestQuery& query() const;
  ::SC2APIProtocol::RequestQuery* release_query();
  ::SC2APIProtocol::RequestQuery* mutable_query();
  void set_allocated_query(::SC2APIProtocol::RequestQuery* query);

  // optional .SC2APIProtocol.RequestSaveReplay save_replay = 15;
  bool has_save_replay() const;
  void clear_save_replay();
  static const int kSaveReplayFieldNumber = 15;
  private:
  const ::SC2APIProtocol::RequestSaveReplay& _internal_save_replay() const;
  public:
  const ::SC2APIProtocol::RequestSaveReplay& save_replay() const;
  ::SC2APIProtocol::RequestSaveReplay* release_save_replay();
  ::SC2APIProtocol::RequestSaveReplay* mutable_save_replay();
  void set_allocated_save_replay(::SC2APIProtocol::RequestSaveReplay* save_replay);

  // optional .SC2APIProtocol.RequestReplayInfo replay_info = 16;
  bool has_replay_info() const;
  void clear_replay_info();
  static const int kReplayInfoFieldNumber = 16;
  private:
  const ::SC2APIProtocol::RequestReplayInfo& _internal_replay_info() const;
  public:
  const ::SC2APIProtocol::RequestReplayInfo& replay_info() const;
  ::SC2APIProtocol::RequestReplayInfo* release_replay_info();
  ::SC2APIProtocol::RequestReplayInfo* mutable_replay_info();
  void set_allocated_replay_info(::SC2APIProtocol::RequestReplayInfo* replay_info);

  // optional .SC2APIProtocol.RequestAvailableMaps available_maps = 17;
  bool has_available_maps() const;
  void clear_available_maps();
  static const int kAvailableMapsFieldNumber = 17;
  private:
  const ::SC2APIProtocol::RequestAvailableMaps& _internal_available_maps() const;
  public:
  const ::SC2APIProtocol::RequestAvailableMaps& available_maps() const;
  ::SC2APIProtocol::RequestAvailableMaps* release_available_maps();
  ::SC2APIProtocol::RequestAvailableMaps* mutable_available_maps();
  void set_allocated_available_maps(::SC2APIProtocol::RequestAvailableMaps* available_maps);

  // optional .SC2APIProtocol.RequestSaveMap save_map = 18;
  bool has_save_map() const;
  void clear_save_map();
  static const int kSaveMapFieldNumber = 18;
  private:
  const ::SC2APIProtocol::RequestSaveMap& _internal_save_map() const;
  public:
  const ::SC2APIProtocol::RequestSaveMap& save_map() const;
  ::SC2APIProtocol::RequestSaveMap* release_save_map();
  ::SC2APIProtocol::RequestSaveMap* mutable_save_map();
  void set_allocated_save_map(::SC2APIProtocol::RequestSaveMap* save_map);

  // optional .SC2APIProtocol.RequestPing ping = 19;
  bool has_ping() const;
  void clear_ping();
  static const int kPingFieldNumber = 19;
  private:
  const ::SC2APIProtocol::RequestPing& _internal_ping() const;
  public:
  const ::SC2APIProtocol::RequestPing& ping() const;
  ::SC2APIProtocol::RequestPing* release_ping();
  ::SC2APIProtocol::RequestPing* mutable_ping();
  void set_allocated_ping(::SC2APIProtocol::RequestPing* ping);

  // optional .SC2APIProtocol.RequestDebug debug = 20;
  bool has_debug() const;
  void clear_debug();
  static const int kDebugFieldNumber = 20;
  private:
  const ::SC2APIProtocol::RequestDebug& _internal_debug() const;
  public:
  const ::SC2APIProtocol::RequestDebug& debug() const;
  ::SC2APIProtocol::RequestDebug* release_debug();
  ::SC2APIProtocol::RequestDebug* mutable_debug();
  void set_allocated_debug(::SC2APIProtocol::RequestDebug* debug);

  void clear_request();
  RequestCase request_case() const;
  // @@protoc_insertion_point(class_scope:SC2APIProtocol.Request)
 private:
  void set_has_create_game();
  void set_has_join_game();
  void set_has_restart_game();
  void set_has_start_replay();
  void set_has_leave_game();
  void set_has_quick_save();
  void set_has_quick_load();
  void set_has_quit();
  void set_has_game_info();
  void set_has_observation();
  void set_has_action();
  void set_has_obs_action();
  void set_has_step();
  void set_has_data();
  void set_has_query();
  void set_has_save_replay();
  void set_has_replay_info();
  void set_has_available_maps();
  void set_has_save_map();
  void set_has_ping();
  void set_has_debug();

  inline bool has_request() const;
  inline void clear_has_request();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  union RequestUnion {
    RequestUnion() {}
    ::SC2APIProtocol::RequestCreateGame* create_game_;
    ::SC2APIProtocol::RequestJoinGame* join_game_;
    ::SC2APIProtocol::RequestRestartGame* restart_game_;
    ::SC2APIProtocol::RequestStartReplay* start_replay_;
    ::SC2APIProtocol::RequestLeaveGame* leave_game_;
    ::SC2APIProtocol::RequestQuickSave* quick_save_;
    ::SC2APIProtocol::RequestQuickLoad* quick_load_;
    ::SC2APIProtocol::RequestQuit* quit_;
    ::SC2APIProtocol::RequestGameInfo* game_info_;
    ::SC2APIProtocol::RequestObservation* observation_;
    ::SC2APIProtocol::RequestAction* action_;
    ::SC2APIProtocol::RequestObserverAction* obs_action_;
    ::SC2APIProtocol::RequestStep* step_;
    ::SC2APIProtocol::RequestData* data_;
    ::SC2APIProtocol::RequestQuery* query_;
    ::SC2APIProtocol::RequestSaveReplay* save_replay_;
    ::SC2APIProtocol::RequestReplayInfo* replay_info_;
    ::SC2APIProtocol::RequestAvailableMaps* available_maps_;
    ::SC2APIProtocol::RequestSaveMap* save_map_;
    ::SC2APIProtocol::RequestPing* ping_;
    ::SC2APIProtocol::RequestDebug* debug_;
  } request_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.Response) */ {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response(Response&& from) noexcept
    : Response() {
    *this = ::std::move(from);
  }

  inline Response& operator=(Response&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();

  enum ResponseCase {
    kCreateGame = 1,
    kJoinGame = 2,
    kRestartGame = 3,
    kStartReplay = 4,
    kLeaveGame = 5,
    kQuickSave = 6,
    kQuickLoad = 7,
    kQuit = 8,
    kGameInfo = 9,
    kObservation = 10,
    kAction = 11,
    kObsAction = 21,
    kStep = 12,
    kData = 13,
    kQuery = 14,
    kSaveReplay = 15,
    kReplayInfo = 16,
    kAvailableMaps = 17,
    kSaveMap = 18,
    kPing = 19,
    kDebug = 20,
    RESPONSE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
               &_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Response* other);
  friend void swap(Response& a, Response& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response* New() const final {
    return CreateMaybeMessage<Response>(NULL);
  }

  Response* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Response>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string error = 98;
  int error_size() const;
  void clear_error();
  static const int kErrorFieldNumber = 98;
  const ::std::string& error(int index) const;
  ::std::string* mutable_error(int index);
  void set_error(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_error(int index, ::std::string&& value);
  #endif
  void set_error(int index, const char* value);
  void set_error(int index, const char* value, size_t size);
  ::std::string* add_error();
  void add_error(const ::std::string& value);
  #if LANG_CXX11
  void add_error(::std::string&& value);
  #endif
  void add_error(const char* value);
  void add_error(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& error() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_error();

  // optional .SC2APIProtocol.Status status = 99;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 99;
  ::SC2APIProtocol::Status status() const;
  void set_status(::SC2APIProtocol::Status value);

  // optional .SC2APIProtocol.ResponseCreateGame create_game = 1;
  bool has_create_game() const;
  void clear_create_game();
  static const int kCreateGameFieldNumber = 1;
  private:
  const ::SC2APIProtocol::ResponseCreateGame& _internal_create_game() const;
  public:
  const ::SC2APIProtocol::ResponseCreateGame& create_game() const;
  ::SC2APIProtocol::ResponseCreateGame* release_create_game();
  ::SC2APIProtocol::ResponseCreateGame* mutable_create_game();
  void set_allocated_create_game(::SC2APIProtocol::ResponseCreateGame* create_game);

  // optional .SC2APIProtocol.ResponseJoinGame join_game = 2;
  bool has_join_game() const;
  void clear_join_game();
  static const int kJoinGameFieldNumber = 2;
  private:
  const ::SC2APIProtocol::ResponseJoinGame& _internal_join_game() const;
  public:
  const ::SC2APIProtocol::ResponseJoinGame& join_game() const;
  ::SC2APIProtocol::ResponseJoinGame* release_join_game();
  ::SC2APIProtocol::ResponseJoinGame* mutable_join_game();
  void set_allocated_join_game(::SC2APIProtocol::ResponseJoinGame* join_game);

  // optional .SC2APIProtocol.ResponseRestartGame restart_game = 3;
  bool has_restart_game() const;
  void clear_restart_game();
  static const int kRestartGameFieldNumber = 3;
  private:
  const ::SC2APIProtocol::ResponseRestartGame& _internal_restart_game() const;
  public:
  const ::SC2APIProtocol::ResponseRestartGame& restart_game() const;
  ::SC2APIProtocol::ResponseRestartGame* release_restart_game();
  ::SC2APIProtocol::ResponseRestartGame* mutable_restart_game();
  void set_allocated_restart_game(::SC2APIProtocol::ResponseRestartGame* restart_game);

  // optional .SC2APIProtocol.ResponseStartReplay start_replay = 4;
  bool has_start_replay() const;
  void clear_start_replay();
  static const int kStartReplayFieldNumber = 4;
  private:
  const ::SC2APIProtocol::ResponseStartReplay& _internal_start_replay() const;
  public:
  const ::SC2APIProtocol::ResponseStartReplay& start_replay() const;
  ::SC2APIProtocol::ResponseStartReplay* release_start_replay();
  ::SC2APIProtocol::ResponseStartReplay* mutable_start_replay();
  void set_allocated_start_replay(::SC2APIProtocol::ResponseStartReplay* start_replay);

  // optional .SC2APIProtocol.ResponseLeaveGame leave_game = 5;
  bool has_leave_game() const;
  void clear_leave_game();
  static const int kLeaveGameFieldNumber = 5;
  private:
  const ::SC2APIProtocol::ResponseLeaveGame& _internal_leave_game() const;
  public:
  const ::SC2APIProtocol::ResponseLeaveGame& leave_game() const;
  ::SC2APIProtocol::ResponseLeaveGame* release_leave_game();
  ::SC2APIProtocol::ResponseLeaveGame* mutable_leave_game();
  void set_allocated_leave_game(::SC2APIProtocol::ResponseLeaveGame* leave_game);

  // optional .SC2APIProtocol.ResponseQuickSave quick_save = 6;
  bool has_quick_save() const;
  void clear_quick_save();
  static const int kQuickSaveFieldNumber = 6;
  private:
  const ::SC2APIProtocol::ResponseQuickSave& _internal_quick_save() const;
  public:
  const ::SC2APIProtocol::ResponseQuickSave& quick_save() const;
  ::SC2APIProtocol::ResponseQuickSave* release_quick_save();
  ::SC2APIProtocol::ResponseQuickSave* mutable_quick_save();
  void set_allocated_quick_save(::SC2APIProtocol::ResponseQuickSave* quick_save);

  // optional .SC2APIProtocol.ResponseQuickLoad quick_load = 7;
  bool has_quick_load() const;
  void clear_quick_load();
  static const int kQuickLoadFieldNumber = 7;
  private:
  const ::SC2APIProtocol::ResponseQuickLoad& _internal_quick_load() const;
  public:
  const ::SC2APIProtocol::ResponseQuickLoad& quick_load() const;
  ::SC2APIProtocol::ResponseQuickLoad* release_quick_load();
  ::SC2APIProtocol::ResponseQuickLoad* mutable_quick_load();
  void set_allocated_quick_load(::SC2APIProtocol::ResponseQuickLoad* quick_load);

  // optional .SC2APIProtocol.ResponseQuit quit = 8;
  bool has_quit() const;
  void clear_quit();
  static const int kQuitFieldNumber = 8;
  private:
  const ::SC2APIProtocol::ResponseQuit& _internal_quit() const;
  public:
  const ::SC2APIProtocol::ResponseQuit& quit() const;
  ::SC2APIProtocol::ResponseQuit* release_quit();
  ::SC2APIProtocol::ResponseQuit* mutable_quit();
  void set_allocated_quit(::SC2APIProtocol::ResponseQuit* quit);

  // optional .SC2APIProtocol.ResponseGameInfo game_info = 9;
  bool has_game_info() const;
  void clear_game_info();
  static const int kGameInfoFieldNumber = 9;
  private:
  const ::SC2APIProtocol::ResponseGameInfo& _internal_game_info() const;
  public:
  const ::SC2APIProtocol::ResponseGameInfo& game_info() const;
  ::SC2APIProtocol::ResponseGameInfo* release_game_info();
  ::SC2APIProtocol::ResponseGameInfo* mutable_game_info();
  void set_allocated_game_info(::SC2APIProtocol::ResponseGameInfo* game_info);

  // optional .SC2APIProtocol.ResponseObservation observation = 10;
  bool has_observation() const;
  void clear_observation();
  static const int kObservationFieldNumber = 10;
  private:
  const ::SC2APIProtocol::ResponseObservation& _internal_observation() const;
  public:
  const ::SC2APIProtocol::ResponseObservation& observation() const;
  ::SC2APIProtocol::ResponseObservation* release_observation();
  ::SC2APIProtocol::ResponseObservation* mutable_observation();
  void set_allocated_observation(::SC2APIProtocol::ResponseObservation* observation);

  // optional .SC2APIProtocol.ResponseAction action = 11;
  bool has_action() const;
  void clear_action();
  static const int kActionFieldNumber = 11;
  private:
  const ::SC2APIProtocol::ResponseAction& _internal_action() const;
  public:
  const ::SC2APIProtocol::ResponseAction& action() const;
  ::SC2APIProtocol::ResponseAction* release_action();
  ::SC2APIProtocol::ResponseAction* mutable_action();
  void set_allocated_action(::SC2APIProtocol::ResponseAction* action);

  // optional .SC2APIProtocol.ResponseObserverAction obs_action = 21;
  bool has_obs_action() const;
  void clear_obs_action();
  static const int kObsActionFieldNumber = 21;
  private:
  const ::SC2APIProtocol::ResponseObserverAction& _internal_obs_action() const;
  public:
  const ::SC2APIProtocol::ResponseObserverAction& obs_action() const;
  ::SC2APIProtocol::ResponseObserverAction* release_obs_action();
  ::SC2APIProtocol::ResponseObserverAction* mutable_obs_action();
  void set_allocated_obs_action(::SC2APIProtocol::ResponseObserverAction* obs_action);

  // optional .SC2APIProtocol.ResponseStep step = 12;
  bool has_step() const;
  void clear_step();
  static const int kStepFieldNumber = 12;
  private:
  const ::SC2APIProtocol::ResponseStep& _internal_step() const;
  public:
  const ::SC2APIProtocol::ResponseStep& step() const;
  ::SC2APIProtocol::ResponseStep* release_step();
  ::SC2APIProtocol::ResponseStep* mutable_step();
  void set_allocated_step(::SC2APIProtocol::ResponseStep* step);

  // optional .SC2APIProtocol.ResponseData data = 13;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 13;
  private:
  const ::SC2APIProtocol::ResponseData& _internal_data() const;
  public:
  const ::SC2APIProtocol::ResponseData& data() const;
  ::SC2APIProtocol::ResponseData* release_data();
  ::SC2APIProtocol::ResponseData* mutable_data();
  void set_allocated_data(::SC2APIProtocol::ResponseData* data);

  // optional .SC2APIProtocol.ResponseQuery query = 14;
  bool has_query() const;
  void clear_query();
  static const int kQueryFieldNumber = 14;
  private:
  const ::SC2APIProtocol::ResponseQuery& _internal_query() const;
  public:
  const ::SC2APIProtocol::ResponseQuery& query() const;
  ::SC2APIProtocol::ResponseQuery* release_query();
  ::SC2APIProtocol::ResponseQuery* mutable_query();
  void set_allocated_query(::SC2APIProtocol::ResponseQuery* query);

  // optional .SC2APIProtocol.ResponseSaveReplay save_replay = 15;
  bool has_save_replay() const;
  void clear_save_replay();
  static const int kSaveReplayFieldNumber = 15;
  private:
  const ::SC2APIProtocol::ResponseSaveReplay& _internal_save_replay() const;
  public:
  const ::SC2APIProtocol::ResponseSaveReplay& save_replay() const;
  ::SC2APIProtocol::ResponseSaveReplay* release_save_replay();
  ::SC2APIProtocol::ResponseSaveReplay* mutable_save_replay();
  void set_allocated_save_replay(::SC2APIProtocol::ResponseSaveReplay* save_replay);

  // optional .SC2APIProtocol.ResponseReplayInfo replay_info = 16;
  bool has_replay_info() const;
  void clear_replay_info();
  static const int kReplayInfoFieldNumber = 16;
  private:
  const ::SC2APIProtocol::ResponseReplayInfo& _internal_replay_info() const;
  public:
  const ::SC2APIProtocol::ResponseReplayInfo& replay_info() const;
  ::SC2APIProtocol::ResponseReplayInfo* release_replay_info();
  ::SC2APIProtocol::ResponseReplayInfo* mutable_replay_info();
  void set_allocated_replay_info(::SC2APIProtocol::ResponseReplayInfo* replay_info);

  // optional .SC2APIProtocol.ResponseAvailableMaps available_maps = 17;
  bool has_available_maps() const;
  void clear_available_maps();
  static const int kAvailableMapsFieldNumber = 17;
  private:
  const ::SC2APIProtocol::ResponseAvailableMaps& _internal_available_maps() const;
  public:
  const ::SC2APIProtocol::ResponseAvailableMaps& available_maps() const;
  ::SC2APIProtocol::ResponseAvailableMaps* release_available_maps();
  ::SC2APIProtocol::ResponseAvailableMaps* mutable_available_maps();
  void set_allocated_available_maps(::SC2APIProtocol::ResponseAvailableMaps* available_maps);

  // optional .SC2APIProtocol.ResponseSaveMap save_map = 18;
  bool has_save_map() const;
  void clear_save_map();
  static const int kSaveMapFieldNumber = 18;
  private:
  const ::SC2APIProtocol::ResponseSaveMap& _internal_save_map() const;
  public:
  const ::SC2APIProtocol::ResponseSaveMap& save_map() const;
  ::SC2APIProtocol::ResponseSaveMap* release_save_map();
  ::SC2APIProtocol::ResponseSaveMap* mutable_save_map();
  void set_allocated_save_map(::SC2APIProtocol::ResponseSaveMap* save_map);

  // optional .SC2APIProtocol.ResponsePing ping = 19;
  bool has_ping() const;
  void clear_ping();
  static const int kPingFieldNumber = 19;
  private:
  const ::SC2APIProtocol::ResponsePing& _internal_ping() const;
  public:
  const ::SC2APIProtocol::ResponsePing& ping() const;
  ::SC2APIProtocol::ResponsePing* release_ping();
  ::SC2APIProtocol::ResponsePing* mutable_ping();
  void set_allocated_ping(::SC2APIProtocol::ResponsePing* ping);

  // optional .SC2APIProtocol.ResponseDebug debug = 20;
  bool has_debug() const;
  void clear_debug();
  static const int kDebugFieldNumber = 20;
  private:
  const ::SC2APIProtocol::ResponseDebug& _internal_debug() const;
  public:
  const ::SC2APIProtocol::ResponseDebug& debug() const;
  ::SC2APIProtocol::ResponseDebug* release_debug();
  ::SC2APIProtocol::ResponseDebug* mutable_debug();
  void set_allocated_debug(::SC2APIProtocol::ResponseDebug* debug);

  void clear_response();
  ResponseCase response_case() const;
  // @@protoc_insertion_point(class_scope:SC2APIProtocol.Response)
 private:
  void set_has_create_game();
  void set_has_join_game();
  void set_has_restart_game();
  void set_has_start_replay();
  void set_has_leave_game();
  void set_has_quick_save();
  void set_has_quick_load();
  void set_has_quit();
  void set_has_game_info();
  void set_has_observation();
  void set_has_action();
  void set_has_obs_action();
  void set_has_step();
  void set_has_data();
  void set_has_query();
  void set_has_save_replay();
  void set_has_replay_info();
  void set_has_available_maps();
  void set_has_save_map();
  void set_has_ping();
  void set_has_debug();
  void set_has_status();
  void clear_has_status();

  inline bool has_response() const;
  inline void clear_has_response();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> error_;
  int status_;
  union ResponseUnion {
    ResponseUnion() {}
    ::SC2APIProtocol::ResponseCreateGame* create_game_;
    ::SC2APIProtocol::ResponseJoinGame* join_game_;
    ::SC2APIProtocol::ResponseRestartGame* restart_game_;
    ::SC2APIProtocol::ResponseStartReplay* start_replay_;
    ::SC2APIProtocol::ResponseLeaveGame* leave_game_;
    ::SC2APIProtocol::ResponseQuickSave* quick_save_;
    ::SC2APIProtocol::ResponseQuickLoad* quick_load_;
    ::SC2APIProtocol::ResponseQuit* quit_;
    ::SC2APIProtocol::ResponseGameInfo* game_info_;
    ::SC2APIProtocol::ResponseObservation* observation_;
    ::SC2APIProtocol::ResponseAction* action_;
    ::SC2APIProtocol::ResponseObserverAction* obs_action_;
    ::SC2APIProtocol::ResponseStep* step_;
    ::SC2APIProtocol::ResponseData* data_;
    ::SC2APIProtocol::ResponseQuery* query_;
    ::SC2APIProtocol::ResponseSaveReplay* save_replay_;
    ::SC2APIProtocol::ResponseReplayInfo* replay_info_;
    ::SC2APIProtocol::ResponseAvailableMaps* available_maps_;
    ::SC2APIProtocol::ResponseSaveMap* save_map_;
    ::SC2APIProtocol::ResponsePing* ping_;
    ::SC2APIProtocol::ResponseDebug* debug_;
  } response_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestCreateGame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestCreateGame) */ {
 public:
  RequestCreateGame();
  virtual ~RequestCreateGame();

  RequestCreateGame(const RequestCreateGame& from);

  inline RequestCreateGame& operator=(const RequestCreateGame& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestCreateGame(RequestCreateGame&& from) noexcept
    : RequestCreateGame() {
    *this = ::std::move(from);
  }

  inline RequestCreateGame& operator=(RequestCreateGame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestCreateGame& default_instance();

  enum MapCase {
    kLocalMap = 1,
    kBattlenetMapName = 2,
    MAP_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestCreateGame* internal_default_instance() {
    return reinterpret_cast<const RequestCreateGame*>(
               &_RequestCreateGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(RequestCreateGame* other);
  friend void swap(RequestCreateGame& a, RequestCreateGame& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestCreateGame* New() const final {
    return CreateMaybeMessage<RequestCreateGame>(NULL);
  }

  RequestCreateGame* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestCreateGame>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestCreateGame& from);
  void MergeFrom(const RequestCreateGame& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestCreateGame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SC2APIProtocol.PlayerSetup player_setup = 3;
  int player_setup_size() const;
  void clear_player_setup();
  static const int kPlayerSetupFieldNumber = 3;
  ::SC2APIProtocol::PlayerSetup* mutable_player_setup(int index);
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PlayerSetup >*
      mutable_player_setup();
  const ::SC2APIProtocol::PlayerSetup& player_setup(int index) const;
  ::SC2APIProtocol::PlayerSetup* add_player_setup();
  const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PlayerSetup >&
      player_setup() const;

  // optional uint32 random_seed = 5;
  bool has_random_seed() const;
  void clear_random_seed();
  static const int kRandomSeedFieldNumber = 5;
  ::google::protobuf::uint32 random_seed() const;
  void set_random_seed(::google::protobuf::uint32 value);

  // optional bool disable_fog = 4;
  bool has_disable_fog() const;
  void clear_disable_fog();
  static const int kDisableFogFieldNumber = 4;
  bool disable_fog() const;
  void set_disable_fog(bool value);

  // optional bool realtime = 6;
  bool has_realtime() const;
  void clear_realtime();
  static const int kRealtimeFieldNumber = 6;
  bool realtime() const;
  void set_realtime(bool value);

  // optional .SC2APIProtocol.LocalMap local_map = 1;
  bool has_local_map() const;
  void clear_local_map();
  static const int kLocalMapFieldNumber = 1;
  private:
  const ::SC2APIProtocol::LocalMap& _internal_local_map() const;
  public:
  const ::SC2APIProtocol::LocalMap& local_map() const;
  ::SC2APIProtocol::LocalMap* release_local_map();
  ::SC2APIProtocol::LocalMap* mutable_local_map();
  void set_allocated_local_map(::SC2APIProtocol::LocalMap* local_map);

  // optional string battlenet_map_name = 2;
  bool has_battlenet_map_name() const;
  void clear_battlenet_map_name();
  static const int kBattlenetMapNameFieldNumber = 2;
  const ::std::string& battlenet_map_name() const;
  void set_battlenet_map_name(const ::std::string& value);
  #if LANG_CXX11
  void set_battlenet_map_name(::std::string&& value);
  #endif
  void set_battlenet_map_name(const char* value);
  void set_battlenet_map_name(const char* value, size_t size);
  ::std::string* mutable_battlenet_map_name();
  ::std::string* release_battlenet_map_name();
  void set_allocated_battlenet_map_name(::std::string* battlenet_map_name);

  void clear_Map();
  MapCase Map_case() const;
  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestCreateGame)
 private:
  void set_has_local_map();
  void set_has_battlenet_map_name();
  void set_has_disable_fog();
  void clear_has_disable_fog();
  void set_has_random_seed();
  void clear_has_random_seed();
  void set_has_realtime();
  void clear_has_realtime();

  inline bool has_Map() const;
  inline void clear_has_Map();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PlayerSetup > player_setup_;
  ::google::protobuf::uint32 random_seed_;
  bool disable_fog_;
  bool realtime_;
  union MapUnion {
    MapUnion() {}
    ::SC2APIProtocol::LocalMap* local_map_;
    ::google::protobuf::internal::ArenaStringPtr battlenet_map_name_;
  } Map_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LocalMap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.LocalMap) */ {
 public:
  LocalMap();
  virtual ~LocalMap();

  LocalMap(const LocalMap& from);

  inline LocalMap& operator=(const LocalMap& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LocalMap(LocalMap&& from) noexcept
    : LocalMap() {
    *this = ::std::move(from);
  }

  inline LocalMap& operator=(LocalMap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LocalMap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LocalMap* internal_default_instance() {
    return reinterpret_cast<const LocalMap*>(
               &_LocalMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(LocalMap* other);
  friend void swap(LocalMap& a, LocalMap& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LocalMap* New() const final {
    return CreateMaybeMessage<LocalMap>(NULL);
  }

  LocalMap* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LocalMap>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LocalMap& from);
  void MergeFrom(const LocalMap& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocalMap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string map_path = 1;
  bool has_map_path() const;
  void clear_map_path();
  static const int kMapPathFieldNumber = 1;
  const ::std::string& map_path() const;
  void set_map_path(const ::std::string& value);
  #if LANG_CXX11
  void set_map_path(::std::string&& value);
  #endif
  void set_map_path(const char* value);
  void set_map_path(const char* value, size_t size);
  ::std::string* mutable_map_path();
  ::std::string* release_map_path();
  void set_allocated_map_path(::std::string* map_path);

  // optional bytes map_data = 7;
  bool has_map_data() const;
  void clear_map_data();
  static const int kMapDataFieldNumber = 7;
  const ::std::string& map_data() const;
  void set_map_data(const ::std::string& value);
  #if LANG_CXX11
  void set_map_data(::std::string&& value);
  #endif
  void set_map_data(const char* value);
  void set_map_data(const void* value, size_t size);
  ::std::string* mutable_map_data();
  ::std::string* release_map_data();
  void set_allocated_map_data(::std::string* map_data);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.LocalMap)
 private:
  void set_has_map_path();
  void clear_has_map_path();
  void set_has_map_data();
  void clear_has_map_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr map_path_;
  ::google::protobuf::internal::ArenaStringPtr map_data_;
  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseCreateGame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseCreateGame) */ {
 public:
  ResponseCreateGame();
  virtual ~ResponseCreateGame();

  ResponseCreateGame(const ResponseCreateGame& from);

  inline ResponseCreateGame& operator=(const ResponseCreateGame& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseCreateGame(ResponseCreateGame&& from) noexcept
    : ResponseCreateGame() {
    *this = ::std::move(from);
  }

  inline ResponseCreateGame& operator=(ResponseCreateGame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseCreateGame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseCreateGame* internal_default_instance() {
    return reinterpret_cast<const ResponseCreateGame*>(
               &_ResponseCreateGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ResponseCreateGame* other);
  friend void swap(ResponseCreateGame& a, ResponseCreateGame& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseCreateGame* New() const final {
    return CreateMaybeMessage<ResponseCreateGame>(NULL);
  }

  ResponseCreateGame* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseCreateGame>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResponseCreateGame& from);
  void MergeFrom(const ResponseCreateGame& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseCreateGame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResponseCreateGame_Error Error;
  static const Error MissingMap =
    ResponseCreateGame_Error_MissingMap;
  static const Error InvalidMapPath =
    ResponseCreateGame_Error_InvalidMapPath;
  static const Error InvalidMapData =
    ResponseCreateGame_Error_InvalidMapData;
  static const Error InvalidMapName =
    ResponseCreateGame_Error_InvalidMapName;
  static const Error InvalidMapHandle =
    ResponseCreateGame_Error_InvalidMapHandle;
  static const Error MissingPlayerSetup =
    ResponseCreateGame_Error_MissingPlayerSetup;
  static const Error InvalidPlayerSetup =
    ResponseCreateGame_Error_InvalidPlayerSetup;
  static const Error MultiplayerUnsupported =
    ResponseCreateGame_Error_MultiplayerUnsupported;
  static inline bool Error_IsValid(int value) {
    return ResponseCreateGame_Error_IsValid(value);
  }
  static const Error Error_MIN =
    ResponseCreateGame_Error_Error_MIN;
  static const Error Error_MAX =
    ResponseCreateGame_Error_Error_MAX;
  static const int Error_ARRAYSIZE =
    ResponseCreateGame_Error_Error_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Error_descriptor() {
    return ResponseCreateGame_Error_descriptor();
  }
  static inline const ::std::string& Error_Name(Error value) {
    return ResponseCreateGame_Error_Name(value);
  }
  static inline bool Error_Parse(const ::std::string& name,
      Error* value) {
    return ResponseCreateGame_Error_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string error_details = 2;
  bool has_error_details() const;
  void clear_error_details();
  static const int kErrorDetailsFieldNumber = 2;
  const ::std::string& error_details() const;
  void set_error_details(const ::std::string& value);
  #if LANG_CXX11
  void set_error_details(::std::string&& value);
  #endif
  void set_error_details(const char* value);
  void set_error_details(const char* value, size_t size);
  ::std::string* mutable_error_details();
  ::std::string* release_error_details();
  void set_allocated_error_details(::std::string* error_details);

  // optional .SC2APIProtocol.ResponseCreateGame.Error error = 1;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  ::SC2APIProtocol::ResponseCreateGame_Error error() const;
  void set_error(::SC2APIProtocol::ResponseCreateGame_Error value);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseCreateGame)
 private:
  void set_has_error();
  void clear_has_error();
  void set_has_error_details();
  void clear_has_error_details();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr error_details_;
  int error_;
  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestJoinGame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestJoinGame) */ {
 public:
  RequestJoinGame();
  virtual ~RequestJoinGame();

  RequestJoinGame(const RequestJoinGame& from);

  inline RequestJoinGame& operator=(const RequestJoinGame& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestJoinGame(RequestJoinGame&& from) noexcept
    : RequestJoinGame() {
    *this = ::std::move(from);
  }

  inline RequestJoinGame& operator=(RequestJoinGame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestJoinGame& default_instance();

  enum ParticipationCase {
    kRace = 1,
    kObservedPlayerId = 2,
    PARTICIPATION_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestJoinGame* internal_default_instance() {
    return reinterpret_cast<const RequestJoinGame*>(
               &_RequestJoinGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(RequestJoinGame* other);
  friend void swap(RequestJoinGame& a, RequestJoinGame& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestJoinGame* New() const final {
    return CreateMaybeMessage<RequestJoinGame>(NULL);
  }

  RequestJoinGame* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestJoinGame>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestJoinGame& from);
  void MergeFrom(const RequestJoinGame& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestJoinGame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SC2APIProtocol.PortSet client_ports = 5;
  int client_ports_size() const;
  void clear_client_ports();
  static const int kClientPortsFieldNumber = 5;
  ::SC2APIProtocol::PortSet* mutable_client_ports(int index);
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PortSet >*
      mutable_client_ports();
  const ::SC2APIProtocol::PortSet& client_ports(int index) const;
  ::SC2APIProtocol::PortSet* add_client_ports();
  const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PortSet >&
      client_ports() const;

  // optional .SC2APIProtocol.InterfaceOptions options = 3;
  bool has_options() const;
  void clear_options();
  static const int kOptionsFieldNumber = 3;
  private:
  const ::SC2APIProtocol::InterfaceOptions& _internal_options() const;
  public:
  const ::SC2APIProtocol::InterfaceOptions& options() const;
  ::SC2APIProtocol::InterfaceOptions* release_options();
  ::SC2APIProtocol::InterfaceOptions* mutable_options();
  void set_allocated_options(::SC2APIProtocol::InterfaceOptions* options);

  // optional .SC2APIProtocol.PortSet server_ports = 4;
  bool has_server_ports() const;
  void clear_server_ports();
  static const int kServerPortsFieldNumber = 4;
  private:
  const ::SC2APIProtocol::PortSet& _internal_server_ports() const;
  public:
  const ::SC2APIProtocol::PortSet& server_ports() const;
  ::SC2APIProtocol::PortSet* release_server_ports();
  ::SC2APIProtocol::PortSet* mutable_server_ports();
  void set_allocated_server_ports(::SC2APIProtocol::PortSet* server_ports);

  // optional int32 shared_port = 6;
  bool has_shared_port() const;
  void clear_shared_port();
  static const int kSharedPortFieldNumber = 6;
  ::google::protobuf::int32 shared_port() const;
  void set_shared_port(::google::protobuf::int32 value);

  // optional .SC2APIProtocol.Race race = 1;
  bool has_race() const;
  void clear_race();
  static const int kRaceFieldNumber = 1;
  ::SC2APIProtocol::Race race() const;
  void set_race(::SC2APIProtocol::Race value);

  // optional uint32 observed_player_id = 2;
  bool has_observed_player_id() const;
  void clear_observed_player_id();
  static const int kObservedPlayerIdFieldNumber = 2;
  ::google::protobuf::uint32 observed_player_id() const;
  void set_observed_player_id(::google::protobuf::uint32 value);

  void clear_participation();
  ParticipationCase participation_case() const;
  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestJoinGame)
 private:
  void set_has_race();
  void set_has_observed_player_id();
  void set_has_options();
  void clear_has_options();
  void set_has_server_ports();
  void clear_has_server_ports();
  void set_has_shared_port();
  void clear_has_shared_port();

  inline bool has_participation() const;
  inline void clear_has_participation();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PortSet > client_ports_;
  ::SC2APIProtocol::InterfaceOptions* options_;
  ::SC2APIProtocol::PortSet* server_ports_;
  ::google::protobuf::int32 shared_port_;
  union ParticipationUnion {
    ParticipationUnion() {}
    int race_;
    ::google::protobuf::uint32 observed_player_id_;
  } participation_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PortSet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.PortSet) */ {
 public:
  PortSet();
  virtual ~PortSet();

  PortSet(const PortSet& from);

  inline PortSet& operator=(const PortSet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PortSet(PortSet&& from) noexcept
    : PortSet() {
    *this = ::std::move(from);
  }

  inline PortSet& operator=(PortSet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PortSet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PortSet* internal_default_instance() {
    return reinterpret_cast<const PortSet*>(
               &_PortSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(PortSet* other);
  friend void swap(PortSet& a, PortSet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PortSet* New() const final {
    return CreateMaybeMessage<PortSet>(NULL);
  }

  PortSet* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PortSet>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PortSet& from);
  void MergeFrom(const PortSet& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PortSet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 game_port = 1;
  bool has_game_port() const;
  void clear_game_port();
  static const int kGamePortFieldNumber = 1;
  ::google::protobuf::int32 game_port() const;
  void set_game_port(::google::protobuf::int32 value);

  // optional int32 base_port = 2;
  bool has_base_port() const;
  void clear_base_port();
  static const int kBasePortFieldNumber = 2;
  ::google::protobuf::int32 base_port() const;
  void set_base_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.PortSet)
 private:
  void set_has_game_port();
  void clear_has_game_port();
  void set_has_base_port();
  void clear_has_base_port();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 game_port_;
  ::google::protobuf::int32 base_port_;
  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseJoinGame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseJoinGame) */ {
 public:
  ResponseJoinGame();
  virtual ~ResponseJoinGame();

  ResponseJoinGame(const ResponseJoinGame& from);

  inline ResponseJoinGame& operator=(const ResponseJoinGame& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseJoinGame(ResponseJoinGame&& from) noexcept
    : ResponseJoinGame() {
    *this = ::std::move(from);
  }

  inline ResponseJoinGame& operator=(ResponseJoinGame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseJoinGame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseJoinGame* internal_default_instance() {
    return reinterpret_cast<const ResponseJoinGame*>(
               &_ResponseJoinGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(ResponseJoinGame* other);
  friend void swap(ResponseJoinGame& a, ResponseJoinGame& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseJoinGame* New() const final {
    return CreateMaybeMessage<ResponseJoinGame>(NULL);
  }

  ResponseJoinGame* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseJoinGame>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResponseJoinGame& from);
  void MergeFrom(const ResponseJoinGame& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseJoinGame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResponseJoinGame_Error Error;
  static const Error MissingParticipation =
    ResponseJoinGame_Error_MissingParticipation;
  static const Error InvalidObservedPlayerId =
    ResponseJoinGame_Error_InvalidObservedPlayerId;
  static const Error MissingOptions =
    ResponseJoinGame_Error_MissingOptions;
  static const Error MissingPorts =
    ResponseJoinGame_Error_MissingPorts;
  static const Error GameFull =
    ResponseJoinGame_Error_GameFull;
  static const Error LaunchError =
    ResponseJoinGame_Error_LaunchError;
  static const Error FeatureUnsupported =
    ResponseJoinGame_Error_FeatureUnsupported;
  static const Error NoSpaceForUser =
    ResponseJoinGame_Error_NoSpaceForUser;
  static const Error MapDoesNotExist =
    ResponseJoinGame_Error_MapDoesNotExist;
  static const Error CannotOpenMap =
    ResponseJoinGame_Error_CannotOpenMap;
  static const Error ChecksumError =
    ResponseJoinGame_Error_ChecksumError;
  static const Error NetworkError =
    ResponseJoinGame_Error_NetworkError;
  static const Error OtherError =
    ResponseJoinGame_Error_OtherError;
  static inline bool Error_IsValid(int value) {
    return ResponseJoinGame_Error_IsValid(value);
  }
  static const Error Error_MIN =
    ResponseJoinGame_Error_Error_MIN;
  static const Error Error_MAX =
    ResponseJoinGame_Error_Error_MAX;
  static const int Error_ARRAYSIZE =
    ResponseJoinGame_Error_Error_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Error_descriptor() {
    return ResponseJoinGame_Error_descriptor();
  }
  static inline const ::std::string& Error_Name(Error value) {
    return ResponseJoinGame_Error_Name(value);
  }
  static inline bool Error_Parse(const ::std::string& name,
      Error* value) {
    return ResponseJoinGame_Error_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string error_details = 3;
  bool has_error_details() const;
  void clear_error_details();
  static const int kErrorDetailsFieldNumber = 3;
  const ::std::string& error_details() const;
  void set_error_details(const ::std::string& value);
  #if LANG_CXX11
  void set_error_details(::std::string&& value);
  #endif
  void set_error_details(const char* value);
  void set_error_details(const char* value, size_t size);
  ::std::string* mutable_error_details();
  ::std::string* release_error_details();
  void set_allocated_error_details(::std::string* error_details);

  // optional uint32 player_id = 1;
  bool has_player_id() const;
  void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  ::google::protobuf::uint32 player_id() const;
  void set_player_id(::google::protobuf::uint32 value);

  // optional .SC2APIProtocol.ResponseJoinGame.Error error = 2;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  ::SC2APIProtocol::ResponseJoinGame_Error error() const;
  void set_error(::SC2APIProtocol::ResponseJoinGame_Error value);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseJoinGame)
 private:
  void set_has_player_id();
  void clear_has_player_id();
  void set_has_error();
  void clear_has_error();
  void set_has_error_details();
  void clear_has_error_details();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr error_details_;
  ::google::protobuf::uint32 player_id_;
  int error_;
  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestRestartGame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestRestartGame) */ {
 public:
  RequestRestartGame();
  virtual ~RequestRestartGame();

  RequestRestartGame(const RequestRestartGame& from);

  inline RequestRestartGame& operator=(const RequestRestartGame& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestRestartGame(RequestRestartGame&& from) noexcept
    : RequestRestartGame() {
    *this = ::std::move(from);
  }

  inline RequestRestartGame& operator=(RequestRestartGame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestRestartGame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestRestartGame* internal_default_instance() {
    return reinterpret_cast<const RequestRestartGame*>(
               &_RequestRestartGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(RequestRestartGame* other);
  friend void swap(RequestRestartGame& a, RequestRestartGame& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestRestartGame* New() const final {
    return CreateMaybeMessage<RequestRestartGame>(NULL);
  }

  RequestRestartGame* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestRestartGame>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestRestartGame& from);
  void MergeFrom(const RequestRestartGame& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestRestartGame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestRestartGame)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseRestartGame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseRestartGame) */ {
 public:
  ResponseRestartGame();
  virtual ~ResponseRestartGame();

  ResponseRestartGame(const ResponseRestartGame& from);

  inline ResponseRestartGame& operator=(const ResponseRestartGame& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseRestartGame(ResponseRestartGame&& from) noexcept
    : ResponseRestartGame() {
    *this = ::std::move(from);
  }

  inline ResponseRestartGame& operator=(ResponseRestartGame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseRestartGame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseRestartGame* internal_default_instance() {
    return reinterpret_cast<const ResponseRestartGame*>(
               &_ResponseRestartGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(ResponseRestartGame* other);
  friend void swap(ResponseRestartGame& a, ResponseRestartGame& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseRestartGame* New() const final {
    return CreateMaybeMessage<ResponseRestartGame>(NULL);
  }

  ResponseRestartGame* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseRestartGame>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResponseRestartGame& from);
  void MergeFrom(const ResponseRestartGame& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseRestartGame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResponseRestartGame_Error Error;
  static const Error LaunchError =
    ResponseRestartGame_Error_LaunchError;
  static inline bool Error_IsValid(int value) {
    return ResponseRestartGame_Error_IsValid(value);
  }
  static const Error Error_MIN =
    ResponseRestartGame_Error_Error_MIN;
  static const Error Error_MAX =
    ResponseRestartGame_Error_Error_MAX;
  static const int Error_ARRAYSIZE =
    ResponseRestartGame_Error_Error_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Error_descriptor() {
    return ResponseRestartGame_Error_descriptor();
  }
  static inline const ::std::string& Error_Name(Error value) {
    return ResponseRestartGame_Error_Name(value);
  }
  static inline bool Error_Parse(const ::std::string& name,
      Error* value) {
    return ResponseRestartGame_Error_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string error_details = 2;
  bool has_error_details() const;
  void clear_error_details();
  static const int kErrorDetailsFieldNumber = 2;
  const ::std::string& error_details() const;
  void set_error_details(const ::std::string& value);
  #if LANG_CXX11
  void set_error_details(::std::string&& value);
  #endif
  void set_error_details(const char* value);
  void set_error_details(const char* value, size_t size);
  ::std::string* mutable_error_details();
  ::std::string* release_error_details();
  void set_allocated_error_details(::std::string* error_details);

  // optional .SC2APIProtocol.ResponseRestartGame.Error error = 1;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  ::SC2APIProtocol::ResponseRestartGame_Error error() const;
  void set_error(::SC2APIProtocol::ResponseRestartGame_Error value);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseRestartGame)
 private:
  void set_has_error();
  void clear_has_error();
  void set_has_error_details();
  void clear_has_error_details();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr error_details_;
  int error_;
  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestStartReplay : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestStartReplay) */ {
 public:
  RequestStartReplay();
  virtual ~RequestStartReplay();

  RequestStartReplay(const RequestStartReplay& from);

  inline RequestStartReplay& operator=(const RequestStartReplay& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestStartReplay(RequestStartReplay&& from) noexcept
    : RequestStartReplay() {
    *this = ::std::move(from);
  }

  inline RequestStartReplay& operator=(RequestStartReplay&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestStartReplay& default_instance();

  enum ReplayCase {
    kReplayPath = 1,
    kReplayData = 5,
    REPLAY_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestStartReplay* internal_default_instance() {
    return reinterpret_cast<const RequestStartReplay*>(
               &_RequestStartReplay_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(RequestStartReplay* other);
  friend void swap(RequestStartReplay& a, RequestStartReplay& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestStartReplay* New() const final {
    return CreateMaybeMessage<RequestStartReplay>(NULL);
  }

  RequestStartReplay* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestStartReplay>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestStartReplay& from);
  void MergeFrom(const RequestStartReplay& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestStartReplay* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes map_data = 6;
  bool has_map_data() const;
  void clear_map_data();
  static const int kMapDataFieldNumber = 6;
  const ::std::string& map_data() const;
  void set_map_data(const ::std::string& value);
  #if LANG_CXX11
  void set_map_data(::std::string&& value);
  #endif
  void set_map_data(const char* value);
  void set_map_data(const void* value, size_t size);
  ::std::string* mutable_map_data();
  ::std::string* release_map_data();
  void set_allocated_map_data(::std::string* map_data);

  // optional .SC2APIProtocol.InterfaceOptions options = 3;
  bool has_options() const;
  void clear_options();
  static const int kOptionsFieldNumber = 3;
  private:
  const ::SC2APIProtocol::InterfaceOptions& _internal_options() const;
  public:
  const ::SC2APIProtocol::InterfaceOptions& options() const;
  ::SC2APIProtocol::InterfaceOptions* release_options();
  ::SC2APIProtocol::InterfaceOptions* mutable_options();
  void set_allocated_options(::SC2APIProtocol::InterfaceOptions* options);

  // optional int32 observed_player_id = 2;
  bool has_observed_player_id() const;
  void clear_observed_player_id();
  static const int kObservedPlayerIdFieldNumber = 2;
  ::google::protobuf::int32 observed_player_id() const;
  void set_observed_player_id(::google::protobuf::int32 value);

  // optional bool disable_fog = 4;
  bool has_disable_fog() const;
  void clear_disable_fog();
  static const int kDisableFogFieldNumber = 4;
  bool disable_fog() const;
  void set_disable_fog(bool value);

  // optional bool realtime = 7;
  bool has_realtime() const;
  void clear_realtime();
  static const int kRealtimeFieldNumber = 7;
  bool realtime() const;
  void set_realtime(bool value);

  // optional string replay_path = 1;
  bool has_replay_path() const;
  void clear_replay_path();
  static const int kReplayPathFieldNumber = 1;
  const ::std::string& replay_path() const;
  void set_replay_path(const ::std::string& value);
  #if LANG_CXX11
  void set_replay_path(::std::string&& value);
  #endif
  void set_replay_path(const char* value);
  void set_replay_path(const char* value, size_t size);
  ::std::string* mutable_replay_path();
  ::std::string* release_replay_path();
  void set_allocated_replay_path(::std::string* replay_path);

  // optional bytes replay_data = 5;
  bool has_replay_data() const;
  void clear_replay_data();
  static const int kReplayDataFieldNumber = 5;
  const ::std::string& replay_data() const;
  void set_replay_data(const ::std::string& value);
  #if LANG_CXX11
  void set_replay_data(::std::string&& value);
  #endif
  void set_replay_data(const char* value);
  void set_replay_data(const void* value, size_t size);
  ::std::string* mutable_replay_data();
  ::std::string* release_replay_data();
  void set_allocated_replay_data(::std::string* replay_data);

  void clear_replay();
  ReplayCase replay_case() const;
  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestStartReplay)
 private:
  void set_has_replay_path();
  void set_has_replay_data();
  void set_has_map_data();
  void clear_has_map_data();
  void set_has_observed_player_id();
  void clear_has_observed_player_id();
  void set_has_options();
  void clear_has_options();
  void set_has_disable_fog();
  void clear_has_disable_fog();
  void set_has_realtime();
  void clear_has_realtime();

  inline bool has_replay() const;
  inline void clear_has_replay();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr map_data_;
  ::SC2APIProtocol::InterfaceOptions* options_;
  ::google::protobuf::int32 observed_player_id_;
  bool disable_fog_;
  bool realtime_;
  union ReplayUnion {
    ReplayUnion() {}
    ::google::protobuf::internal::ArenaStringPtr replay_path_;
    ::google::protobuf::internal::ArenaStringPtr replay_data_;
  } replay_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseStartReplay : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseStartReplay) */ {
 public:
  ResponseStartReplay();
  virtual ~ResponseStartReplay();

  ResponseStartReplay(const ResponseStartReplay& from);

  inline ResponseStartReplay& operator=(const ResponseStartReplay& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseStartReplay(ResponseStartReplay&& from) noexcept
    : ResponseStartReplay() {
    *this = ::std::move(from);
  }

  inline ResponseStartReplay& operator=(ResponseStartReplay&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseStartReplay& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseStartReplay* internal_default_instance() {
    return reinterpret_cast<const ResponseStartReplay*>(
               &_ResponseStartReplay_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(ResponseStartReplay* other);
  friend void swap(ResponseStartReplay& a, ResponseStartReplay& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseStartReplay* New() const final {
    return CreateMaybeMessage<ResponseStartReplay>(NULL);
  }

  ResponseStartReplay* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseStartReplay>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResponseStartReplay& from);
  void MergeFrom(const ResponseStartReplay& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseStartReplay* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResponseStartReplay_Error Error;
  static const Error MissingReplay =
    ResponseStartReplay_Error_MissingReplay;
  static const Error InvalidReplayPath =
    ResponseStartReplay_Error_InvalidReplayPath;
  static const Error InvalidReplayData =
    ResponseStartReplay_Error_InvalidReplayData;
  static const Error InvalidMapData =
    ResponseStartReplay_Error_InvalidMapData;
  static const Error InvalidObservedPlayerId =
    ResponseStartReplay_Error_InvalidObservedPlayerId;
  static const Error MissingOptions =
    ResponseStartReplay_Error_MissingOptions;
  static const Error LaunchError =
    ResponseStartReplay_Error_LaunchError;
  static inline bool Error_IsValid(int value) {
    return ResponseStartReplay_Error_IsValid(value);
  }
  static const Error Error_MIN =
    ResponseStartReplay_Error_Error_MIN;
  static const Error Error_MAX =
    ResponseStartReplay_Error_Error_MAX;
  static const int Error_ARRAYSIZE =
    ResponseStartReplay_Error_Error_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Error_descriptor() {
    return ResponseStartReplay_Error_descriptor();
  }
  static inline const ::std::string& Error_Name(Error value) {
    return ResponseStartReplay_Error_Name(value);
  }
  static inline bool Error_Parse(const ::std::string& name,
      Error* value) {
    return ResponseStartReplay_Error_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string error_details = 2;
  bool has_error_details() const;
  void clear_error_details();
  static const int kErrorDetailsFieldNumber = 2;
  const ::std::string& error_details() const;
  void set_error_details(const ::std::string& value);
  #if LANG_CXX11
  void set_error_details(::std::string&& value);
  #endif
  void set_error_details(const char* value);
  void set_error_details(const char* value, size_t size);
  ::std::string* mutable_error_details();
  ::std::string* release_error_details();
  void set_allocated_error_details(::std::string* error_details);

  // optional .SC2APIProtocol.ResponseStartReplay.Error error = 1;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  ::SC2APIProtocol::ResponseStartReplay_Error error() const;
  void set_error(::SC2APIProtocol::ResponseStartReplay_Error value);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseStartReplay)
 private:
  void set_has_error();
  void clear_has_error();
  void set_has_error_details();
  void clear_has_error_details();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr error_details_;
  int error_;
  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestLeaveGame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestLeaveGame) */ {
 public:
  RequestLeaveGame();
  virtual ~RequestLeaveGame();

  RequestLeaveGame(const RequestLeaveGame& from);

  inline RequestLeaveGame& operator=(const RequestLeaveGame& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestLeaveGame(RequestLeaveGame&& from) noexcept
    : RequestLeaveGame() {
    *this = ::std::move(from);
  }

  inline RequestLeaveGame& operator=(RequestLeaveGame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestLeaveGame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestLeaveGame* internal_default_instance() {
    return reinterpret_cast<const RequestLeaveGame*>(
               &_RequestLeaveGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(RequestLeaveGame* other);
  friend void swap(RequestLeaveGame& a, RequestLeaveGame& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestLeaveGame* New() const final {
    return CreateMaybeMessage<RequestLeaveGame>(NULL);
  }

  RequestLeaveGame* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestLeaveGame>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestLeaveGame& from);
  void MergeFrom(const RequestLeaveGame& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestLeaveGame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestLeaveGame)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseLeaveGame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseLeaveGame) */ {
 public:
  ResponseLeaveGame();
  virtual ~ResponseLeaveGame();

  ResponseLeaveGame(const ResponseLeaveGame& from);

  inline ResponseLeaveGame& operator=(const ResponseLeaveGame& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseLeaveGame(ResponseLeaveGame&& from) noexcept
    : ResponseLeaveGame() {
    *this = ::std::move(from);
  }

  inline ResponseLeaveGame& operator=(ResponseLeaveGame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseLeaveGame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseLeaveGame* internal_default_instance() {
    return reinterpret_cast<const ResponseLeaveGame*>(
               &_ResponseLeaveGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(ResponseLeaveGame* other);
  friend void swap(ResponseLeaveGame& a, ResponseLeaveGame& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseLeaveGame* New() const final {
    return CreateMaybeMessage<ResponseLeaveGame>(NULL);
  }

  ResponseLeaveGame* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseLeaveGame>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResponseLeaveGame& from);
  void MergeFrom(const ResponseLeaveGame& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseLeaveGame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseLeaveGame)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestQuickSave : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestQuickSave) */ {
 public:
  RequestQuickSave();
  virtual ~RequestQuickSave();

  RequestQuickSave(const RequestQuickSave& from);

  inline RequestQuickSave& operator=(const RequestQuickSave& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestQuickSave(RequestQuickSave&& from) noexcept
    : RequestQuickSave() {
    *this = ::std::move(from);
  }

  inline RequestQuickSave& operator=(RequestQuickSave&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestQuickSave& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestQuickSave* internal_default_instance() {
    return reinterpret_cast<const RequestQuickSave*>(
               &_RequestQuickSave_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(RequestQuickSave* other);
  friend void swap(RequestQuickSave& a, RequestQuickSave& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestQuickSave* New() const final {
    return CreateMaybeMessage<RequestQuickSave>(NULL);
  }

  RequestQuickSave* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestQuickSave>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestQuickSave& from);
  void MergeFrom(const RequestQuickSave& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestQuickSave* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestQuickSave)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseQuickSave : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseQuickSave) */ {
 public:
  ResponseQuickSave();
  virtual ~ResponseQuickSave();

  ResponseQuickSave(const ResponseQuickSave& from);

  inline ResponseQuickSave& operator=(const ResponseQuickSave& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseQuickSave(ResponseQuickSave&& from) noexcept
    : ResponseQuickSave() {
    *this = ::std::move(from);
  }

  inline ResponseQuickSave& operator=(ResponseQuickSave&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseQuickSave& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseQuickSave* internal_default_instance() {
    return reinterpret_cast<const ResponseQuickSave*>(
               &_ResponseQuickSave_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(ResponseQuickSave* other);
  friend void swap(ResponseQuickSave& a, ResponseQuickSave& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseQuickSave* New() const final {
    return CreateMaybeMessage<ResponseQuickSave>(NULL);
  }

  ResponseQuickSave* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseQuickSave>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResponseQuickSave& from);
  void MergeFrom(const ResponseQuickSave& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseQuickSave* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseQuickSave)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestQuickLoad : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestQuickLoad) */ {
 public:
  RequestQuickLoad();
  virtual ~RequestQuickLoad();

  RequestQuickLoad(const RequestQuickLoad& from);

  inline RequestQuickLoad& operator=(const RequestQuickLoad& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestQuickLoad(RequestQuickLoad&& from) noexcept
    : RequestQuickLoad() {
    *this = ::std::move(from);
  }

  inline RequestQuickLoad& operator=(RequestQuickLoad&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestQuickLoad& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestQuickLoad* internal_default_instance() {
    return reinterpret_cast<const RequestQuickLoad*>(
               &_RequestQuickLoad_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(RequestQuickLoad* other);
  friend void swap(RequestQuickLoad& a, RequestQuickLoad& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestQuickLoad* New() const final {
    return CreateMaybeMessage<RequestQuickLoad>(NULL);
  }

  RequestQuickLoad* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestQuickLoad>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestQuickLoad& from);
  void MergeFrom(const RequestQuickLoad& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestQuickLoad* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestQuickLoad)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseQuickLoad : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseQuickLoad) */ {
 public:
  ResponseQuickLoad();
  virtual ~ResponseQuickLoad();

  ResponseQuickLoad(const ResponseQuickLoad& from);

  inline ResponseQuickLoad& operator=(const ResponseQuickLoad& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseQuickLoad(ResponseQuickLoad&& from) noexcept
    : ResponseQuickLoad() {
    *this = ::std::move(from);
  }

  inline ResponseQuickLoad& operator=(ResponseQuickLoad&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseQuickLoad& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseQuickLoad* internal_default_instance() {
    return reinterpret_cast<const ResponseQuickLoad*>(
               &_ResponseQuickLoad_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(ResponseQuickLoad* other);
  friend void swap(ResponseQuickLoad& a, ResponseQuickLoad& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseQuickLoad* New() const final {
    return CreateMaybeMessage<ResponseQuickLoad>(NULL);
  }

  ResponseQuickLoad* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseQuickLoad>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResponseQuickLoad& from);
  void MergeFrom(const ResponseQuickLoad& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseQuickLoad* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseQuickLoad)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestQuit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestQuit) */ {
 public:
  RequestQuit();
  virtual ~RequestQuit();

  RequestQuit(const RequestQuit& from);

  inline RequestQuit& operator=(const RequestQuit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestQuit(RequestQuit&& from) noexcept
    : RequestQuit() {
    *this = ::std::move(from);
  }

  inline RequestQuit& operator=(RequestQuit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestQuit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestQuit* internal_default_instance() {
    return reinterpret_cast<const RequestQuit*>(
               &_RequestQuit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(RequestQuit* other);
  friend void swap(RequestQuit& a, RequestQuit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestQuit* New() const final {
    return CreateMaybeMessage<RequestQuit>(NULL);
  }

  RequestQuit* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestQuit>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestQuit& from);
  void MergeFrom(const RequestQuit& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestQuit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestQuit)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseQuit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseQuit) */ {
 public:
  ResponseQuit();
  virtual ~ResponseQuit();

  ResponseQuit(const ResponseQuit& from);

  inline ResponseQuit& operator=(const ResponseQuit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseQuit(ResponseQuit&& from) noexcept
    : ResponseQuit() {
    *this = ::std::move(from);
  }

  inline ResponseQuit& operator=(ResponseQuit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseQuit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseQuit* internal_default_instance() {
    return reinterpret_cast<const ResponseQuit*>(
               &_ResponseQuit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(ResponseQuit* other);
  friend void swap(ResponseQuit& a, ResponseQuit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseQuit* New() const final {
    return CreateMaybeMessage<ResponseQuit>(NULL);
  }

  ResponseQuit* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseQuit>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResponseQuit& from);
  void MergeFrom(const ResponseQuit& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseQuit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseQuit)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestGameInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestGameInfo) */ {
 public:
  RequestGameInfo();
  virtual ~RequestGameInfo();

  RequestGameInfo(const RequestGameInfo& from);

  inline RequestGameInfo& operator=(const RequestGameInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestGameInfo(RequestGameInfo&& from) noexcept
    : RequestGameInfo() {
    *this = ::std::move(from);
  }

  inline RequestGameInfo& operator=(RequestGameInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestGameInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestGameInfo* internal_default_instance() {
    return reinterpret_cast<const RequestGameInfo*>(
               &_RequestGameInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(RequestGameInfo* other);
  friend void swap(RequestGameInfo& a, RequestGameInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestGameInfo* New() const final {
    return CreateMaybeMessage<RequestGameInfo>(NULL);
  }

  RequestGameInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestGameInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestGameInfo& from);
  void MergeFrom(const RequestGameInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestGameInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestGameInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseGameInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseGameInfo) */ {
 public:
  ResponseGameInfo();
  virtual ~ResponseGameInfo();

  ResponseGameInfo(const ResponseGameInfo& from);

  inline ResponseGameInfo& operator=(const ResponseGameInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseGameInfo(ResponseGameInfo&& from) noexcept
    : ResponseGameInfo() {
    *this = ::std::move(from);
  }

  inline ResponseGameInfo& operator=(ResponseGameInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseGameInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseGameInfo* internal_default_instance() {
    return reinterpret_cast<const ResponseGameInfo*>(
               &_ResponseGameInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(ResponseGameInfo* other);
  friend void swap(ResponseGameInfo& a, ResponseGameInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseGameInfo* New() const final {
    return CreateMaybeMessage<ResponseGameInfo>(NULL);
  }

  ResponseGameInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseGameInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResponseGameInfo& from);
  void MergeFrom(const ResponseGameInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseGameInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SC2APIProtocol.PlayerInfo player_info = 3;
  int player_info_size() const;
  void clear_player_info();
  static const int kPlayerInfoFieldNumber = 3;
  ::SC2APIProtocol::PlayerInfo* mutable_player_info(int index);
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PlayerInfo >*
      mutable_player_info();
  const ::SC2APIProtocol::PlayerInfo& player_info(int index) const;
  ::SC2APIProtocol::PlayerInfo* add_player_info();
  const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PlayerInfo >&
      player_info() const;

  // repeated string mod_names = 6;
  int mod_names_size() const;
  void clear_mod_names();
  static const int kModNamesFieldNumber = 6;
  const ::std::string& mod_names(int index) const;
  ::std::string* mutable_mod_names(int index);
  void set_mod_names(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_mod_names(int index, ::std::string&& value);
  #endif
  void set_mod_names(int index, const char* value);
  void set_mod_names(int index, const char* value, size_t size);
  ::std::string* add_mod_names();
  void add_mod_names(const ::std::string& value);
  #if LANG_CXX11
  void add_mod_names(::std::string&& value);
  #endif
  void add_mod_names(const char* value);
  void add_mod_names(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& mod_names() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_mod_names();

  // optional string map_name = 1;
  bool has_map_name() const;
  void clear_map_name();
  static const int kMapNameFieldNumber = 1;
  const ::std::string& map_name() const;
  void set_map_name(const ::std::string& value);
  #if LANG_CXX11
  void set_map_name(::std::string&& value);
  #endif
  void set_map_name(const char* value);
  void set_map_name(const char* value, size_t size);
  ::std::string* mutable_map_name();
  ::std::string* release_map_name();
  void set_allocated_map_name(::std::string* map_name);

  // optional string local_map_path = 2;
  bool has_local_map_path() const;
  void clear_local_map_path();
  static const int kLocalMapPathFieldNumber = 2;
  const ::std::string& local_map_path() const;
  void set_local_map_path(const ::std::string& value);
  #if LANG_CXX11
  void set_local_map_path(::std::string&& value);
  #endif
  void set_local_map_path(const char* value);
  void set_local_map_path(const char* value, size_t size);
  ::std::string* mutable_local_map_path();
  ::std::string* release_local_map_path();
  void set_allocated_local_map_path(::std::string* local_map_path);

  // optional .SC2APIProtocol.StartRaw start_raw = 4;
  bool has_start_raw() const;
  void clear_start_raw();
  static const int kStartRawFieldNumber = 4;
  private:
  const ::SC2APIProtocol::StartRaw& _internal_start_raw() const;
  public:
  const ::SC2APIProtocol::StartRaw& start_raw() const;
  ::SC2APIProtocol::StartRaw* release_start_raw();
  ::SC2APIProtocol::StartRaw* mutable_start_raw();
  void set_allocated_start_raw(::SC2APIProtocol::StartRaw* start_raw);

  // optional .SC2APIProtocol.InterfaceOptions options = 5;
  bool has_options() const;
  void clear_options();
  static const int kOptionsFieldNumber = 5;
  private:
  const ::SC2APIProtocol::InterfaceOptions& _internal_options() const;
  public:
  const ::SC2APIProtocol::InterfaceOptions& options() const;
  ::SC2APIProtocol::InterfaceOptions* release_options();
  ::SC2APIProtocol::InterfaceOptions* mutable_options();
  void set_allocated_options(::SC2APIProtocol::InterfaceOptions* options);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseGameInfo)
 private:
  void set_has_map_name();
  void clear_has_map_name();
  void set_has_local_map_path();
  void clear_has_local_map_path();
  void set_has_start_raw();
  void clear_has_start_raw();
  void set_has_options();
  void clear_has_options();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PlayerInfo > player_info_;
  ::google::protobuf::RepeatedPtrField< ::std::string> mod_names_;
  ::google::protobuf::internal::ArenaStringPtr map_name_;
  ::google::protobuf::internal::ArenaStringPtr local_map_path_;
  ::SC2APIProtocol::StartRaw* start_raw_;
  ::SC2APIProtocol::InterfaceOptions* options_;
  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestObservation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestObservation) */ {
 public:
  RequestObservation();
  virtual ~RequestObservation();

  RequestObservation(const RequestObservation& from);

  inline RequestObservation& operator=(const RequestObservation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestObservation(RequestObservation&& from) noexcept
    : RequestObservation() {
    *this = ::std::move(from);
  }

  inline RequestObservation& operator=(RequestObservation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestObservation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestObservation* internal_default_instance() {
    return reinterpret_cast<const RequestObservation*>(
               &_RequestObservation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(RequestObservation* other);
  friend void swap(RequestObservation& a, RequestObservation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestObservation* New() const final {
    return CreateMaybeMessage<RequestObservation>(NULL);
  }

  RequestObservation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestObservation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestObservation& from);
  void MergeFrom(const RequestObservation& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestObservation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool disable_fog = 1;
  bool has_disable_fog() const;
  void clear_disable_fog();
  static const int kDisableFogFieldNumber = 1;
  bool disable_fog() const;
  void set_disable_fog(bool value);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestObservation)
 private:
  void set_has_disable_fog();
  void clear_has_disable_fog();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool disable_fog_;
  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseObservation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseObservation) */ {
 public:
  ResponseObservation();
  virtual ~ResponseObservation();

  ResponseObservation(const ResponseObservation& from);

  inline ResponseObservation& operator=(const ResponseObservation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseObservation(ResponseObservation&& from) noexcept
    : ResponseObservation() {
    *this = ::std::move(from);
  }

  inline ResponseObservation& operator=(ResponseObservation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseObservation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseObservation* internal_default_instance() {
    return reinterpret_cast<const ResponseObservation*>(
               &_ResponseObservation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(ResponseObservation* other);
  friend void swap(ResponseObservation& a, ResponseObservation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseObservation* New() const final {
    return CreateMaybeMessage<ResponseObservation>(NULL);
  }

  ResponseObservation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseObservation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResponseObservation& from);
  void MergeFrom(const ResponseObservation& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseObservation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SC2APIProtocol.Action actions = 1;
  int actions_size() const;
  void clear_actions();
  static const int kActionsFieldNumber = 1;
  ::SC2APIProtocol::Action* mutable_actions(int index);
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::Action >*
      mutable_actions();
  const ::SC2APIProtocol::Action& actions(int index) const;
  ::SC2APIProtocol::Action* add_actions();
  const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::Action >&
      actions() const;

  // repeated .SC2APIProtocol.ActionError action_errors = 2;
  int action_errors_size() const;
  void clear_action_errors();
  static const int kActionErrorsFieldNumber = 2;
  ::SC2APIProtocol::ActionError* mutable_action_errors(int index);
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::ActionError >*
      mutable_action_errors();
  const ::SC2APIProtocol::ActionError& action_errors(int index) const;
  ::SC2APIProtocol::ActionError* add_action_errors();
  const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::ActionError >&
      action_errors() const;

  // repeated .SC2APIProtocol.PlayerResult player_result = 4;
  int player_result_size() const;
  void clear_player_result();
  static const int kPlayerResultFieldNumber = 4;
  ::SC2APIProtocol::PlayerResult* mutable_player_result(int index);
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PlayerResult >*
      mutable_player_result();
  const ::SC2APIProtocol::PlayerResult& player_result(int index) const;
  ::SC2APIProtocol::PlayerResult* add_player_result();
  const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PlayerResult >&
      player_result() const;

  // repeated .SC2APIProtocol.ChatReceived chat = 5;
  int chat_size() const;
  void clear_chat();
  static const int kChatFieldNumber = 5;
  ::SC2APIProtocol::ChatReceived* mutable_chat(int index);
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::ChatReceived >*
      mutable_chat();
  const ::SC2APIProtocol::ChatReceived& chat(int index) const;
  ::SC2APIProtocol::ChatReceived* add_chat();
  const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::ChatReceived >&
      chat() const;

  // optional .SC2APIProtocol.Observation observation = 3;
  bool has_observation() const;
  void clear_observation();
  static const int kObservationFieldNumber = 3;
  private:
  const ::SC2APIProtocol::Observation& _internal_observation() const;
  public:
  const ::SC2APIProtocol::Observation& observation() const;
  ::SC2APIProtocol::Observation* release_observation();
  ::SC2APIProtocol::Observation* mutable_observation();
  void set_allocated_observation(::SC2APIProtocol::Observation* observation);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseObservation)
 private:
  void set_has_observation();
  void clear_has_observation();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::Action > actions_;
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::ActionError > action_errors_;
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PlayerResult > player_result_;
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::ChatReceived > chat_;
  ::SC2APIProtocol::Observation* observation_;
  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ChatReceived : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ChatReceived) */ {
 public:
  ChatReceived();
  virtual ~ChatReceived();

  ChatReceived(const ChatReceived& from);

  inline ChatReceived& operator=(const ChatReceived& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChatReceived(ChatReceived&& from) noexcept
    : ChatReceived() {
    *this = ::std::move(from);
  }

  inline ChatReceived& operator=(ChatReceived&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChatReceived& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChatReceived* internal_default_instance() {
    return reinterpret_cast<const ChatReceived*>(
               &_ChatReceived_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(ChatReceived* other);
  friend void swap(ChatReceived& a, ChatReceived& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChatReceived* New() const final {
    return CreateMaybeMessage<ChatReceived>(NULL);
  }

  ChatReceived* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ChatReceived>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ChatReceived& from);
  void MergeFrom(const ChatReceived& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChatReceived* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string message = 2;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // optional uint32 player_id = 1;
  bool has_player_id() const;
  void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  ::google::protobuf::uint32 player_id() const;
  void set_player_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ChatReceived)
 private:
  void set_has_player_id();
  void clear_has_player_id();
  void set_has_message();
  void clear_has_message();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::uint32 player_id_;
  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestAction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestAction) */ {
 public:
  RequestAction();
  virtual ~RequestAction();

  RequestAction(const RequestAction& from);

  inline RequestAction& operator=(const RequestAction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestAction(RequestAction&& from) noexcept
    : RequestAction() {
    *this = ::std::move(from);
  }

  inline RequestAction& operator=(RequestAction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestAction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestAction* internal_default_instance() {
    return reinterpret_cast<const RequestAction*>(
               &_RequestAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(RequestAction* other);
  friend void swap(RequestAction& a, RequestAction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestAction* New() const final {
    return CreateMaybeMessage<RequestAction>(NULL);
  }

  RequestAction* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestAction>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestAction& from);
  void MergeFrom(const RequestAction& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestAction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SC2APIProtocol.Action actions = 1;
  int actions_size() const;
  void clear_actions();
  static const int kActionsFieldNumber = 1;
  ::SC2APIProtocol::Action* mutable_actions(int index);
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::Action >*
      mutable_actions();
  const ::SC2APIProtocol::Action& actions(int index) const;
  ::SC2APIProtocol::Action* add_actions();
  const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::Action >&
      actions() const;

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestAction)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::Action > actions_;
  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseAction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseAction) */ {
 public:
  ResponseAction();
  virtual ~ResponseAction();

  ResponseAction(const ResponseAction& from);

  inline ResponseAction& operator=(const ResponseAction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseAction(ResponseAction&& from) noexcept
    : ResponseAction() {
    *this = ::std::move(from);
  }

  inline ResponseAction& operator=(ResponseAction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseAction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseAction* internal_default_instance() {
    return reinterpret_cast<const ResponseAction*>(
               &_ResponseAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(ResponseAction* other);
  friend void swap(ResponseAction& a, ResponseAction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseAction* New() const final {
    return CreateMaybeMessage<ResponseAction>(NULL);
  }

  ResponseAction* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseAction>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResponseAction& from);
  void MergeFrom(const ResponseAction& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseAction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SC2APIProtocol.ActionResult result = 1;
  int result_size() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::SC2APIProtocol::ActionResult result(int index) const;
  void set_result(int index, ::SC2APIProtocol::ActionResult value);
  void add_result(::SC2APIProtocol::ActionResult value);
  const ::google::protobuf::RepeatedField<int>& result() const;
  ::google::protobuf::RepeatedField<int>* mutable_result();

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseAction)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField<int> result_;
  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestObserverAction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestObserverAction) */ {
 public:
  RequestObserverAction();
  virtual ~RequestObserverAction();

  RequestObserverAction(const RequestObserverAction& from);

  inline RequestObserverAction& operator=(const RequestObserverAction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestObserverAction(RequestObserverAction&& from) noexcept
    : RequestObserverAction() {
    *this = ::std::move(from);
  }

  inline RequestObserverAction& operator=(RequestObserverAction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestObserverAction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestObserverAction* internal_default_instance() {
    return reinterpret_cast<const RequestObserverAction*>(
               &_RequestObserverAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(RequestObserverAction* other);
  friend void swap(RequestObserverAction& a, RequestObserverAction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestObserverAction* New() const final {
    return CreateMaybeMessage<RequestObserverAction>(NULL);
  }

  RequestObserverAction* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestObserverAction>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestObserverAction& from);
  void MergeFrom(const RequestObserverAction& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestObserverAction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SC2APIProtocol.ObserverAction actions = 1;
  int actions_size() const;
  void clear_actions();
  static const int kActionsFieldNumber = 1;
  ::SC2APIProtocol::ObserverAction* mutable_actions(int index);
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::ObserverAction >*
      mutable_actions();
  const ::SC2APIProtocol::ObserverAction& actions(int index) const;
  ::SC2APIProtocol::ObserverAction* add_actions();
  const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::ObserverAction >&
      actions() const;

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestObserverAction)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::ObserverAction > actions_;
  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseObserverAction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseObserverAction) */ {
 public:
  ResponseObserverAction();
  virtual ~ResponseObserverAction();

  ResponseObserverAction(const ResponseObserverAction& from);

  inline ResponseObserverAction& operator=(const ResponseObserverAction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseObserverAction(ResponseObserverAction&& from) noexcept
    : ResponseObserverAction() {
    *this = ::std::move(from);
  }

  inline ResponseObserverAction& operator=(ResponseObserverAction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseObserverAction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseObserverAction* internal_default_instance() {
    return reinterpret_cast<const ResponseObserverAction*>(
               &_ResponseObserverAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(ResponseObserverAction* other);
  friend void swap(ResponseObserverAction& a, ResponseObserverAction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseObserverAction* New() const final {
    return CreateMaybeMessage<ResponseObserverAction>(NULL);
  }

  ResponseObserverAction* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseObserverAction>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResponseObserverAction& from);
  void MergeFrom(const ResponseObserverAction& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseObserverAction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseObserverAction)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestStep : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestStep) */ {
 public:
  RequestStep();
  virtual ~RequestStep();

  RequestStep(const RequestStep& from);

  inline RequestStep& operator=(const RequestStep& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestStep(RequestStep&& from) noexcept
    : RequestStep() {
    *this = ::std::move(from);
  }

  inline RequestStep& operator=(RequestStep&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestStep& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestStep* internal_default_instance() {
    return reinterpret_cast<const RequestStep*>(
               &_RequestStep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(RequestStep* other);
  friend void swap(RequestStep& a, RequestStep& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestStep* New() const final {
    return CreateMaybeMessage<RequestStep>(NULL);
  }

  RequestStep* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestStep>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestStep& from);
  void MergeFrom(const RequestStep& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestStep* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 count = 1;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 1;
  ::google::protobuf::uint32 count() const;
  void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestStep)
 private:
  void set_has_count();
  void clear_has_count();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 count_;
  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseStep : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseStep) */ {
 public:
  ResponseStep();
  virtual ~ResponseStep();

  ResponseStep(const ResponseStep& from);

  inline ResponseStep& operator=(const ResponseStep& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseStep(ResponseStep&& from) noexcept
    : ResponseStep() {
    *this = ::std::move(from);
  }

  inline ResponseStep& operator=(ResponseStep&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseStep& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseStep* internal_default_instance() {
    return reinterpret_cast<const ResponseStep*>(
               &_ResponseStep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  void Swap(ResponseStep* other);
  friend void swap(ResponseStep& a, ResponseStep& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseStep* New() const final {
    return CreateMaybeMessage<ResponseStep>(NULL);
  }

  ResponseStep* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseStep>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResponseStep& from);
  void MergeFrom(const ResponseStep& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseStep* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseStep)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestData) */ {
 public:
  RequestData();
  virtual ~RequestData();

  RequestData(const RequestData& from);

  inline RequestData& operator=(const RequestData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestData(RequestData&& from) noexcept
    : RequestData() {
    *this = ::std::move(from);
  }

  inline RequestData& operator=(RequestData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestData* internal_default_instance() {
    return reinterpret_cast<const RequestData*>(
               &_RequestData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  void Swap(RequestData* other);
  friend void swap(RequestData& a, RequestData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestData* New() const final {
    return CreateMaybeMessage<RequestData>(NULL);
  }

  RequestData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestData& from);
  void MergeFrom(const RequestData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool ability_id = 1;
  bool has_ability_id() const;
  void clear_ability_id();
  static const int kAbilityIdFieldNumber = 1;
  bool ability_id() const;
  void set_ability_id(bool value);

  // optional bool unit_type_id = 2;
  bool has_unit_type_id() const;
  void clear_unit_type_id();
  static const int kUnitTypeIdFieldNumber = 2;
  bool unit_type_id() const;
  void set_unit_type_id(bool value);

  // optional bool upgrade_id = 3;
  bool has_upgrade_id() const;
  void clear_upgrade_id();
  static const int kUpgradeIdFieldNumber = 3;
  bool upgrade_id() const;
  void set_upgrade_id(bool value);

  // optional bool buff_id = 4;
  bool has_buff_id() const;
  void clear_buff_id();
  static const int kBuffIdFieldNumber = 4;
  bool buff_id() const;
  void set_buff_id(bool value);

  // optional bool effect_id = 5;
  bool has_effect_id() const;
  void clear_effect_id();
  static const int kEffectIdFieldNumber = 5;
  bool effect_id() const;
  void set_effect_id(bool value);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestData)
 private:
  void set_has_ability_id();
  void clear_has_ability_id();
  void set_has_unit_type_id();
  void clear_has_unit_type_id();
  void set_has_upgrade_id();
  void clear_has_upgrade_id();
  void set_has_buff_id();
  void clear_has_buff_id();
  void set_has_effect_id();
  void clear_has_effect_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool ability_id_;
  bool unit_type_id_;
  bool upgrade_id_;
  bool buff_id_;
  bool effect_id_;
  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseData) */ {
 public:
  ResponseData();
  virtual ~ResponseData();

  ResponseData(const ResponseData& from);

  inline ResponseData& operator=(const ResponseData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseData(ResponseData&& from) noexcept
    : ResponseData() {
    *this = ::std::move(from);
  }

  inline ResponseData& operator=(ResponseData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseData* internal_default_instance() {
    return reinterpret_cast<const ResponseData*>(
               &_ResponseData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  void Swap(ResponseData* other);
  friend void swap(ResponseData& a, ResponseData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseData* New() const final {
    return CreateMaybeMessage<ResponseData>(NULL);
  }

  ResponseData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResponseData& from);
  void MergeFrom(const ResponseData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SC2APIProtocol.AbilityData abilities = 1;
  int abilities_size() const;
  void clear_abilities();
  static const int kAbilitiesFieldNumber = 1;
  ::SC2APIProtocol::AbilityData* mutable_abilities(int index);
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::AbilityData >*
      mutable_abilities();
  const ::SC2APIProtocol::AbilityData& abilities(int index) const;
  ::SC2APIProtocol::AbilityData* add_abilities();
  const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::AbilityData >&
      abilities() const;

  // repeated .SC2APIProtocol.UnitTypeData units = 2;
  int units_size() const;
  void clear_units();
  static const int kUnitsFieldNumber = 2;
  ::SC2APIProtocol::UnitTypeData* mutable_units(int index);
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::UnitTypeData >*
      mutable_units();
  const ::SC2APIProtocol::UnitTypeData& units(int index) const;
  ::SC2APIProtocol::UnitTypeData* add_units();
  const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::UnitTypeData >&
      units() const;

  // repeated .SC2APIProtocol.UpgradeData upgrades = 3;
  int upgrades_size() const;
  void clear_upgrades();
  static const int kUpgradesFieldNumber = 3;
  ::SC2APIProtocol::UpgradeData* mutable_upgrades(int index);
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::UpgradeData >*
      mutable_upgrades();
  const ::SC2APIProtocol::UpgradeData& upgrades(int index) const;
  ::SC2APIProtocol::UpgradeData* add_upgrades();
  const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::UpgradeData >&
      upgrades() const;

  // repeated .SC2APIProtocol.BuffData buffs = 4;
  int buffs_size() const;
  void clear_buffs();
  static const int kBuffsFieldNumber = 4;
  ::SC2APIProtocol::BuffData* mutable_buffs(int index);
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::BuffData >*
      mutable_buffs();
  const ::SC2APIProtocol::BuffData& buffs(int index) const;
  ::SC2APIProtocol::BuffData* add_buffs();
  const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::BuffData >&
      buffs() const;

  // repeated .SC2APIProtocol.EffectData effects = 5;
  int effects_size() const;
  void clear_effects();
  static const int kEffectsFieldNumber = 5;
  ::SC2APIProtocol::EffectData* mutable_effects(int index);
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::EffectData >*
      mutable_effects();
  const ::SC2APIProtocol::EffectData& effects(int index) const;
  ::SC2APIProtocol::EffectData* add_effects();
  const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::EffectData >&
      effects() const;

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::AbilityData > abilities_;
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::UnitTypeData > units_;
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::UpgradeData > upgrades_;
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::BuffData > buffs_;
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::EffectData > effects_;
  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestSaveReplay : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestSaveReplay) */ {
 public:
  RequestSaveReplay();
  virtual ~RequestSaveReplay();

  RequestSaveReplay(const RequestSaveReplay& from);

  inline RequestSaveReplay& operator=(const RequestSaveReplay& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestSaveReplay(RequestSaveReplay&& from) noexcept
    : RequestSaveReplay() {
    *this = ::std::move(from);
  }

  inline RequestSaveReplay& operator=(RequestSaveReplay&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestSaveReplay& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestSaveReplay* internal_default_instance() {
    return reinterpret_cast<const RequestSaveReplay*>(
               &_RequestSaveReplay_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  void Swap(RequestSaveReplay* other);
  friend void swap(RequestSaveReplay& a, RequestSaveReplay& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestSaveReplay* New() const final {
    return CreateMaybeMessage<RequestSaveReplay>(NULL);
  }

  RequestSaveReplay* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestSaveReplay>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestSaveReplay& from);
  void MergeFrom(const RequestSaveReplay& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestSaveReplay* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestSaveReplay)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseSaveReplay : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseSaveReplay) */ {
 public:
  ResponseSaveReplay();
  virtual ~ResponseSaveReplay();

  ResponseSaveReplay(const ResponseSaveReplay& from);

  inline ResponseSaveReplay& operator=(const ResponseSaveReplay& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseSaveReplay(ResponseSaveReplay&& from) noexcept
    : ResponseSaveReplay() {
    *this = ::std::move(from);
  }

  inline ResponseSaveReplay& operator=(ResponseSaveReplay&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseSaveReplay& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseSaveReplay* internal_default_instance() {
    return reinterpret_cast<const ResponseSaveReplay*>(
               &_ResponseSaveReplay_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  void Swap(ResponseSaveReplay* other);
  friend void swap(ResponseSaveReplay& a, ResponseSaveReplay& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseSaveReplay* New() const final {
    return CreateMaybeMessage<ResponseSaveReplay>(NULL);
  }

  ResponseSaveReplay* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseSaveReplay>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResponseSaveReplay& from);
  void MergeFrom(const ResponseSaveReplay& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseSaveReplay* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes data = 1;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 1;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseSaveReplay)
 private:
  void set_has_data();
  void clear_has_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestReplayInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestReplayInfo) */ {
 public:
  RequestReplayInfo();
  virtual ~RequestReplayInfo();

  RequestReplayInfo(const RequestReplayInfo& from);

  inline RequestReplayInfo& operator=(const RequestReplayInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestReplayInfo(RequestReplayInfo&& from) noexcept
    : RequestReplayInfo() {
    *this = ::std::move(from);
  }

  inline RequestReplayInfo& operator=(RequestReplayInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestReplayInfo& default_instance();

  enum ReplayCase {
    kReplayPath = 1,
    kReplayData = 2,
    REPLAY_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestReplayInfo* internal_default_instance() {
    return reinterpret_cast<const RequestReplayInfo*>(
               &_RequestReplayInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  void Swap(RequestReplayInfo* other);
  friend void swap(RequestReplayInfo& a, RequestReplayInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestReplayInfo* New() const final {
    return CreateMaybeMessage<RequestReplayInfo>(NULL);
  }

  RequestReplayInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestReplayInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestReplayInfo& from);
  void MergeFrom(const RequestReplayInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestReplayInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool download_data = 3;
  bool has_download_data() const;
  void clear_download_data();
  static const int kDownloadDataFieldNumber = 3;
  bool download_data() const;
  void set_download_data(bool value);

  // optional string replay_path = 1;
  bool has_replay_path() const;
  void clear_replay_path();
  static const int kReplayPathFieldNumber = 1;
  const ::std::string& replay_path() const;
  void set_replay_path(const ::std::string& value);
  #if LANG_CXX11
  void set_replay_path(::std::string&& value);
  #endif
  void set_replay_path(const char* value);
  void set_replay_path(const char* value, size_t size);
  ::std::string* mutable_replay_path();
  ::std::string* release_replay_path();
  void set_allocated_replay_path(::std::string* replay_path);

  // optional bytes replay_data = 2;
  bool has_replay_data() const;
  void clear_replay_data();
  static const int kReplayDataFieldNumber = 2;
  const ::std::string& replay_data() const;
  void set_replay_data(const ::std::string& value);
  #if LANG_CXX11
  void set_replay_data(::std::string&& value);
  #endif
  void set_replay_data(const char* value);
  void set_replay_data(const void* value, size_t size);
  ::std::string* mutable_replay_data();
  ::std::string* release_replay_data();
  void set_allocated_replay_data(::std::string* replay_data);

  void clear_replay();
  ReplayCase replay_case() const;
  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestReplayInfo)
 private:
  void set_has_replay_path();
  void set_has_replay_data();
  void set_has_download_data();
  void clear_has_download_data();

  inline bool has_replay() const;
  inline void clear_has_replay();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool download_data_;
  union ReplayUnion {
    ReplayUnion() {}
    ::google::protobuf::internal::ArenaStringPtr replay_path_;
    ::google::protobuf::internal::ArenaStringPtr replay_data_;
  } replay_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PlayerInfoExtra : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.PlayerInfoExtra) */ {
 public:
  PlayerInfoExtra();
  virtual ~PlayerInfoExtra();

  PlayerInfoExtra(const PlayerInfoExtra& from);

  inline PlayerInfoExtra& operator=(const PlayerInfoExtra& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerInfoExtra(PlayerInfoExtra&& from) noexcept
    : PlayerInfoExtra() {
    *this = ::std::move(from);
  }

  inline PlayerInfoExtra& operator=(PlayerInfoExtra&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerInfoExtra& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerInfoExtra* internal_default_instance() {
    return reinterpret_cast<const PlayerInfoExtra*>(
               &_PlayerInfoExtra_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  void Swap(PlayerInfoExtra* other);
  friend void swap(PlayerInfoExtra& a, PlayerInfoExtra& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerInfoExtra* New() const final {
    return CreateMaybeMessage<PlayerInfoExtra>(NULL);
  }

  PlayerInfoExtra* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PlayerInfoExtra>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PlayerInfoExtra& from);
  void MergeFrom(const PlayerInfoExtra& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerInfoExtra* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SC2APIProtocol.PlayerInfo player_info = 1;
  bool has_player_info() const;
  void clear_player_info();
  static const int kPlayerInfoFieldNumber = 1;
  private:
  const ::SC2APIProtocol::PlayerInfo& _internal_player_info() const;
  public:
  const ::SC2APIProtocol::PlayerInfo& player_info() const;
  ::SC2APIProtocol::PlayerInfo* release_player_info();
  ::SC2APIProtocol::PlayerInfo* mutable_player_info();
  void set_allocated_player_info(::SC2APIProtocol::PlayerInfo* player_info);

  // optional .SC2APIProtocol.PlayerResult player_result = 2;
  bool has_player_result() const;
  void clear_player_result();
  static const int kPlayerResultFieldNumber = 2;
  private:
  const ::SC2APIProtocol::PlayerResult& _internal_player_result() const;
  public:
  const ::SC2APIProtocol::PlayerResult& player_result() const;
  ::SC2APIProtocol::PlayerResult* release_player_result();
  ::SC2APIProtocol::PlayerResult* mutable_player_result();
  void set_allocated_player_result(::SC2APIProtocol::PlayerResult* player_result);

  // optional int32 player_mmr = 3;
  bool has_player_mmr() const;
  void clear_player_mmr();
  static const int kPlayerMmrFieldNumber = 3;
  ::google::protobuf::int32 player_mmr() const;
  void set_player_mmr(::google::protobuf::int32 value);

  // optional int32 player_apm = 4;
  bool has_player_apm() const;
  void clear_player_apm();
  static const int kPlayerApmFieldNumber = 4;
  ::google::protobuf::int32 player_apm() const;
  void set_player_apm(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.PlayerInfoExtra)
 private:
  void set_has_player_info();
  void clear_has_player_info();
  void set_has_player_result();
  void clear_has_player_result();
  void set_has_player_mmr();
  void clear_has_player_mmr();
  void set_has_player_apm();
  void clear_has_player_apm();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::SC2APIProtocol::PlayerInfo* player_info_;
  ::SC2APIProtocol::PlayerResult* player_result_;
  ::google::protobuf::int32 player_mmr_;
  ::google::protobuf::int32 player_apm_;
  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseReplayInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseReplayInfo) */ {
 public:
  ResponseReplayInfo();
  virtual ~ResponseReplayInfo();

  ResponseReplayInfo(const ResponseReplayInfo& from);

  inline ResponseReplayInfo& operator=(const ResponseReplayInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseReplayInfo(ResponseReplayInfo&& from) noexcept
    : ResponseReplayInfo() {
    *this = ::std::move(from);
  }

  inline ResponseReplayInfo& operator=(ResponseReplayInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseReplayInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseReplayInfo* internal_default_instance() {
    return reinterpret_cast<const ResponseReplayInfo*>(
               &_ResponseReplayInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  void Swap(ResponseReplayInfo* other);
  friend void swap(ResponseReplayInfo& a, ResponseReplayInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseReplayInfo* New() const final {
    return CreateMaybeMessage<ResponseReplayInfo>(NULL);
  }

  ResponseReplayInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseReplayInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResponseReplayInfo& from);
  void MergeFrom(const ResponseReplayInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseReplayInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResponseReplayInfo_Error Error;
  static const Error MissingReplay =
    ResponseReplayInfo_Error_MissingReplay;
  static const Error InvalidReplayPath =
    ResponseReplayInfo_Error_InvalidReplayPath;
  static const Error InvalidReplayData =
    ResponseReplayInfo_Error_InvalidReplayData;
  static const Error ParsingError =
    ResponseReplayInfo_Error_ParsingError;
  static const Error DownloadError =
    ResponseReplayInfo_Error_DownloadError;
  static inline bool Error_IsValid(int value) {
    return ResponseReplayInfo_Error_IsValid(value);
  }
  static const Error Error_MIN =
    ResponseReplayInfo_Error_Error_MIN;
  static const Error Error_MAX =
    ResponseReplayInfo_Error_Error_MAX;
  static const int Error_ARRAYSIZE =
    ResponseReplayInfo_Error_Error_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Error_descriptor() {
    return ResponseReplayInfo_Error_descriptor();
  }
  static inline const ::std::string& Error_Name(Error value) {
    return ResponseReplayInfo_Error_Name(value);
  }
  static inline bool Error_Parse(const ::std::string& name,
      Error* value) {
    return ResponseReplayInfo_Error_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .SC2APIProtocol.PlayerInfoExtra player_info = 3;
  int player_info_size() const;
  void clear_player_info();
  static const int kPlayerInfoFieldNumber = 3;
  ::SC2APIProtocol::PlayerInfoExtra* mutable_player_info(int index);
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PlayerInfoExtra >*
      mutable_player_info();
  const ::SC2APIProtocol::PlayerInfoExtra& player_info(int index) const;
  ::SC2APIProtocol::PlayerInfoExtra* add_player_info();
  const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PlayerInfoExtra >&
      player_info() const;

  // optional string map_name = 1;
  bool has_map_name() const;
  void clear_map_name();
  static const int kMapNameFieldNumber = 1;
  const ::std::string& map_name() const;
  void set_map_name(const ::std::string& value);
  #if LANG_CXX11
  void set_map_name(::std::string&& value);
  #endif
  void set_map_name(const char* value);
  void set_map_name(const char* value, size_t size);
  ::std::string* mutable_map_name();
  ::std::string* release_map_name();
  void set_allocated_map_name(::std::string* map_name);

  // optional string local_map_path = 2;
  bool has_local_map_path() const;
  void clear_local_map_path();
  static const int kLocalMapPathFieldNumber = 2;
  const ::std::string& local_map_path() const;
  void set_local_map_path(const ::std::string& value);
  #if LANG_CXX11
  void set_local_map_path(::std::string&& value);
  #endif
  void set_local_map_path(const char* value);
  void set_local_map_path(const char* value, size_t size);
  ::std::string* mutable_local_map_path();
  ::std::string* release_local_map_path();
  void set_allocated_local_map_path(::std::string* local_map_path);

  // optional string game_version = 6;
  bool has_game_version() const;
  void clear_game_version();
  static const int kGameVersionFieldNumber = 6;
  const ::std::string& game_version() const;
  void set_game_version(const ::std::string& value);
  #if LANG_CXX11
  void set_game_version(::std::string&& value);
  #endif
  void set_game_version(const char* value);
  void set_game_version(const char* value, size_t size);
  ::std::string* mutable_game_version();
  ::std::string* release_game_version();
  void set_allocated_game_version(::std::string* game_version);

  // optional string error_details = 10;
  bool has_error_details() const;
  void clear_error_details();
  static const int kErrorDetailsFieldNumber = 10;
  const ::std::string& error_details() const;
  void set_error_details(const ::std::string& value);
  #if LANG_CXX11
  void set_error_details(::std::string&& value);
  #endif
  void set_error_details(const char* value);
  void set_error_details(const char* value, size_t size);
  ::std::string* mutable_error_details();
  ::std::string* release_error_details();
  void set_allocated_error_details(::std::string* error_details);

  // optional string data_version = 11;
  bool has_data_version() const;
  void clear_data_version();
  static const int kDataVersionFieldNumber = 11;
  const ::std::string& data_version() const;
  void set_data_version(const ::std::string& value);
  #if LANG_CXX11
  void set_data_version(::std::string&& value);
  #endif
  void set_data_version(const char* value);
  void set_data_version(const char* value, size_t size);
  ::std::string* mutable_data_version();
  ::std::string* release_data_version();
  void set_allocated_data_version(::std::string* data_version);

  // optional uint32 game_duration_loops = 4;
  bool has_game_duration_loops() const;
  void clear_game_duration_loops();
  static const int kGameDurationLoopsFieldNumber = 4;
  ::google::protobuf::uint32 game_duration_loops() const;
  void set_game_duration_loops(::google::protobuf::uint32 value);

  // optional float game_duration_seconds = 5;
  bool has_game_duration_seconds() const;
  void clear_game_duration_seconds();
  static const int kGameDurationSecondsFieldNumber = 5;
  float game_duration_seconds() const;
  void set_game_duration_seconds(float value);

  // optional uint32 data_build = 7;
  bool has_data_build() const;
  void clear_data_build();
  static const int kDataBuildFieldNumber = 7;
  ::google::protobuf::uint32 data_build() const;
  void set_data_build(::google::protobuf::uint32 value);

  // optional uint32 base_build = 8;
  bool has_base_build() const;
  void clear_base_build();
  static const int kBaseBuildFieldNumber = 8;
  ::google::protobuf::uint32 base_build() const;
  void set_base_build(::google::protobuf::uint32 value);

  // optional .SC2APIProtocol.ResponseReplayInfo.Error error = 9;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 9;
  ::SC2APIProtocol::ResponseReplayInfo_Error error() const;
  void set_error(::SC2APIProtocol::ResponseReplayInfo_Error value);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseReplayInfo)
 private:
  void set_has_map_name();
  void clear_has_map_name();
  void set_has_local_map_path();
  void clear_has_local_map_path();
  void set_has_game_duration_loops();
  void clear_has_game_duration_loops();
  void set_has_game_duration_seconds();
  void clear_has_game_duration_seconds();
  void set_has_game_version();
  void clear_has_game_version();
  void set_has_data_version();
  void clear_has_data_version();
  void set_has_data_build();
  void clear_has_data_build();
  void set_has_base_build();
  void clear_has_base_build();
  void set_has_error();
  void clear_has_error();
  void set_has_error_details();
  void clear_has_error_details();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PlayerInfoExtra > player_info_;
  ::google::protobuf::internal::ArenaStringPtr map_name_;
  ::google::protobuf::internal::ArenaStringPtr local_map_path_;
  ::google::protobuf::internal::ArenaStringPtr game_version_;
  ::google::protobuf::internal::ArenaStringPtr error_details_;
  ::google::protobuf::internal::ArenaStringPtr data_version_;
  ::google::protobuf::uint32 game_duration_loops_;
  float game_duration_seconds_;
  ::google::protobuf::uint32 data_build_;
  ::google::protobuf::uint32 base_build_;
  int error_;
  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestAvailableMaps : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestAvailableMaps) */ {
 public:
  RequestAvailableMaps();
  virtual ~RequestAvailableMaps();

  RequestAvailableMaps(const RequestAvailableMaps& from);

  inline RequestAvailableMaps& operator=(const RequestAvailableMaps& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestAvailableMaps(RequestAvailableMaps&& from) noexcept
    : RequestAvailableMaps() {
    *this = ::std::move(from);
  }

  inline RequestAvailableMaps& operator=(RequestAvailableMaps&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestAvailableMaps& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestAvailableMaps* internal_default_instance() {
    return reinterpret_cast<const RequestAvailableMaps*>(
               &_RequestAvailableMaps_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  void Swap(RequestAvailableMaps* other);
  friend void swap(RequestAvailableMaps& a, RequestAvailableMaps& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestAvailableMaps* New() const final {
    return CreateMaybeMessage<RequestAvailableMaps>(NULL);
  }

  RequestAvailableMaps* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestAvailableMaps>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestAvailableMaps& from);
  void MergeFrom(const RequestAvailableMaps& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestAvailableMaps* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestAvailableMaps)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseAvailableMaps : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseAvailableMaps) */ {
 public:
  ResponseAvailableMaps();
  virtual ~ResponseAvailableMaps();

  ResponseAvailableMaps(const ResponseAvailableMaps& from);

  inline ResponseAvailableMaps& operator=(const ResponseAvailableMaps& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseAvailableMaps(ResponseAvailableMaps&& from) noexcept
    : ResponseAvailableMaps() {
    *this = ::std::move(from);
  }

  inline ResponseAvailableMaps& operator=(ResponseAvailableMaps&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseAvailableMaps& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseAvailableMaps* internal_default_instance() {
    return reinterpret_cast<const ResponseAvailableMaps*>(
               &_ResponseAvailableMaps_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  void Swap(ResponseAvailableMaps* other);
  friend void swap(ResponseAvailableMaps& a, ResponseAvailableMaps& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseAvailableMaps* New() const final {
    return CreateMaybeMessage<ResponseAvailableMaps>(NULL);
  }

  ResponseAvailableMaps* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseAvailableMaps>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResponseAvailableMaps& from);
  void MergeFrom(const ResponseAvailableMaps& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseAvailableMaps* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string local_map_paths = 1;
  int local_map_paths_size() const;
  void clear_local_map_paths();
  static const int kLocalMapPathsFieldNumber = 1;
  const ::std::string& local_map_paths(int index) const;
  ::std::string* mutable_local_map_paths(int index);
  void set_local_map_paths(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_local_map_paths(int index, ::std::string&& value);
  #endif
  void set_local_map_paths(int index, const char* value);
  void set_local_map_paths(int index, const char* value, size_t size);
  ::std::string* add_local_map_paths();
  void add_local_map_paths(const ::std::string& value);
  #if LANG_CXX11
  void add_local_map_paths(::std::string&& value);
  #endif
  void add_local_map_paths(const char* value);
  void add_local_map_paths(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& local_map_paths() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_local_map_paths();

  // repeated string battlenet_map_names = 2;
  int battlenet_map_names_size() const;
  void clear_battlenet_map_names();
  static const int kBattlenetMapNamesFieldNumber = 2;
  const ::std::string& battlenet_map_names(int index) const;
  ::std::string* mutable_battlenet_map_names(int index);
  void set_battlenet_map_names(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_battlenet_map_names(int index, ::std::string&& value);
  #endif
  void set_battlenet_map_names(int index, const char* value);
  void set_battlenet_map_names(int index, const char* value, size_t size);
  ::std::string* add_battlenet_map_names();
  void add_battlenet_map_names(const ::std::string& value);
  #if LANG_CXX11
  void add_battlenet_map_names(::std::string&& value);
  #endif
  void add_battlenet_map_names(const char* value);
  void add_battlenet_map_names(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& battlenet_map_names() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_battlenet_map_names();

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseAvailableMaps)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> local_map_paths_;
  ::google::protobuf::RepeatedPtrField< ::std::string> battlenet_map_names_;
  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestSaveMap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestSaveMap) */ {
 public:
  RequestSaveMap();
  virtual ~RequestSaveMap();

  RequestSaveMap(const RequestSaveMap& from);

  inline RequestSaveMap& operator=(const RequestSaveMap& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestSaveMap(RequestSaveMap&& from) noexcept
    : RequestSaveMap() {
    *this = ::std::move(from);
  }

  inline RequestSaveMap& operator=(RequestSaveMap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestSaveMap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestSaveMap* internal_default_instance() {
    return reinterpret_cast<const RequestSaveMap*>(
               &_RequestSaveMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  void Swap(RequestSaveMap* other);
  friend void swap(RequestSaveMap& a, RequestSaveMap& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestSaveMap* New() const final {
    return CreateMaybeMessage<RequestSaveMap>(NULL);
  }

  RequestSaveMap* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestSaveMap>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestSaveMap& from);
  void MergeFrom(const RequestSaveMap& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestSaveMap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string map_path = 1;
  bool has_map_path() const;
  void clear_map_path();
  static const int kMapPathFieldNumber = 1;
  const ::std::string& map_path() const;
  void set_map_path(const ::std::string& value);
  #if LANG_CXX11
  void set_map_path(::std::string&& value);
  #endif
  void set_map_path(const char* value);
  void set_map_path(const char* value, size_t size);
  ::std::string* mutable_map_path();
  ::std::string* release_map_path();
  void set_allocated_map_path(::std::string* map_path);

  // optional bytes map_data = 2;
  bool has_map_data() const;
  void clear_map_data();
  static const int kMapDataFieldNumber = 2;
  const ::std::string& map_data() const;
  void set_map_data(const ::std::string& value);
  #if LANG_CXX11
  void set_map_data(::std::string&& value);
  #endif
  void set_map_data(const char* value);
  void set_map_data(const void* value, size_t size);
  ::std::string* mutable_map_data();
  ::std::string* release_map_data();
  void set_allocated_map_data(::std::string* map_data);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestSaveMap)
 private:
  void set_has_map_path();
  void clear_has_map_path();
  void set_has_map_data();
  void clear_has_map_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr map_path_;
  ::google::protobuf::internal::ArenaStringPtr map_data_;
  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseSaveMap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseSaveMap) */ {
 public:
  ResponseSaveMap();
  virtual ~ResponseSaveMap();

  ResponseSaveMap(const ResponseSaveMap& from);

  inline ResponseSaveMap& operator=(const ResponseSaveMap& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseSaveMap(ResponseSaveMap&& from) noexcept
    : ResponseSaveMap() {
    *this = ::std::move(from);
  }

  inline ResponseSaveMap& operator=(ResponseSaveMap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseSaveMap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseSaveMap* internal_default_instance() {
    return reinterpret_cast<const ResponseSaveMap*>(
               &_ResponseSaveMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  void Swap(ResponseSaveMap* other);
  friend void swap(ResponseSaveMap& a, ResponseSaveMap& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseSaveMap* New() const final {
    return CreateMaybeMessage<ResponseSaveMap>(NULL);
  }

  ResponseSaveMap* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseSaveMap>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResponseSaveMap& from);
  void MergeFrom(const ResponseSaveMap& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseSaveMap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResponseSaveMap_Error Error;
  static const Error InvalidMapData =
    ResponseSaveMap_Error_InvalidMapData;
  static inline bool Error_IsValid(int value) {
    return ResponseSaveMap_Error_IsValid(value);
  }
  static const Error Error_MIN =
    ResponseSaveMap_Error_Error_MIN;
  static const Error Error_MAX =
    ResponseSaveMap_Error_Error_MAX;
  static const int Error_ARRAYSIZE =
    ResponseSaveMap_Error_Error_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Error_descriptor() {
    return ResponseSaveMap_Error_descriptor();
  }
  static inline const ::std::string& Error_Name(Error value) {
    return ResponseSaveMap_Error_Name(value);
  }
  static inline bool Error_Parse(const ::std::string& name,
      Error* value) {
    return ResponseSaveMap_Error_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .SC2APIProtocol.ResponseSaveMap.Error error = 1;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  ::SC2APIProtocol::ResponseSaveMap_Error error() const;
  void set_error(::SC2APIProtocol::ResponseSaveMap_Error value);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseSaveMap)
 private:
  void set_has_error();
  void clear_has_error();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int error_;
  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestPing : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestPing) */ {
 public:
  RequestPing();
  virtual ~RequestPing();

  RequestPing(const RequestPing& from);

  inline RequestPing& operator=(const RequestPing& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestPing(RequestPing&& from) noexcept
    : RequestPing() {
    *this = ::std::move(from);
  }

  inline RequestPing& operator=(RequestPing&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestPing& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestPing* internal_default_instance() {
    return reinterpret_cast<const RequestPing*>(
               &_RequestPing_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  void Swap(RequestPing* other);
  friend void swap(RequestPing& a, RequestPing& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestPing* New() const final {
    return CreateMaybeMessage<RequestPing>(NULL);
  }

  RequestPing* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestPing>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestPing& from);
  void MergeFrom(const RequestPing& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestPing* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestPing)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponsePing : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponsePing) */ {
 public:
  ResponsePing();
  virtual ~ResponsePing();

  ResponsePing(const ResponsePing& from);

  inline ResponsePing& operator=(const ResponsePing& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponsePing(ResponsePing&& from) noexcept
    : ResponsePing() {
    *this = ::std::move(from);
  }

  inline ResponsePing& operator=(ResponsePing&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponsePing& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponsePing* internal_default_instance() {
    return reinterpret_cast<const ResponsePing*>(
               &_ResponsePing_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  void Swap(ResponsePing* other);
  friend void swap(ResponsePing& a, ResponsePing& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponsePing* New() const final {
    return CreateMaybeMessage<ResponsePing>(NULL);
  }

  ResponsePing* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponsePing>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResponsePing& from);
  void MergeFrom(const ResponsePing& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponsePing* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string game_version = 1;
  bool has_game_version() const;
  void clear_game_version();
  static const int kGameVersionFieldNumber = 1;
  const ::std::string& game_version() const;
  void set_game_version(const ::std::string& value);
  #if LANG_CXX11
  void set_game_version(::std::string&& value);
  #endif
  void set_game_version(const char* value);
  void set_game_version(const char* value, size_t size);
  ::std::string* mutable_game_version();
  ::std::string* release_game_version();
  void set_allocated_game_version(::std::string* game_version);

  // optional string data_version = 2;
  bool has_data_version() const;
  void clear_data_version();
  static const int kDataVersionFieldNumber = 2;
  const ::std::string& data_version() const;
  void set_data_version(const ::std::string& value);
  #if LANG_CXX11
  void set_data_version(::std::string&& value);
  #endif
  void set_data_version(const char* value);
  void set_data_version(const char* value, size_t size);
  ::std::string* mutable_data_version();
  ::std::string* release_data_version();
  void set_allocated_data_version(::std::string* data_version);

  // optional uint32 data_build = 3;
  bool has_data_build() const;
  void clear_data_build();
  static const int kDataBuildFieldNumber = 3;
  ::google::protobuf::uint32 data_build() const;
  void set_data_build(::google::protobuf::uint32 value);

  // optional uint32 base_build = 4;
  bool has_base_build() const;
  void clear_base_build();
  static const int kBaseBuildFieldNumber = 4;
  ::google::protobuf::uint32 base_build() const;
  void set_base_build(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponsePing)
 private:
  void set_has_game_version();
  void clear_has_game_version();
  void set_has_data_version();
  void clear_has_data_version();
  void set_has_data_build();
  void clear_has_data_build();
  void set_has_base_build();
  void clear_has_base_build();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr game_version_;
  ::google::protobuf::internal::ArenaStringPtr data_version_;
  ::google::protobuf::uint32 data_build_;
  ::google::protobuf::uint32 base_build_;
  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestDebug : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.RequestDebug) */ {
 public:
  RequestDebug();
  virtual ~RequestDebug();

  RequestDebug(const RequestDebug& from);

  inline RequestDebug& operator=(const RequestDebug& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestDebug(RequestDebug&& from) noexcept
    : RequestDebug() {
    *this = ::std::move(from);
  }

  inline RequestDebug& operator=(RequestDebug&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestDebug& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestDebug* internal_default_instance() {
    return reinterpret_cast<const RequestDebug*>(
               &_RequestDebug_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  void Swap(RequestDebug* other);
  friend void swap(RequestDebug& a, RequestDebug& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestDebug* New() const final {
    return CreateMaybeMessage<RequestDebug>(NULL);
  }

  RequestDebug* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestDebug>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestDebug& from);
  void MergeFrom(const RequestDebug& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestDebug* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SC2APIProtocol.DebugCommand debug = 1;
  int debug_size() const;
  void clear_debug();
  static const int kDebugFieldNumber = 1;
  ::SC2APIProtocol::DebugCommand* mutable_debug(int index);
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::DebugCommand >*
      mutable_debug();
  const ::SC2APIProtocol::DebugCommand& debug(int index) const;
  ::SC2APIProtocol::DebugCommand* add_debug();
  const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::DebugCommand >&
      debug() const;

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.RequestDebug)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::DebugCommand > debug_;
  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseDebug : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ResponseDebug) */ {
 public:
  ResponseDebug();
  virtual ~ResponseDebug();

  ResponseDebug(const ResponseDebug& from);

  inline ResponseDebug& operator=(const ResponseDebug& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseDebug(ResponseDebug&& from) noexcept
    : ResponseDebug() {
    *this = ::std::move(from);
  }

  inline ResponseDebug& operator=(ResponseDebug&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseDebug& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseDebug* internal_default_instance() {
    return reinterpret_cast<const ResponseDebug*>(
               &_ResponseDebug_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  void Swap(ResponseDebug* other);
  friend void swap(ResponseDebug& a, ResponseDebug& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseDebug* New() const final {
    return CreateMaybeMessage<ResponseDebug>(NULL);
  }

  ResponseDebug* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseDebug>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResponseDebug& from);
  void MergeFrom(const ResponseDebug& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseDebug* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ResponseDebug)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PlayerSetup : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.PlayerSetup) */ {
 public:
  PlayerSetup();
  virtual ~PlayerSetup();

  PlayerSetup(const PlayerSetup& from);

  inline PlayerSetup& operator=(const PlayerSetup& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerSetup(PlayerSetup&& from) noexcept
    : PlayerSetup() {
    *this = ::std::move(from);
  }

  inline PlayerSetup& operator=(PlayerSetup&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerSetup& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerSetup* internal_default_instance() {
    return reinterpret_cast<const PlayerSetup*>(
               &_PlayerSetup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  void Swap(PlayerSetup* other);
  friend void swap(PlayerSetup& a, PlayerSetup& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerSetup* New() const final {
    return CreateMaybeMessage<PlayerSetup>(NULL);
  }

  PlayerSetup* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PlayerSetup>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PlayerSetup& from);
  void MergeFrom(const PlayerSetup& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerSetup* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SC2APIProtocol.Race race = 2;
  bool has_race() const;
  void clear_race();
  static const int kRaceFieldNumber = 2;
  ::SC2APIProtocol::Race race() const;
  void set_race(::SC2APIProtocol::Race value);

  // optional .SC2APIProtocol.PlayerType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::SC2APIProtocol::PlayerType type() const;
  void set_type(::SC2APIProtocol::PlayerType value);

  // optional .SC2APIProtocol.Difficulty difficulty = 3;
  bool has_difficulty() const;
  void clear_difficulty();
  static const int kDifficultyFieldNumber = 3;
  ::SC2APIProtocol::Difficulty difficulty() const;
  void set_difficulty(::SC2APIProtocol::Difficulty value);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.PlayerSetup)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_race();
  void clear_has_race();
  void set_has_difficulty();
  void clear_has_difficulty();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int race_;
  int type_;
  int difficulty_;
  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SpatialCameraSetup : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.SpatialCameraSetup) */ {
 public:
  SpatialCameraSetup();
  virtual ~SpatialCameraSetup();

  SpatialCameraSetup(const SpatialCameraSetup& from);

  inline SpatialCameraSetup& operator=(const SpatialCameraSetup& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SpatialCameraSetup(SpatialCameraSetup&& from) noexcept
    : SpatialCameraSetup() {
    *this = ::std::move(from);
  }

  inline SpatialCameraSetup& operator=(SpatialCameraSetup&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SpatialCameraSetup& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpatialCameraSetup* internal_default_instance() {
    return reinterpret_cast<const SpatialCameraSetup*>(
               &_SpatialCameraSetup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  void Swap(SpatialCameraSetup* other);
  friend void swap(SpatialCameraSetup& a, SpatialCameraSetup& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SpatialCameraSetup* New() const final {
    return CreateMaybeMessage<SpatialCameraSetup>(NULL);
  }

  SpatialCameraSetup* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SpatialCameraSetup>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SpatialCameraSetup& from);
  void MergeFrom(const SpatialCameraSetup& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpatialCameraSetup* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SC2APIProtocol.Size2DI resolution = 2;
  bool has_resolution() const;
  void clear_resolution();
  static const int kResolutionFieldNumber = 2;
  private:
  const ::SC2APIProtocol::Size2DI& _internal_resolution() const;
  public:
  const ::SC2APIProtocol::Size2DI& resolution() const;
  ::SC2APIProtocol::Size2DI* release_resolution();
  ::SC2APIProtocol::Size2DI* mutable_resolution();
  void set_allocated_resolution(::SC2APIProtocol::Size2DI* resolution);

  // optional .SC2APIProtocol.Size2DI minimap_resolution = 3;
  bool has_minimap_resolution() const;
  void clear_minimap_resolution();
  static const int kMinimapResolutionFieldNumber = 3;
  private:
  const ::SC2APIProtocol::Size2DI& _internal_minimap_resolution() const;
  public:
  const ::SC2APIProtocol::Size2DI& minimap_resolution() const;
  ::SC2APIProtocol::Size2DI* release_minimap_resolution();
  ::SC2APIProtocol::Size2DI* mutable_minimap_resolution();
  void set_allocated_minimap_resolution(::SC2APIProtocol::Size2DI* minimap_resolution);

  // optional float width = 1;
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 1;
  float width() const;
  void set_width(float value);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.SpatialCameraSetup)
 private:
  void set_has_width();
  void clear_has_width();
  void set_has_resolution();
  void clear_has_resolution();
  void set_has_minimap_resolution();
  void clear_has_minimap_resolution();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::SC2APIProtocol::Size2DI* resolution_;
  ::SC2APIProtocol::Size2DI* minimap_resolution_;
  float width_;
  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InterfaceOptions : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.InterfaceOptions) */ {
 public:
  InterfaceOptions();
  virtual ~InterfaceOptions();

  InterfaceOptions(const InterfaceOptions& from);

  inline InterfaceOptions& operator=(const InterfaceOptions& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InterfaceOptions(InterfaceOptions&& from) noexcept
    : InterfaceOptions() {
    *this = ::std::move(from);
  }

  inline InterfaceOptions& operator=(InterfaceOptions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InterfaceOptions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InterfaceOptions* internal_default_instance() {
    return reinterpret_cast<const InterfaceOptions*>(
               &_InterfaceOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  void Swap(InterfaceOptions* other);
  friend void swap(InterfaceOptions& a, InterfaceOptions& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InterfaceOptions* New() const final {
    return CreateMaybeMessage<InterfaceOptions>(NULL);
  }

  InterfaceOptions* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InterfaceOptions>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const InterfaceOptions& from);
  void MergeFrom(const InterfaceOptions& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InterfaceOptions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SC2APIProtocol.SpatialCameraSetup feature_layer = 3;
  bool has_feature_layer() const;
  void clear_feature_layer();
  static const int kFeatureLayerFieldNumber = 3;
  private:
  const ::SC2APIProtocol::SpatialCameraSetup& _internal_feature_layer() const;
  public:
  const ::SC2APIProtocol::SpatialCameraSetup& feature_layer() const;
  ::SC2APIProtocol::SpatialCameraSetup* release_feature_layer();
  ::SC2APIProtocol::SpatialCameraSetup* mutable_feature_layer();
  void set_allocated_feature_layer(::SC2APIProtocol::SpatialCameraSetup* feature_layer);

  // optional .SC2APIProtocol.SpatialCameraSetup render = 4;
  bool has_render() const;
  void clear_render();
  static const int kRenderFieldNumber = 4;
  private:
  const ::SC2APIProtocol::SpatialCameraSetup& _internal_render() const;
  public:
  const ::SC2APIProtocol::SpatialCameraSetup& render() const;
  ::SC2APIProtocol::SpatialCameraSetup* release_render();
  ::SC2APIProtocol::SpatialCameraSetup* mutable_render();
  void set_allocated_render(::SC2APIProtocol::SpatialCameraSetup* render);

  // optional bool raw = 1;
  bool has_raw() const;
  void clear_raw();
  static const int kRawFieldNumber = 1;
  bool raw() const;
  void set_raw(bool value);

  // optional bool score = 2;
  bool has_score() const;
  void clear_score();
  static const int kScoreFieldNumber = 2;
  bool score() const;
  void set_score(bool value);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.InterfaceOptions)
 private:
  void set_has_raw();
  void clear_has_raw();
  void set_has_score();
  void clear_has_score();
  void set_has_feature_layer();
  void clear_has_feature_layer();
  void set_has_render();
  void clear_has_render();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::SC2APIProtocol::SpatialCameraSetup* feature_layer_;
  ::SC2APIProtocol::SpatialCameraSetup* render_;
  bool raw_;
  bool score_;
  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PlayerInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.PlayerInfo) */ {
 public:
  PlayerInfo();
  virtual ~PlayerInfo();

  PlayerInfo(const PlayerInfo& from);

  inline PlayerInfo& operator=(const PlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerInfo(PlayerInfo&& from) noexcept
    : PlayerInfo() {
    *this = ::std::move(from);
  }

  inline PlayerInfo& operator=(PlayerInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerInfo* internal_default_instance() {
    return reinterpret_cast<const PlayerInfo*>(
               &_PlayerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  void Swap(PlayerInfo* other);
  friend void swap(PlayerInfo& a, PlayerInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerInfo* New() const final {
    return CreateMaybeMessage<PlayerInfo>(NULL);
  }

  PlayerInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PlayerInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PlayerInfo& from);
  void MergeFrom(const PlayerInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 player_id = 1;
  bool has_player_id() const;
  void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  ::google::protobuf::uint32 player_id() const;
  void set_player_id(::google::protobuf::uint32 value);

  // optional .SC2APIProtocol.Race race_requested = 3;
  bool has_race_requested() const;
  void clear_race_requested();
  static const int kRaceRequestedFieldNumber = 3;
  ::SC2APIProtocol::Race race_requested() const;
  void set_race_requested(::SC2APIProtocol::Race value);

  // optional .SC2APIProtocol.Race race_actual = 4;
  bool has_race_actual() const;
  void clear_race_actual();
  static const int kRaceActualFieldNumber = 4;
  ::SC2APIProtocol::Race race_actual() const;
  void set_race_actual(::SC2APIProtocol::Race value);

  // optional .SC2APIProtocol.PlayerType type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::SC2APIProtocol::PlayerType type() const;
  void set_type(::SC2APIProtocol::PlayerType value);

  // optional .SC2APIProtocol.Difficulty difficulty = 5;
  bool has_difficulty() const;
  void clear_difficulty();
  static const int kDifficultyFieldNumber = 5;
  ::SC2APIProtocol::Difficulty difficulty() const;
  void set_difficulty(::SC2APIProtocol::Difficulty value);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.PlayerInfo)
 private:
  void set_has_player_id();
  void clear_has_player_id();
  void set_has_type();
  void clear_has_type();
  void set_has_race_requested();
  void clear_has_race_requested();
  void set_has_race_actual();
  void clear_has_race_actual();
  void set_has_difficulty();
  void clear_has_difficulty();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 player_id_;
  int race_requested_;
  int race_actual_;
  int type_;
  int difficulty_;
  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PlayerCommon : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.PlayerCommon) */ {
 public:
  PlayerCommon();
  virtual ~PlayerCommon();

  PlayerCommon(const PlayerCommon& from);

  inline PlayerCommon& operator=(const PlayerCommon& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerCommon(PlayerCommon&& from) noexcept
    : PlayerCommon() {
    *this = ::std::move(from);
  }

  inline PlayerCommon& operator=(PlayerCommon&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerCommon& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerCommon* internal_default_instance() {
    return reinterpret_cast<const PlayerCommon*>(
               &_PlayerCommon_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  void Swap(PlayerCommon* other);
  friend void swap(PlayerCommon& a, PlayerCommon& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerCommon* New() const final {
    return CreateMaybeMessage<PlayerCommon>(NULL);
  }

  PlayerCommon* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PlayerCommon>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PlayerCommon& from);
  void MergeFrom(const PlayerCommon& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerCommon* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 player_id = 1;
  bool has_player_id() const;
  void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  ::google::protobuf::uint32 player_id() const;
  void set_player_id(::google::protobuf::uint32 value);

  // optional uint32 minerals = 2;
  bool has_minerals() const;
  void clear_minerals();
  static const int kMineralsFieldNumber = 2;
  ::google::protobuf::uint32 minerals() const;
  void set_minerals(::google::protobuf::uint32 value);

  // optional uint32 vespene = 3;
  bool has_vespene() const;
  void clear_vespene();
  static const int kVespeneFieldNumber = 3;
  ::google::protobuf::uint32 vespene() const;
  void set_vespene(::google::protobuf::uint32 value);

  // optional uint32 food_cap = 4;
  bool has_food_cap() const;
  void clear_food_cap();
  static const int kFoodCapFieldNumber = 4;
  ::google::protobuf::uint32 food_cap() const;
  void set_food_cap(::google::protobuf::uint32 value);

  // optional uint32 food_used = 5;
  bool has_food_used() const;
  void clear_food_used();
  static const int kFoodUsedFieldNumber = 5;
  ::google::protobuf::uint32 food_used() const;
  void set_food_used(::google::protobuf::uint32 value);

  // optional uint32 food_army = 6;
  bool has_food_army() const;
  void clear_food_army();
  static const int kFoodArmyFieldNumber = 6;
  ::google::protobuf::uint32 food_army() const;
  void set_food_army(::google::protobuf::uint32 value);

  // optional uint32 food_workers = 7;
  bool has_food_workers() const;
  void clear_food_workers();
  static const int kFoodWorkersFieldNumber = 7;
  ::google::protobuf::uint32 food_workers() const;
  void set_food_workers(::google::protobuf::uint32 value);

  // optional uint32 idle_worker_count = 8;
  bool has_idle_worker_count() const;
  void clear_idle_worker_count();
  static const int kIdleWorkerCountFieldNumber = 8;
  ::google::protobuf::uint32 idle_worker_count() const;
  void set_idle_worker_count(::google::protobuf::uint32 value);

  // optional uint32 army_count = 9;
  bool has_army_count() const;
  void clear_army_count();
  static const int kArmyCountFieldNumber = 9;
  ::google::protobuf::uint32 army_count() const;
  void set_army_count(::google::protobuf::uint32 value);

  // optional uint32 warp_gate_count = 10;
  bool has_warp_gate_count() const;
  void clear_warp_gate_count();
  static const int kWarpGateCountFieldNumber = 10;
  ::google::protobuf::uint32 warp_gate_count() const;
  void set_warp_gate_count(::google::protobuf::uint32 value);

  // optional uint32 larva_count = 11;
  bool has_larva_count() const;
  void clear_larva_count();
  static const int kLarvaCountFieldNumber = 11;
  ::google::protobuf::uint32 larva_count() const;
  void set_larva_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.PlayerCommon)
 private:
  void set_has_player_id();
  void clear_has_player_id();
  void set_has_minerals();
  void clear_has_minerals();
  void set_has_vespene();
  void clear_has_vespene();
  void set_has_food_cap();
  void clear_has_food_cap();
  void set_has_food_used();
  void clear_has_food_used();
  void set_has_food_army();
  void clear_has_food_army();
  void set_has_food_workers();
  void clear_has_food_workers();
  void set_has_idle_worker_count();
  void clear_has_idle_worker_count();
  void set_has_army_count();
  void clear_has_army_count();
  void set_has_warp_gate_count();
  void clear_has_warp_gate_count();
  void set_has_larva_count();
  void clear_has_larva_count();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 player_id_;
  ::google::protobuf::uint32 minerals_;
  ::google::protobuf::uint32 vespene_;
  ::google::protobuf::uint32 food_cap_;
  ::google::protobuf::uint32 food_used_;
  ::google::protobuf::uint32 food_army_;
  ::google::protobuf::uint32 food_workers_;
  ::google::protobuf::uint32 idle_worker_count_;
  ::google::protobuf::uint32 army_count_;
  ::google::protobuf::uint32 warp_gate_count_;
  ::google::protobuf::uint32 larva_count_;
  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Observation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.Observation) */ {
 public:
  Observation();
  virtual ~Observation();

  Observation(const Observation& from);

  inline Observation& operator=(const Observation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Observation(Observation&& from) noexcept
    : Observation() {
    *this = ::std::move(from);
  }

  inline Observation& operator=(Observation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Observation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Observation* internal_default_instance() {
    return reinterpret_cast<const Observation*>(
               &_Observation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  void Swap(Observation* other);
  friend void swap(Observation& a, Observation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Observation* New() const final {
    return CreateMaybeMessage<Observation>(NULL);
  }

  Observation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Observation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Observation& from);
  void MergeFrom(const Observation& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Observation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .SC2APIProtocol.AvailableAbility abilities = 3;
  int abilities_size() const;
  void clear_abilities();
  static const int kAbilitiesFieldNumber = 3;
  ::SC2APIProtocol::AvailableAbility* mutable_abilities(int index);
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::AvailableAbility >*
      mutable_abilities();
  const ::SC2APIProtocol::AvailableAbility& abilities(int index) const;
  ::SC2APIProtocol::AvailableAbility* add_abilities();
  const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::AvailableAbility >&
      abilities() const;

  // repeated .SC2APIProtocol.Alert alerts = 10;
  int alerts_size() const;
  void clear_alerts();
  static const int kAlertsFieldNumber = 10;
  ::SC2APIProtocol::Alert alerts(int index) const;
  void set_alerts(int index, ::SC2APIProtocol::Alert value);
  void add_alerts(::SC2APIProtocol::Alert value);
  const ::google::protobuf::RepeatedField<int>& alerts() const;
  ::google::protobuf::RepeatedField<int>* mutable_alerts();

  // optional .SC2APIProtocol.PlayerCommon player_common = 1;
  bool has_player_common() const;
  void clear_player_common();
  static const int kPlayerCommonFieldNumber = 1;
  private:
  const ::SC2APIProtocol::PlayerCommon& _internal_player_common() const;
  public:
  const ::SC2APIProtocol::PlayerCommon& player_common() const;
  ::SC2APIProtocol::PlayerCommon* release_player_common();
  ::SC2APIProtocol::PlayerCommon* mutable_player_common();
  void set_allocated_player_common(::SC2APIProtocol::PlayerCommon* player_common);

  // optional .SC2APIProtocol.Score score = 4;
  bool has_score() const;
  void clear_score();
  static const int kScoreFieldNumber = 4;
  private:
  const ::SC2APIProtocol::Score& _internal_score() const;
  public:
  const ::SC2APIProtocol::Score& score() const;
  ::SC2APIProtocol::Score* release_score();
  ::SC2APIProtocol::Score* mutable_score();
  void set_allocated_score(::SC2APIProtocol::Score* score);

  // optional .SC2APIProtocol.ObservationRaw raw_data = 5;
  bool has_raw_data() const;
  void clear_raw_data();
  static const int kRawDataFieldNumber = 5;
  private:
  const ::SC2APIProtocol::ObservationRaw& _internal_raw_data() const;
  public:
  const ::SC2APIProtocol::ObservationRaw& raw_data() const;
  ::SC2APIProtocol::ObservationRaw* release_raw_data();
  ::SC2APIProtocol::ObservationRaw* mutable_raw_data();
  void set_allocated_raw_data(::SC2APIProtocol::ObservationRaw* raw_data);

  // optional .SC2APIProtocol.ObservationFeatureLayer feature_layer_data = 6;
  bool has_feature_layer_data() const;
  void clear_feature_layer_data();
  static const int kFeatureLayerDataFieldNumber = 6;
  private:
  const ::SC2APIProtocol::ObservationFeatureLayer& _internal_feature_layer_data() const;
  public:
  const ::SC2APIProtocol::ObservationFeatureLayer& feature_layer_data() const;
  ::SC2APIProtocol::ObservationFeatureLayer* release_feature_layer_data();
  ::SC2APIProtocol::ObservationFeatureLayer* mutable_feature_layer_data();
  void set_allocated_feature_layer_data(::SC2APIProtocol::ObservationFeatureLayer* feature_layer_data);

  // optional .SC2APIProtocol.ObservationRender render_data = 7;
  bool has_render_data() const;
  void clear_render_data();
  static const int kRenderDataFieldNumber = 7;
  private:
  const ::SC2APIProtocol::ObservationRender& _internal_render_data() const;
  public:
  const ::SC2APIProtocol::ObservationRender& render_data() const;
  ::SC2APIProtocol::ObservationRender* release_render_data();
  ::SC2APIProtocol::ObservationRender* mutable_render_data();
  void set_allocated_render_data(::SC2APIProtocol::ObservationRender* render_data);

  // optional .SC2APIProtocol.ObservationUI ui_data = 8;
  bool has_ui_data() const;
  void clear_ui_data();
  static const int kUiDataFieldNumber = 8;
  private:
  const ::SC2APIProtocol::ObservationUI& _internal_ui_data() const;
  public:
  const ::SC2APIProtocol::ObservationUI& ui_data() const;
  ::SC2APIProtocol::ObservationUI* release_ui_data();
  ::SC2APIProtocol::ObservationUI* mutable_ui_data();
  void set_allocated_ui_data(::SC2APIProtocol::ObservationUI* ui_data);

  // optional uint32 game_loop = 9;
  bool has_game_loop() const;
  void clear_game_loop();
  static const int kGameLoopFieldNumber = 9;
  ::google::protobuf::uint32 game_loop() const;
  void set_game_loop(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.Observation)
 private:
  void set_has_game_loop();
  void clear_has_game_loop();
  void set_has_player_common();
  void clear_has_player_common();
  void set_has_score();
  void clear_has_score();
  void set_has_raw_data();
  void clear_has_raw_data();
  void set_has_feature_layer_data();
  void clear_has_feature_layer_data();
  void set_has_render_data();
  void clear_has_render_data();
  void set_has_ui_data();
  void clear_has_ui_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::AvailableAbility > abilities_;
  ::google::protobuf::RepeatedField<int> alerts_;
  ::SC2APIProtocol::PlayerCommon* player_common_;
  ::SC2APIProtocol::Score* score_;
  ::SC2APIProtocol::ObservationRaw* raw_data_;
  ::SC2APIProtocol::ObservationFeatureLayer* feature_layer_data_;
  ::SC2APIProtocol::ObservationRender* render_data_;
  ::SC2APIProtocol::ObservationUI* ui_data_;
  ::google::protobuf::uint32 game_loop_;
  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Action : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.Action) */ {
 public:
  Action();
  virtual ~Action();

  Action(const Action& from);

  inline Action& operator=(const Action& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Action(Action&& from) noexcept
    : Action() {
    *this = ::std::move(from);
  }

  inline Action& operator=(Action&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Action& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Action* internal_default_instance() {
    return reinterpret_cast<const Action*>(
               &_Action_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  void Swap(Action* other);
  friend void swap(Action& a, Action& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Action* New() const final {
    return CreateMaybeMessage<Action>(NULL);
  }

  Action* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Action>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Action& from);
  void MergeFrom(const Action& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Action* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SC2APIProtocol.ActionRaw action_raw = 1;
  bool has_action_raw() const;
  void clear_action_raw();
  static const int kActionRawFieldNumber = 1;
  private:
  const ::SC2APIProtocol::ActionRaw& _internal_action_raw() const;
  public:
  const ::SC2APIProtocol::ActionRaw& action_raw() const;
  ::SC2APIProtocol::ActionRaw* release_action_raw();
  ::SC2APIProtocol::ActionRaw* mutable_action_raw();
  void set_allocated_action_raw(::SC2APIProtocol::ActionRaw* action_raw);

  // optional .SC2APIProtocol.ActionSpatial action_feature_layer = 2;
  bool has_action_feature_layer() const;
  void clear_action_feature_layer();
  static const int kActionFeatureLayerFieldNumber = 2;
  private:
  const ::SC2APIProtocol::ActionSpatial& _internal_action_feature_layer() const;
  public:
  const ::SC2APIProtocol::ActionSpatial& action_feature_layer() const;
  ::SC2APIProtocol::ActionSpatial* release_action_feature_layer();
  ::SC2APIProtocol::ActionSpatial* mutable_action_feature_layer();
  void set_allocated_action_feature_layer(::SC2APIProtocol::ActionSpatial* action_feature_layer);

  // optional .SC2APIProtocol.ActionSpatial action_render = 3;
  bool has_action_render() const;
  void clear_action_render();
  static const int kActionRenderFieldNumber = 3;
  private:
  const ::SC2APIProtocol::ActionSpatial& _internal_action_render() const;
  public:
  const ::SC2APIProtocol::ActionSpatial& action_render() const;
  ::SC2APIProtocol::ActionSpatial* release_action_render();
  ::SC2APIProtocol::ActionSpatial* mutable_action_render();
  void set_allocated_action_render(::SC2APIProtocol::ActionSpatial* action_render);

  // optional .SC2APIProtocol.ActionUI action_ui = 4;
  bool has_action_ui() const;
  void clear_action_ui();
  static const int kActionUiFieldNumber = 4;
  private:
  const ::SC2APIProtocol::ActionUI& _internal_action_ui() const;
  public:
  const ::SC2APIProtocol::ActionUI& action_ui() const;
  ::SC2APIProtocol::ActionUI* release_action_ui();
  ::SC2APIProtocol::ActionUI* mutable_action_ui();
  void set_allocated_action_ui(::SC2APIProtocol::ActionUI* action_ui);

  // optional .SC2APIProtocol.ActionChat action_chat = 6;
  bool has_action_chat() const;
  void clear_action_chat();
  static const int kActionChatFieldNumber = 6;
  private:
  const ::SC2APIProtocol::ActionChat& _internal_action_chat() const;
  public:
  const ::SC2APIProtocol::ActionChat& action_chat() const;
  ::SC2APIProtocol::ActionChat* release_action_chat();
  ::SC2APIProtocol::ActionChat* mutable_action_chat();
  void set_allocated_action_chat(::SC2APIProtocol::ActionChat* action_chat);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.Action)
 private:
  void set_has_action_raw();
  void clear_has_action_raw();
  void set_has_action_feature_layer();
  void clear_has_action_feature_layer();
  void set_has_action_render();
  void clear_has_action_render();
  void set_has_action_ui();
  void clear_has_action_ui();
  void set_has_action_chat();
  void clear_has_action_chat();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::SC2APIProtocol::ActionRaw* action_raw_;
  ::SC2APIProtocol::ActionSpatial* action_feature_layer_;
  ::SC2APIProtocol::ActionSpatial* action_render_;
  ::SC2APIProtocol::ActionUI* action_ui_;
  ::SC2APIProtocol::ActionChat* action_chat_;
  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActionChat : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ActionChat) */ {
 public:
  ActionChat();
  virtual ~ActionChat();

  ActionChat(const ActionChat& from);

  inline ActionChat& operator=(const ActionChat& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ActionChat(ActionChat&& from) noexcept
    : ActionChat() {
    *this = ::std::move(from);
  }

  inline ActionChat& operator=(ActionChat&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionChat& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionChat* internal_default_instance() {
    return reinterpret_cast<const ActionChat*>(
               &_ActionChat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  void Swap(ActionChat* other);
  friend void swap(ActionChat& a, ActionChat& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ActionChat* New() const final {
    return CreateMaybeMessage<ActionChat>(NULL);
  }

  ActionChat* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ActionChat>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ActionChat& from);
  void MergeFrom(const ActionChat& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionChat* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ActionChat_Channel Channel;
  static const Channel Broadcast =
    ActionChat_Channel_Broadcast;
  static const Channel Team =
    ActionChat_Channel_Team;
  static inline bool Channel_IsValid(int value) {
    return ActionChat_Channel_IsValid(value);
  }
  static const Channel Channel_MIN =
    ActionChat_Channel_Channel_MIN;
  static const Channel Channel_MAX =
    ActionChat_Channel_Channel_MAX;
  static const int Channel_ARRAYSIZE =
    ActionChat_Channel_Channel_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Channel_descriptor() {
    return ActionChat_Channel_descriptor();
  }
  static inline const ::std::string& Channel_Name(Channel value) {
    return ActionChat_Channel_Name(value);
  }
  static inline bool Channel_Parse(const ::std::string& name,
      Channel* value) {
    return ActionChat_Channel_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string message = 2;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // optional .SC2APIProtocol.ActionChat.Channel channel = 1;
  bool has_channel() const;
  void clear_channel();
  static const int kChannelFieldNumber = 1;
  ::SC2APIProtocol::ActionChat_Channel channel() const;
  void set_channel(::SC2APIProtocol::ActionChat_Channel value);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ActionChat)
 private:
  void set_has_channel();
  void clear_has_channel();
  void set_has_message();
  void clear_has_message();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  int channel_;
  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActionError : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ActionError) */ {
 public:
  ActionError();
  virtual ~ActionError();

  ActionError(const ActionError& from);

  inline ActionError& operator=(const ActionError& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ActionError(ActionError&& from) noexcept
    : ActionError() {
    *this = ::std::move(from);
  }

  inline ActionError& operator=(ActionError&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionError& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionError* internal_default_instance() {
    return reinterpret_cast<const ActionError*>(
               &_ActionError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  void Swap(ActionError* other);
  friend void swap(ActionError& a, ActionError& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ActionError* New() const final {
    return CreateMaybeMessage<ActionError>(NULL);
  }

  ActionError* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ActionError>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ActionError& from);
  void MergeFrom(const ActionError& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionError* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 unit_tag = 1;
  bool has_unit_tag() const;
  void clear_unit_tag();
  static const int kUnitTagFieldNumber = 1;
  ::google::protobuf::uint64 unit_tag() const;
  void set_unit_tag(::google::protobuf::uint64 value);

  // optional uint64 ability_id = 2;
  bool has_ability_id() const;
  void clear_ability_id();
  static const int kAbilityIdFieldNumber = 2;
  ::google::protobuf::uint64 ability_id() const;
  void set_ability_id(::google::protobuf::uint64 value);

  // optional .SC2APIProtocol.ActionResult result = 3;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 3;
  ::SC2APIProtocol::ActionResult result() const;
  void set_result(::SC2APIProtocol::ActionResult value);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ActionError)
 private:
  void set_has_unit_tag();
  void clear_has_unit_tag();
  void set_has_ability_id();
  void clear_has_ability_id();
  void set_has_result();
  void clear_has_result();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 unit_tag_;
  ::google::protobuf::uint64 ability_id_;
  int result_;
  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ObserverAction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ObserverAction) */ {
 public:
  ObserverAction();
  virtual ~ObserverAction();

  ObserverAction(const ObserverAction& from);

  inline ObserverAction& operator=(const ObserverAction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ObserverAction(ObserverAction&& from) noexcept
    : ObserverAction() {
    *this = ::std::move(from);
  }

  inline ObserverAction& operator=(ObserverAction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ObserverAction& default_instance();

  enum ActionCase {
    kPlayerPerspective = 1,
    kCameraMove = 2,
    kCameraFollowPlayer = 3,
    kCameraFollowUnits = 4,
    ACTION_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObserverAction* internal_default_instance() {
    return reinterpret_cast<const ObserverAction*>(
               &_ObserverAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  void Swap(ObserverAction* other);
  friend void swap(ObserverAction& a, ObserverAction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ObserverAction* New() const final {
    return CreateMaybeMessage<ObserverAction>(NULL);
  }

  ObserverAction* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ObserverAction>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ObserverAction& from);
  void MergeFrom(const ObserverAction& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObserverAction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SC2APIProtocol.ActionObserverPlayerPerspective player_perspective = 1;
  bool has_player_perspective() const;
  void clear_player_perspective();
  static const int kPlayerPerspectiveFieldNumber = 1;
  private:
  const ::SC2APIProtocol::ActionObserverPlayerPerspective& _internal_player_perspective() const;
  public:
  const ::SC2APIProtocol::ActionObserverPlayerPerspective& player_perspective() const;
  ::SC2APIProtocol::ActionObserverPlayerPerspective* release_player_perspective();
  ::SC2APIProtocol::ActionObserverPlayerPerspective* mutable_player_perspective();
  void set_allocated_player_perspective(::SC2APIProtocol::ActionObserverPlayerPerspective* player_perspective);

  // optional .SC2APIProtocol.ActionObserverCameraMove camera_move = 2;
  bool has_camera_move() const;
  void clear_camera_move();
  static const int kCameraMoveFieldNumber = 2;
  private:
  const ::SC2APIProtocol::ActionObserverCameraMove& _internal_camera_move() const;
  public:
  const ::SC2APIProtocol::ActionObserverCameraMove& camera_move() const;
  ::SC2APIProtocol::ActionObserverCameraMove* release_camera_move();
  ::SC2APIProtocol::ActionObserverCameraMove* mutable_camera_move();
  void set_allocated_camera_move(::SC2APIProtocol::ActionObserverCameraMove* camera_move);

  // optional .SC2APIProtocol.ActionObserverCameraFollowPlayer camera_follow_player = 3;
  bool has_camera_follow_player() const;
  void clear_camera_follow_player();
  static const int kCameraFollowPlayerFieldNumber = 3;
  private:
  const ::SC2APIProtocol::ActionObserverCameraFollowPlayer& _internal_camera_follow_player() const;
  public:
  const ::SC2APIProtocol::ActionObserverCameraFollowPlayer& camera_follow_player() const;
  ::SC2APIProtocol::ActionObserverCameraFollowPlayer* release_camera_follow_player();
  ::SC2APIProtocol::ActionObserverCameraFollowPlayer* mutable_camera_follow_player();
  void set_allocated_camera_follow_player(::SC2APIProtocol::ActionObserverCameraFollowPlayer* camera_follow_player);

  // optional .SC2APIProtocol.ActionObserverCameraFollowUnits camera_follow_units = 4;
  bool has_camera_follow_units() const;
  void clear_camera_follow_units();
  static const int kCameraFollowUnitsFieldNumber = 4;
  private:
  const ::SC2APIProtocol::ActionObserverCameraFollowUnits& _internal_camera_follow_units() const;
  public:
  const ::SC2APIProtocol::ActionObserverCameraFollowUnits& camera_follow_units() const;
  ::SC2APIProtocol::ActionObserverCameraFollowUnits* release_camera_follow_units();
  ::SC2APIProtocol::ActionObserverCameraFollowUnits* mutable_camera_follow_units();
  void set_allocated_camera_follow_units(::SC2APIProtocol::ActionObserverCameraFollowUnits* camera_follow_units);

  void clear_action();
  ActionCase action_case() const;
  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ObserverAction)
 private:
  void set_has_player_perspective();
  void set_has_camera_move();
  void set_has_camera_follow_player();
  void set_has_camera_follow_units();

  inline bool has_action() const;
  inline void clear_has_action();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  union ActionUnion {
    ActionUnion() {}
    ::SC2APIProtocol::ActionObserverPlayerPerspective* player_perspective_;
    ::SC2APIProtocol::ActionObserverCameraMove* camera_move_;
    ::SC2APIProtocol::ActionObserverCameraFollowPlayer* camera_follow_player_;
    ::SC2APIProtocol::ActionObserverCameraFollowUnits* camera_follow_units_;
  } action_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActionObserverPlayerPerspective : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ActionObserverPlayerPerspective) */ {
 public:
  ActionObserverPlayerPerspective();
  virtual ~ActionObserverPlayerPerspective();

  ActionObserverPlayerPerspective(const ActionObserverPlayerPerspective& from);

  inline ActionObserverPlayerPerspective& operator=(const ActionObserverPlayerPerspective& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ActionObserverPlayerPerspective(ActionObserverPlayerPerspective&& from) noexcept
    : ActionObserverPlayerPerspective() {
    *this = ::std::move(from);
  }

  inline ActionObserverPlayerPerspective& operator=(ActionObserverPlayerPerspective&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionObserverPlayerPerspective& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionObserverPlayerPerspective* internal_default_instance() {
    return reinterpret_cast<const ActionObserverPlayerPerspective*>(
               &_ActionObserverPlayerPerspective_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  void Swap(ActionObserverPlayerPerspective* other);
  friend void swap(ActionObserverPlayerPerspective& a, ActionObserverPlayerPerspective& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ActionObserverPlayerPerspective* New() const final {
    return CreateMaybeMessage<ActionObserverPlayerPerspective>(NULL);
  }

  ActionObserverPlayerPerspective* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ActionObserverPlayerPerspective>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ActionObserverPlayerPerspective& from);
  void MergeFrom(const ActionObserverPlayerPerspective& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionObserverPlayerPerspective* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 player_id = 1;
  bool has_player_id() const;
  void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  ::google::protobuf::uint32 player_id() const;
  void set_player_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ActionObserverPlayerPerspective)
 private:
  void set_has_player_id();
  void clear_has_player_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 player_id_;
  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActionObserverCameraMove : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ActionObserverCameraMove) */ {
 public:
  ActionObserverCameraMove();
  virtual ~ActionObserverCameraMove();

  ActionObserverCameraMove(const ActionObserverCameraMove& from);

  inline ActionObserverCameraMove& operator=(const ActionObserverCameraMove& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ActionObserverCameraMove(ActionObserverCameraMove&& from) noexcept
    : ActionObserverCameraMove() {
    *this = ::std::move(from);
  }

  inline ActionObserverCameraMove& operator=(ActionObserverCameraMove&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionObserverCameraMove& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionObserverCameraMove* internal_default_instance() {
    return reinterpret_cast<const ActionObserverCameraMove*>(
               &_ActionObserverCameraMove_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  void Swap(ActionObserverCameraMove* other);
  friend void swap(ActionObserverCameraMove& a, ActionObserverCameraMove& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ActionObserverCameraMove* New() const final {
    return CreateMaybeMessage<ActionObserverCameraMove>(NULL);
  }

  ActionObserverCameraMove* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ActionObserverCameraMove>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ActionObserverCameraMove& from);
  void MergeFrom(const ActionObserverCameraMove& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionObserverCameraMove* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SC2APIProtocol.Point2D world_pos = 1;
  bool has_world_pos() const;
  void clear_world_pos();
  static const int kWorldPosFieldNumber = 1;
  private:
  const ::SC2APIProtocol::Point2D& _internal_world_pos() const;
  public:
  const ::SC2APIProtocol::Point2D& world_pos() const;
  ::SC2APIProtocol::Point2D* release_world_pos();
  ::SC2APIProtocol::Point2D* mutable_world_pos();
  void set_allocated_world_pos(::SC2APIProtocol::Point2D* world_pos);

  // optional float distance = 2;
  bool has_distance() const;
  void clear_distance();
  static const int kDistanceFieldNumber = 2;
  float distance() const;
  void set_distance(float value);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ActionObserverCameraMove)
 private:
  void set_has_world_pos();
  void clear_has_world_pos();
  void set_has_distance();
  void clear_has_distance();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::SC2APIProtocol::Point2D* world_pos_;
  float distance_;
  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActionObserverCameraFollowPlayer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ActionObserverCameraFollowPlayer) */ {
 public:
  ActionObserverCameraFollowPlayer();
  virtual ~ActionObserverCameraFollowPlayer();

  ActionObserverCameraFollowPlayer(const ActionObserverCameraFollowPlayer& from);

  inline ActionObserverCameraFollowPlayer& operator=(const ActionObserverCameraFollowPlayer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ActionObserverCameraFollowPlayer(ActionObserverCameraFollowPlayer&& from) noexcept
    : ActionObserverCameraFollowPlayer() {
    *this = ::std::move(from);
  }

  inline ActionObserverCameraFollowPlayer& operator=(ActionObserverCameraFollowPlayer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionObserverCameraFollowPlayer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionObserverCameraFollowPlayer* internal_default_instance() {
    return reinterpret_cast<const ActionObserverCameraFollowPlayer*>(
               &_ActionObserverCameraFollowPlayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  void Swap(ActionObserverCameraFollowPlayer* other);
  friend void swap(ActionObserverCameraFollowPlayer& a, ActionObserverCameraFollowPlayer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ActionObserverCameraFollowPlayer* New() const final {
    return CreateMaybeMessage<ActionObserverCameraFollowPlayer>(NULL);
  }

  ActionObserverCameraFollowPlayer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ActionObserverCameraFollowPlayer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ActionObserverCameraFollowPlayer& from);
  void MergeFrom(const ActionObserverCameraFollowPlayer& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionObserverCameraFollowPlayer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 player_id = 1;
  bool has_player_id() const;
  void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  ::google::protobuf::uint32 player_id() const;
  void set_player_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ActionObserverCameraFollowPlayer)
 private:
  void set_has_player_id();
  void clear_has_player_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 player_id_;
  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActionObserverCameraFollowUnits : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.ActionObserverCameraFollowUnits) */ {
 public:
  ActionObserverCameraFollowUnits();
  virtual ~ActionObserverCameraFollowUnits();

  ActionObserverCameraFollowUnits(const ActionObserverCameraFollowUnits& from);

  inline ActionObserverCameraFollowUnits& operator=(const ActionObserverCameraFollowUnits& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ActionObserverCameraFollowUnits(ActionObserverCameraFollowUnits&& from) noexcept
    : ActionObserverCameraFollowUnits() {
    *this = ::std::move(from);
  }

  inline ActionObserverCameraFollowUnits& operator=(ActionObserverCameraFollowUnits&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionObserverCameraFollowUnits& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionObserverCameraFollowUnits* internal_default_instance() {
    return reinterpret_cast<const ActionObserverCameraFollowUnits*>(
               &_ActionObserverCameraFollowUnits_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  void Swap(ActionObserverCameraFollowUnits* other);
  friend void swap(ActionObserverCameraFollowUnits& a, ActionObserverCameraFollowUnits& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ActionObserverCameraFollowUnits* New() const final {
    return CreateMaybeMessage<ActionObserverCameraFollowUnits>(NULL);
  }

  ActionObserverCameraFollowUnits* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ActionObserverCameraFollowUnits>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ActionObserverCameraFollowUnits& from);
  void MergeFrom(const ActionObserverCameraFollowUnits& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionObserverCameraFollowUnits* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 unit_tags = 1;
  int unit_tags_size() const;
  void clear_unit_tags();
  static const int kUnitTagsFieldNumber = 1;
  ::google::protobuf::uint64 unit_tags(int index) const;
  void set_unit_tags(int index, ::google::protobuf::uint64 value);
  void add_unit_tags(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      unit_tags() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_unit_tags();

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.ActionObserverCameraFollowUnits)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > unit_tags_;
  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PlayerResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SC2APIProtocol.PlayerResult) */ {
 public:
  PlayerResult();
  virtual ~PlayerResult();

  PlayerResult(const PlayerResult& from);

  inline PlayerResult& operator=(const PlayerResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerResult(PlayerResult&& from) noexcept
    : PlayerResult() {
    *this = ::std::move(from);
  }

  inline PlayerResult& operator=(PlayerResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerResult* internal_default_instance() {
    return reinterpret_cast<const PlayerResult*>(
               &_PlayerResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  void Swap(PlayerResult* other);
  friend void swap(PlayerResult& a, PlayerResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerResult* New() const final {
    return CreateMaybeMessage<PlayerResult>(NULL);
  }

  PlayerResult* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PlayerResult>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PlayerResult& from);
  void MergeFrom(const PlayerResult& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 player_id = 1;
  bool has_player_id() const;
  void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  ::google::protobuf::uint32 player_id() const;
  void set_player_id(::google::protobuf::uint32 value);

  // optional .SC2APIProtocol.Result result = 2;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 2;
  ::SC2APIProtocol::Result result() const;
  void set_result(::SC2APIProtocol::Result value);

  // @@protoc_insertion_point(class_scope:SC2APIProtocol.PlayerResult)
 private:
  void set_has_player_id();
  void clear_has_player_id();
  void set_has_result();
  void clear_has_result();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 player_id_;
  int result_;
  friend struct ::protobuf_s2clientprotocol_2fsc2api_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Request

// optional .SC2APIProtocol.RequestCreateGame create_game = 1;
inline bool Request::has_create_game() const {
  return request_case() == kCreateGame;
}
inline void Request::set_has_create_game() {
  _oneof_case_[0] = kCreateGame;
}
inline void Request::clear_create_game() {
  if (has_create_game()) {
    delete request_.create_game_;
    clear_has_request();
  }
}
inline const ::SC2APIProtocol::RequestCreateGame& Request::_internal_create_game() const {
  return *request_.create_game_;
}
inline ::SC2APIProtocol::RequestCreateGame* Request::release_create_game() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.create_game)
  if (has_create_game()) {
    clear_has_request();
      ::SC2APIProtocol::RequestCreateGame* temp = request_.create_game_;
    request_.create_game_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SC2APIProtocol::RequestCreateGame& Request::create_game() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.create_game)
  return has_create_game()
      ? *request_.create_game_
      : *reinterpret_cast< ::SC2APIProtocol::RequestCreateGame*>(&::SC2APIProtocol::_RequestCreateGame_default_instance_);
}
inline ::SC2APIProtocol::RequestCreateGame* Request::mutable_create_game() {
  if (!has_create_game()) {
    clear_request();
    set_has_create_game();
    request_.create_game_ = CreateMaybeMessage< ::SC2APIProtocol::RequestCreateGame >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.create_game)
  return request_.create_game_;
}

// optional .SC2APIProtocol.RequestJoinGame join_game = 2;
inline bool Request::has_join_game() const {
  return request_case() == kJoinGame;
}
inline void Request::set_has_join_game() {
  _oneof_case_[0] = kJoinGame;
}
inline void Request::clear_join_game() {
  if (has_join_game()) {
    delete request_.join_game_;
    clear_has_request();
  }
}
inline const ::SC2APIProtocol::RequestJoinGame& Request::_internal_join_game() const {
  return *request_.join_game_;
}
inline ::SC2APIProtocol::RequestJoinGame* Request::release_join_game() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.join_game)
  if (has_join_game()) {
    clear_has_request();
      ::SC2APIProtocol::RequestJoinGame* temp = request_.join_game_;
    request_.join_game_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SC2APIProtocol::RequestJoinGame& Request::join_game() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.join_game)
  return has_join_game()
      ? *request_.join_game_
      : *reinterpret_cast< ::SC2APIProtocol::RequestJoinGame*>(&::SC2APIProtocol::_RequestJoinGame_default_instance_);
}
inline ::SC2APIProtocol::RequestJoinGame* Request::mutable_join_game() {
  if (!has_join_game()) {
    clear_request();
    set_has_join_game();
    request_.join_game_ = CreateMaybeMessage< ::SC2APIProtocol::RequestJoinGame >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.join_game)
  return request_.join_game_;
}

// optional .SC2APIProtocol.RequestRestartGame restart_game = 3;
inline bool Request::has_restart_game() const {
  return request_case() == kRestartGame;
}
inline void Request::set_has_restart_game() {
  _oneof_case_[0] = kRestartGame;
}
inline void Request::clear_restart_game() {
  if (has_restart_game()) {
    delete request_.restart_game_;
    clear_has_request();
  }
}
inline const ::SC2APIProtocol::RequestRestartGame& Request::_internal_restart_game() const {
  return *request_.restart_game_;
}
inline ::SC2APIProtocol::RequestRestartGame* Request::release_restart_game() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.restart_game)
  if (has_restart_game()) {
    clear_has_request();
      ::SC2APIProtocol::RequestRestartGame* temp = request_.restart_game_;
    request_.restart_game_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SC2APIProtocol::RequestRestartGame& Request::restart_game() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.restart_game)
  return has_restart_game()
      ? *request_.restart_game_
      : *reinterpret_cast< ::SC2APIProtocol::RequestRestartGame*>(&::SC2APIProtocol::_RequestRestartGame_default_instance_);
}
inline ::SC2APIProtocol::RequestRestartGame* Request::mutable_restart_game() {
  if (!has_restart_game()) {
    clear_request();
    set_has_restart_game();
    request_.restart_game_ = CreateMaybeMessage< ::SC2APIProtocol::RequestRestartGame >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.restart_game)
  return request_.restart_game_;
}

// optional .SC2APIProtocol.RequestStartReplay start_replay = 4;
inline bool Request::has_start_replay() const {
  return request_case() == kStartReplay;
}
inline void Request::set_has_start_replay() {
  _oneof_case_[0] = kStartReplay;
}
inline void Request::clear_start_replay() {
  if (has_start_replay()) {
    delete request_.start_replay_;
    clear_has_request();
  }
}
inline const ::SC2APIProtocol::RequestStartReplay& Request::_internal_start_replay() const {
  return *request_.start_replay_;
}
inline ::SC2APIProtocol::RequestStartReplay* Request::release_start_replay() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.start_replay)
  if (has_start_replay()) {
    clear_has_request();
      ::SC2APIProtocol::RequestStartReplay* temp = request_.start_replay_;
    request_.start_replay_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SC2APIProtocol::RequestStartReplay& Request::start_replay() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.start_replay)
  return has_start_replay()
      ? *request_.start_replay_
      : *reinterpret_cast< ::SC2APIProtocol::RequestStartReplay*>(&::SC2APIProtocol::_RequestStartReplay_default_instance_);
}
inline ::SC2APIProtocol::RequestStartReplay* Request::mutable_start_replay() {
  if (!has_start_replay()) {
    clear_request();
    set_has_start_replay();
    request_.start_replay_ = CreateMaybeMessage< ::SC2APIProtocol::RequestStartReplay >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.start_replay)
  return request_.start_replay_;
}

// optional .SC2APIProtocol.RequestLeaveGame leave_game = 5;
inline bool Request::has_leave_game() const {
  return request_case() == kLeaveGame;
}
inline void Request::set_has_leave_game() {
  _oneof_case_[0] = kLeaveGame;
}
inline void Request::clear_leave_game() {
  if (has_leave_game()) {
    delete request_.leave_game_;
    clear_has_request();
  }
}
inline const ::SC2APIProtocol::RequestLeaveGame& Request::_internal_leave_game() const {
  return *request_.leave_game_;
}
inline ::SC2APIProtocol::RequestLeaveGame* Request::release_leave_game() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.leave_game)
  if (has_leave_game()) {
    clear_has_request();
      ::SC2APIProtocol::RequestLeaveGame* temp = request_.leave_game_;
    request_.leave_game_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SC2APIProtocol::RequestLeaveGame& Request::leave_game() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.leave_game)
  return has_leave_game()
      ? *request_.leave_game_
      : *reinterpret_cast< ::SC2APIProtocol::RequestLeaveGame*>(&::SC2APIProtocol::_RequestLeaveGame_default_instance_);
}
inline ::SC2APIProtocol::RequestLeaveGame* Request::mutable_leave_game() {
  if (!has_leave_game()) {
    clear_request();
    set_has_leave_game();
    request_.leave_game_ = CreateMaybeMessage< ::SC2APIProtocol::RequestLeaveGame >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.leave_game)
  return request_.leave_game_;
}

// optional .SC2APIProtocol.RequestQuickSave quick_save = 6;
inline bool Request::has_quick_save() const {
  return request_case() == kQuickSave;
}
inline void Request::set_has_quick_save() {
  _oneof_case_[0] = kQuickSave;
}
inline void Request::clear_quick_save() {
  if (has_quick_save()) {
    delete request_.quick_save_;
    clear_has_request();
  }
}
inline const ::SC2APIProtocol::RequestQuickSave& Request::_internal_quick_save() const {
  return *request_.quick_save_;
}
inline ::SC2APIProtocol::RequestQuickSave* Request::release_quick_save() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.quick_save)
  if (has_quick_save()) {
    clear_has_request();
      ::SC2APIProtocol::RequestQuickSave* temp = request_.quick_save_;
    request_.quick_save_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SC2APIProtocol::RequestQuickSave& Request::quick_save() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.quick_save)
  return has_quick_save()
      ? *request_.quick_save_
      : *reinterpret_cast< ::SC2APIProtocol::RequestQuickSave*>(&::SC2APIProtocol::_RequestQuickSave_default_instance_);
}
inline ::SC2APIProtocol::RequestQuickSave* Request::mutable_quick_save() {
  if (!has_quick_save()) {
    clear_request();
    set_has_quick_save();
    request_.quick_save_ = CreateMaybeMessage< ::SC2APIProtocol::RequestQuickSave >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.quick_save)
  return request_.quick_save_;
}

// optional .SC2APIProtocol.RequestQuickLoad quick_load = 7;
inline bool Request::has_quick_load() const {
  return request_case() == kQuickLoad;
}
inline void Request::set_has_quick_load() {
  _oneof_case_[0] = kQuickLoad;
}
inline void Request::clear_quick_load() {
  if (has_quick_load()) {
    delete request_.quick_load_;
    clear_has_request();
  }
}
inline const ::SC2APIProtocol::RequestQuickLoad& Request::_internal_quick_load() const {
  return *request_.quick_load_;
}
inline ::SC2APIProtocol::RequestQuickLoad* Request::release_quick_load() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.quick_load)
  if (has_quick_load()) {
    clear_has_request();
      ::SC2APIProtocol::RequestQuickLoad* temp = request_.quick_load_;
    request_.quick_load_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SC2APIProtocol::RequestQuickLoad& Request::quick_load() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.quick_load)
  return has_quick_load()
      ? *request_.quick_load_
      : *reinterpret_cast< ::SC2APIProtocol::RequestQuickLoad*>(&::SC2APIProtocol::_RequestQuickLoad_default_instance_);
}
inline ::SC2APIProtocol::RequestQuickLoad* Request::mutable_quick_load() {
  if (!has_quick_load()) {
    clear_request();
    set_has_quick_load();
    request_.quick_load_ = CreateMaybeMessage< ::SC2APIProtocol::RequestQuickLoad >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.quick_load)
  return request_.quick_load_;
}

// optional .SC2APIProtocol.RequestQuit quit = 8;
inline bool Request::has_quit() const {
  return request_case() == kQuit;
}
inline void Request::set_has_quit() {
  _oneof_case_[0] = kQuit;
}
inline void Request::clear_quit() {
  if (has_quit()) {
    delete request_.quit_;
    clear_has_request();
  }
}
inline const ::SC2APIProtocol::RequestQuit& Request::_internal_quit() const {
  return *request_.quit_;
}
inline ::SC2APIProtocol::RequestQuit* Request::release_quit() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.quit)
  if (has_quit()) {
    clear_has_request();
      ::SC2APIProtocol::RequestQuit* temp = request_.quit_;
    request_.quit_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SC2APIProtocol::RequestQuit& Request::quit() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.quit)
  return has_quit()
      ? *request_.quit_
      : *reinterpret_cast< ::SC2APIProtocol::RequestQuit*>(&::SC2APIProtocol::_RequestQuit_default_instance_);
}
inline ::SC2APIProtocol::RequestQuit* Request::mutable_quit() {
  if (!has_quit()) {
    clear_request();
    set_has_quit();
    request_.quit_ = CreateMaybeMessage< ::SC2APIProtocol::RequestQuit >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.quit)
  return request_.quit_;
}

// optional .SC2APIProtocol.RequestGameInfo game_info = 9;
inline bool Request::has_game_info() const {
  return request_case() == kGameInfo;
}
inline void Request::set_has_game_info() {
  _oneof_case_[0] = kGameInfo;
}
inline void Request::clear_game_info() {
  if (has_game_info()) {
    delete request_.game_info_;
    clear_has_request();
  }
}
inline const ::SC2APIProtocol::RequestGameInfo& Request::_internal_game_info() const {
  return *request_.game_info_;
}
inline ::SC2APIProtocol::RequestGameInfo* Request::release_game_info() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.game_info)
  if (has_game_info()) {
    clear_has_request();
      ::SC2APIProtocol::RequestGameInfo* temp = request_.game_info_;
    request_.game_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SC2APIProtocol::RequestGameInfo& Request::game_info() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.game_info)
  return has_game_info()
      ? *request_.game_info_
      : *reinterpret_cast< ::SC2APIProtocol::RequestGameInfo*>(&::SC2APIProtocol::_RequestGameInfo_default_instance_);
}
inline ::SC2APIProtocol::RequestGameInfo* Request::mutable_game_info() {
  if (!has_game_info()) {
    clear_request();
    set_has_game_info();
    request_.game_info_ = CreateMaybeMessage< ::SC2APIProtocol::RequestGameInfo >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.game_info)
  return request_.game_info_;
}

// optional .SC2APIProtocol.RequestObservation observation = 10;
inline bool Request::has_observation() const {
  return request_case() == kObservation;
}
inline void Request::set_has_observation() {
  _oneof_case_[0] = kObservation;
}
inline void Request::clear_observation() {
  if (has_observation()) {
    delete request_.observation_;
    clear_has_request();
  }
}
inline const ::SC2APIProtocol::RequestObservation& Request::_internal_observation() const {
  return *request_.observation_;
}
inline ::SC2APIProtocol::RequestObservation* Request::release_observation() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.observation)
  if (has_observation()) {
    clear_has_request();
      ::SC2APIProtocol::RequestObservation* temp = request_.observation_;
    request_.observation_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SC2APIProtocol::RequestObservation& Request::observation() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.observation)
  return has_observation()
      ? *request_.observation_
      : *reinterpret_cast< ::SC2APIProtocol::RequestObservation*>(&::SC2APIProtocol::_RequestObservation_default_instance_);
}
inline ::SC2APIProtocol::RequestObservation* Request::mutable_observation() {
  if (!has_observation()) {
    clear_request();
    set_has_observation();
    request_.observation_ = CreateMaybeMessage< ::SC2APIProtocol::RequestObservation >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.observation)
  return request_.observation_;
}

// optional .SC2APIProtocol.RequestAction action = 11;
inline bool Request::has_action() const {
  return request_case() == kAction;
}
inline void Request::set_has_action() {
  _oneof_case_[0] = kAction;
}
inline void Request::clear_action() {
  if (has_action()) {
    delete request_.action_;
    clear_has_request();
  }
}
inline const ::SC2APIProtocol::RequestAction& Request::_internal_action() const {
  return *request_.action_;
}
inline ::SC2APIProtocol::RequestAction* Request::release_action() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.action)
  if (has_action()) {
    clear_has_request();
      ::SC2APIProtocol::RequestAction* temp = request_.action_;
    request_.action_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SC2APIProtocol::RequestAction& Request::action() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.action)
  return has_action()
      ? *request_.action_
      : *reinterpret_cast< ::SC2APIProtocol::RequestAction*>(&::SC2APIProtocol::_RequestAction_default_instance_);
}
inline ::SC2APIProtocol::RequestAction* Request::mutable_action() {
  if (!has_action()) {
    clear_request();
    set_has_action();
    request_.action_ = CreateMaybeMessage< ::SC2APIProtocol::RequestAction >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.action)
  return request_.action_;
}

// optional .SC2APIProtocol.RequestObserverAction obs_action = 21;
inline bool Request::has_obs_action() const {
  return request_case() == kObsAction;
}
inline void Request::set_has_obs_action() {
  _oneof_case_[0] = kObsAction;
}
inline void Request::clear_obs_action() {
  if (has_obs_action()) {
    delete request_.obs_action_;
    clear_has_request();
  }
}
inline const ::SC2APIProtocol::RequestObserverAction& Request::_internal_obs_action() const {
  return *request_.obs_action_;
}
inline ::SC2APIProtocol::RequestObserverAction* Request::release_obs_action() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.obs_action)
  if (has_obs_action()) {
    clear_has_request();
      ::SC2APIProtocol::RequestObserverAction* temp = request_.obs_action_;
    request_.obs_action_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SC2APIProtocol::RequestObserverAction& Request::obs_action() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.obs_action)
  return has_obs_action()
      ? *request_.obs_action_
      : *reinterpret_cast< ::SC2APIProtocol::RequestObserverAction*>(&::SC2APIProtocol::_RequestObserverAction_default_instance_);
}
inline ::SC2APIProtocol::RequestObserverAction* Request::mutable_obs_action() {
  if (!has_obs_action()) {
    clear_request();
    set_has_obs_action();
    request_.obs_action_ = CreateMaybeMessage< ::SC2APIProtocol::RequestObserverAction >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.obs_action)
  return request_.obs_action_;
}

// optional .SC2APIProtocol.RequestStep step = 12;
inline bool Request::has_step() const {
  return request_case() == kStep;
}
inline void Request::set_has_step() {
  _oneof_case_[0] = kStep;
}
inline void Request::clear_step() {
  if (has_step()) {
    delete request_.step_;
    clear_has_request();
  }
}
inline const ::SC2APIProtocol::RequestStep& Request::_internal_step() const {
  return *request_.step_;
}
inline ::SC2APIProtocol::RequestStep* Request::release_step() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.step)
  if (has_step()) {
    clear_has_request();
      ::SC2APIProtocol::RequestStep* temp = request_.step_;
    request_.step_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SC2APIProtocol::RequestStep& Request::step() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.step)
  return has_step()
      ? *request_.step_
      : *reinterpret_cast< ::SC2APIProtocol::RequestStep*>(&::SC2APIProtocol::_RequestStep_default_instance_);
}
inline ::SC2APIProtocol::RequestStep* Request::mutable_step() {
  if (!has_step()) {
    clear_request();
    set_has_step();
    request_.step_ = CreateMaybeMessage< ::SC2APIProtocol::RequestStep >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.step)
  return request_.step_;
}

// optional .SC2APIProtocol.RequestData data = 13;
inline bool Request::has_data() const {
  return request_case() == kData;
}
inline void Request::set_has_data() {
  _oneof_case_[0] = kData;
}
inline void Request::clear_data() {
  if (has_data()) {
    delete request_.data_;
    clear_has_request();
  }
}
inline const ::SC2APIProtocol::RequestData& Request::_internal_data() const {
  return *request_.data_;
}
inline ::SC2APIProtocol::RequestData* Request::release_data() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.data)
  if (has_data()) {
    clear_has_request();
      ::SC2APIProtocol::RequestData* temp = request_.data_;
    request_.data_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SC2APIProtocol::RequestData& Request::data() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.data)
  return has_data()
      ? *request_.data_
      : *reinterpret_cast< ::SC2APIProtocol::RequestData*>(&::SC2APIProtocol::_RequestData_default_instance_);
}
inline ::SC2APIProtocol::RequestData* Request::mutable_data() {
  if (!has_data()) {
    clear_request();
    set_has_data();
    request_.data_ = CreateMaybeMessage< ::SC2APIProtocol::RequestData >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.data)
  return request_.data_;
}

// optional .SC2APIProtocol.RequestQuery query = 14;
inline bool Request::has_query() const {
  return request_case() == kQuery;
}
inline void Request::set_has_query() {
  _oneof_case_[0] = kQuery;
}
inline const ::SC2APIProtocol::RequestQuery& Request::_internal_query() const {
  return *request_.query_;
}
inline ::SC2APIProtocol::RequestQuery* Request::release_query() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.query)
  if (has_query()) {
    clear_has_request();
      ::SC2APIProtocol::RequestQuery* temp = request_.query_;
    request_.query_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SC2APIProtocol::RequestQuery& Request::query() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.query)
  return has_query()
      ? *request_.query_
      : *reinterpret_cast< ::SC2APIProtocol::RequestQuery*>(&::SC2APIProtocol::_RequestQuery_default_instance_);
}
inline ::SC2APIProtocol::RequestQuery* Request::mutable_query() {
  if (!has_query()) {
    clear_request();
    set_has_query();
    request_.query_ = CreateMaybeMessage< ::SC2APIProtocol::RequestQuery >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.query)
  return request_.query_;
}

// optional .SC2APIProtocol.RequestSaveReplay save_replay = 15;
inline bool Request::has_save_replay() const {
  return request_case() == kSaveReplay;
}
inline void Request::set_has_save_replay() {
  _oneof_case_[0] = kSaveReplay;
}
inline void Request::clear_save_replay() {
  if (has_save_replay()) {
    delete request_.save_replay_;
    clear_has_request();
  }
}
inline const ::SC2APIProtocol::RequestSaveReplay& Request::_internal_save_replay() const {
  return *request_.save_replay_;
}
inline ::SC2APIProtocol::RequestSaveReplay* Request::release_save_replay() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.save_replay)
  if (has_save_replay()) {
    clear_has_request();
      ::SC2APIProtocol::RequestSaveReplay* temp = request_.save_replay_;
    request_.save_replay_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SC2APIProtocol::RequestSaveReplay& Request::save_replay() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.save_replay)
  return has_save_replay()
      ? *request_.save_replay_
      : *reinterpret_cast< ::SC2APIProtocol::RequestSaveReplay*>(&::SC2APIProtocol::_RequestSaveReplay_default_instance_);
}
inline ::SC2APIProtocol::RequestSaveReplay* Request::mutable_save_replay() {
  if (!has_save_replay()) {
    clear_request();
    set_has_save_replay();
    request_.save_replay_ = CreateMaybeMessage< ::SC2APIProtocol::RequestSaveReplay >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.save_replay)
  return request_.save_replay_;
}

// optional .SC2APIProtocol.RequestReplayInfo replay_info = 16;
inline bool Request::has_replay_info() const {
  return request_case() == kReplayInfo;
}
inline void Request::set_has_replay_info() {
  _oneof_case_[0] = kReplayInfo;
}
inline void Request::clear_replay_info() {
  if (has_replay_info()) {
    delete request_.replay_info_;
    clear_has_request();
  }
}
inline const ::SC2APIProtocol::RequestReplayInfo& Request::_internal_replay_info() const {
  return *request_.replay_info_;
}
inline ::SC2APIProtocol::RequestReplayInfo* Request::release_replay_info() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.replay_info)
  if (has_replay_info()) {
    clear_has_request();
      ::SC2APIProtocol::RequestReplayInfo* temp = request_.replay_info_;
    request_.replay_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SC2APIProtocol::RequestReplayInfo& Request::replay_info() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.replay_info)
  return has_replay_info()
      ? *request_.replay_info_
      : *reinterpret_cast< ::SC2APIProtocol::RequestReplayInfo*>(&::SC2APIProtocol::_RequestReplayInfo_default_instance_);
}
inline ::SC2APIProtocol::RequestReplayInfo* Request::mutable_replay_info() {
  if (!has_replay_info()) {
    clear_request();
    set_has_replay_info();
    request_.replay_info_ = CreateMaybeMessage< ::SC2APIProtocol::RequestReplayInfo >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.replay_info)
  return request_.replay_info_;
}

// optional .SC2APIProtocol.RequestAvailableMaps available_maps = 17;
inline bool Request::has_available_maps() const {
  return request_case() == kAvailableMaps;
}
inline void Request::set_has_available_maps() {
  _oneof_case_[0] = kAvailableMaps;
}
inline void Request::clear_available_maps() {
  if (has_available_maps()) {
    delete request_.available_maps_;
    clear_has_request();
  }
}
inline const ::SC2APIProtocol::RequestAvailableMaps& Request::_internal_available_maps() const {
  return *request_.available_maps_;
}
inline ::SC2APIProtocol::RequestAvailableMaps* Request::release_available_maps() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.available_maps)
  if (has_available_maps()) {
    clear_has_request();
      ::SC2APIProtocol::RequestAvailableMaps* temp = request_.available_maps_;
    request_.available_maps_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SC2APIProtocol::RequestAvailableMaps& Request::available_maps() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.available_maps)
  return has_available_maps()
      ? *request_.available_maps_
      : *reinterpret_cast< ::SC2APIProtocol::RequestAvailableMaps*>(&::SC2APIProtocol::_RequestAvailableMaps_default_instance_);
}
inline ::SC2APIProtocol::RequestAvailableMaps* Request::mutable_available_maps() {
  if (!has_available_maps()) {
    clear_request();
    set_has_available_maps();
    request_.available_maps_ = CreateMaybeMessage< ::SC2APIProtocol::RequestAvailableMaps >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.available_maps)
  return request_.available_maps_;
}

// optional .SC2APIProtocol.RequestSaveMap save_map = 18;
inline bool Request::has_save_map() const {
  return request_case() == kSaveMap;
}
inline void Request::set_has_save_map() {
  _oneof_case_[0] = kSaveMap;
}
inline void Request::clear_save_map() {
  if (has_save_map()) {
    delete request_.save_map_;
    clear_has_request();
  }
}
inline const ::SC2APIProtocol::RequestSaveMap& Request::_internal_save_map() const {
  return *request_.save_map_;
}
inline ::SC2APIProtocol::RequestSaveMap* Request::release_save_map() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.save_map)
  if (has_save_map()) {
    clear_has_request();
      ::SC2APIProtocol::RequestSaveMap* temp = request_.save_map_;
    request_.save_map_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SC2APIProtocol::RequestSaveMap& Request::save_map() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.save_map)
  return has_save_map()
      ? *request_.save_map_
      : *reinterpret_cast< ::SC2APIProtocol::RequestSaveMap*>(&::SC2APIProtocol::_RequestSaveMap_default_instance_);
}
inline ::SC2APIProtocol::RequestSaveMap* Request::mutable_save_map() {
  if (!has_save_map()) {
    clear_request();
    set_has_save_map();
    request_.save_map_ = CreateMaybeMessage< ::SC2APIProtocol::RequestSaveMap >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.save_map)
  return request_.save_map_;
}

// optional .SC2APIProtocol.RequestPing ping = 19;
inline bool Request::has_ping() const {
  return request_case() == kPing;
}
inline void Request::set_has_ping() {
  _oneof_case_[0] = kPing;
}
inline void Request::clear_ping() {
  if (has_ping()) {
    delete request_.ping_;
    clear_has_request();
  }
}
inline const ::SC2APIProtocol::RequestPing& Request::_internal_ping() const {
  return *request_.ping_;
}
inline ::SC2APIProtocol::RequestPing* Request::release_ping() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.ping)
  if (has_ping()) {
    clear_has_request();
      ::SC2APIProtocol::RequestPing* temp = request_.ping_;
    request_.ping_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SC2APIProtocol::RequestPing& Request::ping() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.ping)
  return has_ping()
      ? *request_.ping_
      : *reinterpret_cast< ::SC2APIProtocol::RequestPing*>(&::SC2APIProtocol::_RequestPing_default_instance_);
}
inline ::SC2APIProtocol::RequestPing* Request::mutable_ping() {
  if (!has_ping()) {
    clear_request();
    set_has_ping();
    request_.ping_ = CreateMaybeMessage< ::SC2APIProtocol::RequestPing >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.ping)
  return request_.ping_;
}

// optional .SC2APIProtocol.RequestDebug debug = 20;
inline bool Request::has_debug() const {
  return request_case() == kDebug;
}
inline void Request::set_has_debug() {
  _oneof_case_[0] = kDebug;
}
inline void Request::clear_debug() {
  if (has_debug()) {
    delete request_.debug_;
    clear_has_request();
  }
}
inline const ::SC2APIProtocol::RequestDebug& Request::_internal_debug() const {
  return *request_.debug_;
}
inline ::SC2APIProtocol::RequestDebug* Request::release_debug() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Request.debug)
  if (has_debug()) {
    clear_has_request();
      ::SC2APIProtocol::RequestDebug* temp = request_.debug_;
    request_.debug_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SC2APIProtocol::RequestDebug& Request::debug() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Request.debug)
  return has_debug()
      ? *request_.debug_
      : *reinterpret_cast< ::SC2APIProtocol::RequestDebug*>(&::SC2APIProtocol::_RequestDebug_default_instance_);
}
inline ::SC2APIProtocol::RequestDebug* Request::mutable_debug() {
  if (!has_debug()) {
    clear_request();
    set_has_debug();
    request_.debug_ = CreateMaybeMessage< ::SC2APIProtocol::RequestDebug >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Request.debug)
  return request_.debug_;
}

inline bool Request::has_request() const {
  return request_case() != REQUEST_NOT_SET;
}
inline void Request::clear_has_request() {
  _oneof_case_[0] = REQUEST_NOT_SET;
}
inline Request::RequestCase Request::request_case() const {
  return Request::RequestCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Response

// optional .SC2APIProtocol.ResponseCreateGame create_game = 1;
inline bool Response::has_create_game() const {
  return response_case() == kCreateGame;
}
inline void Response::set_has_create_game() {
  _oneof_case_[0] = kCreateGame;
}
inline void Response::clear_create_game() {
  if (has_create_game()) {
    delete response_.create_game_;
    clear_has_response();
  }
}
inline const ::SC2APIProtocol::ResponseCreateGame& Response::_internal_create_game() const {
  return *response_.create_game_;
}
inline ::SC2APIProtocol::ResponseCreateGame* Response::release_create_game() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.create_game)
  if (has_create_game()) {
    clear_has_response();
      ::SC2APIProtocol::ResponseCreateGame* temp = response_.create_game_;
    response_.create_game_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SC2APIProtocol::ResponseCreateGame& Response::create_game() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.create_game)
  return has_create_game()
      ? *response_.create_game_
      : *reinterpret_cast< ::SC2APIProtocol::ResponseCreateGame*>(&::SC2APIProtocol::_ResponseCreateGame_default_instance_);
}
inline ::SC2APIProtocol::ResponseCreateGame* Response::mutable_create_game() {
  if (!has_create_game()) {
    clear_response();
    set_has_create_game();
    response_.create_game_ = CreateMaybeMessage< ::SC2APIProtocol::ResponseCreateGame >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.create_game)
  return response_.create_game_;
}

// optional .SC2APIProtocol.ResponseJoinGame join_game = 2;
inline bool Response::has_join_game() const {
  return response_case() == kJoinGame;
}
inline void Response::set_has_join_game() {
  _oneof_case_[0] = kJoinGame;
}
inline void Response::clear_join_game() {
  if (has_join_game()) {
    delete response_.join_game_;
    clear_has_response();
  }
}
inline const ::SC2APIProtocol::ResponseJoinGame& Response::_internal_join_game() const {
  return *response_.join_game_;
}
inline ::SC2APIProtocol::ResponseJoinGame* Response::release_join_game() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.join_game)
  if (has_join_game()) {
    clear_has_response();
      ::SC2APIProtocol::ResponseJoinGame* temp = response_.join_game_;
    response_.join_game_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SC2APIProtocol::ResponseJoinGame& Response::join_game() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.join_game)
  return has_join_game()
      ? *response_.join_game_
      : *reinterpret_cast< ::SC2APIProtocol::ResponseJoinGame*>(&::SC2APIProtocol::_ResponseJoinGame_default_instance_);
}
inline ::SC2APIProtocol::ResponseJoinGame* Response::mutable_join_game() {
  if (!has_join_game()) {
    clear_response();
    set_has_join_game();
    response_.join_game_ = CreateMaybeMessage< ::SC2APIProtocol::ResponseJoinGame >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.join_game)
  return response_.join_game_;
}

// optional .SC2APIProtocol.ResponseRestartGame restart_game = 3;
inline bool Response::has_restart_game() const {
  return response_case() == kRestartGame;
}
inline void Response::set_has_restart_game() {
  _oneof_case_[0] = kRestartGame;
}
inline void Response::clear_restart_game() {
  if (has_restart_game()) {
    delete response_.restart_game_;
    clear_has_response();
  }
}
inline const ::SC2APIProtocol::ResponseRestartGame& Response::_internal_restart_game() const {
  return *response_.restart_game_;
}
inline ::SC2APIProtocol::ResponseRestartGame* Response::release_restart_game() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.restart_game)
  if (has_restart_game()) {
    clear_has_response();
      ::SC2APIProtocol::ResponseRestartGame* temp = response_.restart_game_;
    response_.restart_game_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SC2APIProtocol::ResponseRestartGame& Response::restart_game() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.restart_game)
  return has_restart_game()
      ? *response_.restart_game_
      : *reinterpret_cast< ::SC2APIProtocol::ResponseRestartGame*>(&::SC2APIProtocol::_ResponseRestartGame_default_instance_);
}
inline ::SC2APIProtocol::ResponseRestartGame* Response::mutable_restart_game() {
  if (!has_restart_game()) {
    clear_response();
    set_has_restart_game();
    response_.restart_game_ = CreateMaybeMessage< ::SC2APIProtocol::ResponseRestartGame >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.restart_game)
  return response_.restart_game_;
}

// optional .SC2APIProtocol.ResponseStartReplay start_replay = 4;
inline bool Response::has_start_replay() const {
  return response_case() == kStartReplay;
}
inline void Response::set_has_start_replay() {
  _oneof_case_[0] = kStartReplay;
}
inline void Response::clear_start_replay() {
  if (has_start_replay()) {
    delete response_.start_replay_;
    clear_has_response();
  }
}
inline const ::SC2APIProtocol::ResponseStartReplay& Response::_internal_start_replay() const {
  return *response_.start_replay_;
}
inline ::SC2APIProtocol::ResponseStartReplay* Response::release_start_replay() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.start_replay)
  if (has_start_replay()) {
    clear_has_response();
      ::SC2APIProtocol::ResponseStartReplay* temp = response_.start_replay_;
    response_.start_replay_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SC2APIProtocol::ResponseStartReplay& Response::start_replay() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.start_replay)
  return has_start_replay()
      ? *response_.start_replay_
      : *reinterpret_cast< ::SC2APIProtocol::ResponseStartReplay*>(&::SC2APIProtocol::_ResponseStartReplay_default_instance_);
}
inline ::SC2APIProtocol::ResponseStartReplay* Response::mutable_start_replay() {
  if (!has_start_replay()) {
    clear_response();
    set_has_start_replay();
    response_.start_replay_ = CreateMaybeMessage< ::SC2APIProtocol::ResponseStartReplay >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.start_replay)
  return response_.start_replay_;
}

// optional .SC2APIProtocol.ResponseLeaveGame leave_game = 5;
inline bool Response::has_leave_game() const {
  return response_case() == kLeaveGame;
}
inline void Response::set_has_leave_game() {
  _oneof_case_[0] = kLeaveGame;
}
inline void Response::clear_leave_game() {
  if (has_leave_game()) {
    delete response_.leave_game_;
    clear_has_response();
  }
}
inline const ::SC2APIProtocol::ResponseLeaveGame& Response::_internal_leave_game() const {
  return *response_.leave_game_;
}
inline ::SC2APIProtocol::ResponseLeaveGame* Response::release_leave_game() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.leave_game)
  if (has_leave_game()) {
    clear_has_response();
      ::SC2APIProtocol::ResponseLeaveGame* temp = response_.leave_game_;
    response_.leave_game_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SC2APIProtocol::ResponseLeaveGame& Response::leave_game() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.leave_game)
  return has_leave_game()
      ? *response_.leave_game_
      : *reinterpret_cast< ::SC2APIProtocol::ResponseLeaveGame*>(&::SC2APIProtocol::_ResponseLeaveGame_default_instance_);
}
inline ::SC2APIProtocol::ResponseLeaveGame* Response::mutable_leave_game() {
  if (!has_leave_game()) {
    clear_response();
    set_has_leave_game();
    response_.leave_game_ = CreateMaybeMessage< ::SC2APIProtocol::ResponseLeaveGame >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.leave_game)
  return response_.leave_game_;
}

// optional .SC2APIProtocol.ResponseQuickSave quick_save = 6;
inline bool Response::has_quick_save() const {
  return response_case() == kQuickSave;
}
inline void Response::set_has_quick_save() {
  _oneof_case_[0] = kQuickSave;
}
inline void Response::clear_quick_save() {
  if (has_quick_save()) {
    delete response_.quick_save_;
    clear_has_response();
  }
}
inline const ::SC2APIProtocol::ResponseQuickSave& Response::_internal_quick_save() const {
  return *response_.quick_save_;
}
inline ::SC2APIProtocol::ResponseQuickSave* Response::release_quick_save() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.quick_save)
  if (has_quick_save()) {
    clear_has_response();
      ::SC2APIProtocol::ResponseQuickSave* temp = response_.quick_save_;
    response_.quick_save_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SC2APIProtocol::ResponseQuickSave& Response::quick_save() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.quick_save)
  return has_quick_save()
      ? *response_.quick_save_
      : *reinterpret_cast< ::SC2APIProtocol::ResponseQuickSave*>(&::SC2APIProtocol::_ResponseQuickSave_default_instance_);
}
inline ::SC2APIProtocol::ResponseQuickSave* Response::mutable_quick_save() {
  if (!has_quick_save()) {
    clear_response();
    set_has_quick_save();
    response_.quick_save_ = CreateMaybeMessage< ::SC2APIProtocol::ResponseQuickSave >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.quick_save)
  return response_.quick_save_;
}

// optional .SC2APIProtocol.ResponseQuickLoad quick_load = 7;
inline bool Response::has_quick_load() const {
  return response_case() == kQuickLoad;
}
inline void Response::set_has_quick_load() {
  _oneof_case_[0] = kQuickLoad;
}
inline void Response::clear_quick_load() {
  if (has_quick_load()) {
    delete response_.quick_load_;
    clear_has_response();
  }
}
inline const ::SC2APIProtocol::ResponseQuickLoad& Response::_internal_quick_load() const {
  return *response_.quick_load_;
}
inline ::SC2APIProtocol::ResponseQuickLoad* Response::release_quick_load() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.quick_load)
  if (has_quick_load()) {
    clear_has_response();
      ::SC2APIProtocol::ResponseQuickLoad* temp = response_.quick_load_;
    response_.quick_load_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SC2APIProtocol::ResponseQuickLoad& Response::quick_load() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.quick_load)
  return has_quick_load()
      ? *response_.quick_load_
      : *reinterpret_cast< ::SC2APIProtocol::ResponseQuickLoad*>(&::SC2APIProtocol::_ResponseQuickLoad_default_instance_);
}
inline ::SC2APIProtocol::ResponseQuickLoad* Response::mutable_quick_load() {
  if (!has_quick_load()) {
    clear_response();
    set_has_quick_load();
    response_.quick_load_ = CreateMaybeMessage< ::SC2APIProtocol::ResponseQuickLoad >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.quick_load)
  return response_.quick_load_;
}

// optional .SC2APIProtocol.ResponseQuit quit = 8;
inline bool Response::has_quit() const {
  return response_case() == kQuit;
}
inline void Response::set_has_quit() {
  _oneof_case_[0] = kQuit;
}
inline void Response::clear_quit() {
  if (has_quit()) {
    delete response_.quit_;
    clear_has_response();
  }
}
inline const ::SC2APIProtocol::ResponseQuit& Response::_internal_quit() const {
  return *response_.quit_;
}
inline ::SC2APIProtocol::ResponseQuit* Response::release_quit() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.quit)
  if (has_quit()) {
    clear_has_response();
      ::SC2APIProtocol::ResponseQuit* temp = response_.quit_;
    response_.quit_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SC2APIProtocol::ResponseQuit& Response::quit() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.quit)
  return has_quit()
      ? *response_.quit_
      : *reinterpret_cast< ::SC2APIProtocol::ResponseQuit*>(&::SC2APIProtocol::_ResponseQuit_default_instance_);
}
inline ::SC2APIProtocol::ResponseQuit* Response::mutable_quit() {
  if (!has_quit()) {
    clear_response();
    set_has_quit();
    response_.quit_ = CreateMaybeMessage< ::SC2APIProtocol::ResponseQuit >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.quit)
  return response_.quit_;
}

// optional .SC2APIProtocol.ResponseGameInfo game_info = 9;
inline bool Response::has_game_info() const {
  return response_case() == kGameInfo;
}
inline void Response::set_has_game_info() {
  _oneof_case_[0] = kGameInfo;
}
inline void Response::clear_game_info() {
  if (has_game_info()) {
    delete response_.game_info_;
    clear_has_response();
  }
}
inline const ::SC2APIProtocol::ResponseGameInfo& Response::_internal_game_info() const {
  return *response_.game_info_;
}
inline ::SC2APIProtocol::ResponseGameInfo* Response::release_game_info() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.game_info)
  if (has_game_info()) {
    clear_has_response();
      ::SC2APIProtocol::ResponseGameInfo* temp = response_.game_info_;
    response_.game_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SC2APIProtocol::ResponseGameInfo& Response::game_info() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.game_info)
  return has_game_info()
      ? *response_.game_info_
      : *reinterpret_cast< ::SC2APIProtocol::ResponseGameInfo*>(&::SC2APIProtocol::_ResponseGameInfo_default_instance_);
}
inline ::SC2APIProtocol::ResponseGameInfo* Response::mutable_game_info() {
  if (!has_game_info()) {
    clear_response();
    set_has_game_info();
    response_.game_info_ = CreateMaybeMessage< ::SC2APIProtocol::ResponseGameInfo >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.game_info)
  return response_.game_info_;
}

// optional .SC2APIProtocol.ResponseObservation observation = 10;
inline bool Response::has_observation() const {
  return response_case() == kObservation;
}
inline void Response::set_has_observation() {
  _oneof_case_[0] = kObservation;
}
inline void Response::clear_observation() {
  if (has_observation()) {
    delete response_.observation_;
    clear_has_response();
  }
}
inline const ::SC2APIProtocol::ResponseObservation& Response::_internal_observation() const {
  return *response_.observation_;
}
inline ::SC2APIProtocol::ResponseObservation* Response::release_observation() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.observation)
  if (has_observation()) {
    clear_has_response();
      ::SC2APIProtocol::ResponseObservation* temp = response_.observation_;
    response_.observation_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SC2APIProtocol::ResponseObservation& Response::observation() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.observation)
  return has_observation()
      ? *response_.observation_
      : *reinterpret_cast< ::SC2APIProtocol::ResponseObservation*>(&::SC2APIProtocol::_ResponseObservation_default_instance_);
}
inline ::SC2APIProtocol::ResponseObservation* Response::mutable_observation() {
  if (!has_observation()) {
    clear_response();
    set_has_observation();
    response_.observation_ = CreateMaybeMessage< ::SC2APIProtocol::ResponseObservation >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.observation)
  return response_.observation_;
}

// optional .SC2APIProtocol.ResponseAction action = 11;
inline bool Response::has_action() const {
  return response_case() == kAction;
}
inline void Response::set_has_action() {
  _oneof_case_[0] = kAction;
}
inline void Response::clear_action() {
  if (has_action()) {
    delete response_.action_;
    clear_has_response();
  }
}
inline const ::SC2APIProtocol::ResponseAction& Response::_internal_action() const {
  return *response_.action_;
}
inline ::SC2APIProtocol::ResponseAction* Response::release_action() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.action)
  if (has_action()) {
    clear_has_response();
      ::SC2APIProtocol::ResponseAction* temp = response_.action_;
    response_.action_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SC2APIProtocol::ResponseAction& Response::action() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.action)
  return has_action()
      ? *response_.action_
      : *reinterpret_cast< ::SC2APIProtocol::ResponseAction*>(&::SC2APIProtocol::_ResponseAction_default_instance_);
}
inline ::SC2APIProtocol::ResponseAction* Response::mutable_action() {
  if (!has_action()) {
    clear_response();
    set_has_action();
    response_.action_ = CreateMaybeMessage< ::SC2APIProtocol::ResponseAction >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.action)
  return response_.action_;
}

// optional .SC2APIProtocol.ResponseObserverAction obs_action = 21;
inline bool Response::has_obs_action() const {
  return response_case() == kObsAction;
}
inline void Response::set_has_obs_action() {
  _oneof_case_[0] = kObsAction;
}
inline void Response::clear_obs_action() {
  if (has_obs_action()) {
    delete response_.obs_action_;
    clear_has_response();
  }
}
inline const ::SC2APIProtocol::ResponseObserverAction& Response::_internal_obs_action() const {
  return *response_.obs_action_;
}
inline ::SC2APIProtocol::ResponseObserverAction* Response::release_obs_action() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.obs_action)
  if (has_obs_action()) {
    clear_has_response();
      ::SC2APIProtocol::ResponseObserverAction* temp = response_.obs_action_;
    response_.obs_action_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SC2APIProtocol::ResponseObserverAction& Response::obs_action() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.obs_action)
  return has_obs_action()
      ? *response_.obs_action_
      : *reinterpret_cast< ::SC2APIProtocol::ResponseObserverAction*>(&::SC2APIProtocol::_ResponseObserverAction_default_instance_);
}
inline ::SC2APIProtocol::ResponseObserverAction* Response::mutable_obs_action() {
  if (!has_obs_action()) {
    clear_response();
    set_has_obs_action();
    response_.obs_action_ = CreateMaybeMessage< ::SC2APIProtocol::ResponseObserverAction >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.obs_action)
  return response_.obs_action_;
}

// optional .SC2APIProtocol.ResponseStep step = 12;
inline bool Response::has_step() const {
  return response_case() == kStep;
}
inline void Response::set_has_step() {
  _oneof_case_[0] = kStep;
}
inline void Response::clear_step() {
  if (has_step()) {
    delete response_.step_;
    clear_has_response();
  }
}
inline const ::SC2APIProtocol::ResponseStep& Response::_internal_step() const {
  return *response_.step_;
}
inline ::SC2APIProtocol::ResponseStep* Response::release_step() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.step)
  if (has_step()) {
    clear_has_response();
      ::SC2APIProtocol::ResponseStep* temp = response_.step_;
    response_.step_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SC2APIProtocol::ResponseStep& Response::step() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.step)
  return has_step()
      ? *response_.step_
      : *reinterpret_cast< ::SC2APIProtocol::ResponseStep*>(&::SC2APIProtocol::_ResponseStep_default_instance_);
}
inline ::SC2APIProtocol::ResponseStep* Response::mutable_step() {
  if (!has_step()) {
    clear_response();
    set_has_step();
    response_.step_ = CreateMaybeMessage< ::SC2APIProtocol::ResponseStep >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.step)
  return response_.step_;
}

// optional .SC2APIProtocol.ResponseData data = 13;
inline bool Response::has_data() const {
  return response_case() == kData;
}
inline void Response::set_has_data() {
  _oneof_case_[0] = kData;
}
inline void Response::clear_data() {
  if (has_data()) {
    delete response_.data_;
    clear_has_response();
  }
}
inline const ::SC2APIProtocol::ResponseData& Response::_internal_data() const {
  return *response_.data_;
}
inline ::SC2APIProtocol::ResponseData* Response::release_data() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.data)
  if (has_data()) {
    clear_has_response();
      ::SC2APIProtocol::ResponseData* temp = response_.data_;
    response_.data_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SC2APIProtocol::ResponseData& Response::data() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.data)
  return has_data()
      ? *response_.data_
      : *reinterpret_cast< ::SC2APIProtocol::ResponseData*>(&::SC2APIProtocol::_ResponseData_default_instance_);
}
inline ::SC2APIProtocol::ResponseData* Response::mutable_data() {
  if (!has_data()) {
    clear_response();
    set_has_data();
    response_.data_ = CreateMaybeMessage< ::SC2APIProtocol::ResponseData >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.data)
  return response_.data_;
}

// optional .SC2APIProtocol.ResponseQuery query = 14;
inline bool Response::has_query() const {
  return response_case() == kQuery;
}
inline void Response::set_has_query() {
  _oneof_case_[0] = kQuery;
}
inline const ::SC2APIProtocol::ResponseQuery& Response::_internal_query() const {
  return *response_.query_;
}
inline ::SC2APIProtocol::ResponseQuery* Response::release_query() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.query)
  if (has_query()) {
    clear_has_response();
      ::SC2APIProtocol::ResponseQuery* temp = response_.query_;
    response_.query_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SC2APIProtocol::ResponseQuery& Response::query() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.query)
  return has_query()
      ? *response_.query_
      : *reinterpret_cast< ::SC2APIProtocol::ResponseQuery*>(&::SC2APIProtocol::_ResponseQuery_default_instance_);
}
inline ::SC2APIProtocol::ResponseQuery* Response::mutable_query() {
  if (!has_query()) {
    clear_response();
    set_has_query();
    response_.query_ = CreateMaybeMessage< ::SC2APIProtocol::ResponseQuery >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.query)
  return response_.query_;
}

// optional .SC2APIProtocol.ResponseSaveReplay save_replay = 15;
inline bool Response::has_save_replay() const {
  return response_case() == kSaveReplay;
}
inline void Response::set_has_save_replay() {
  _oneof_case_[0] = kSaveReplay;
}
inline void Response::clear_save_replay() {
  if (has_save_replay()) {
    delete response_.save_replay_;
    clear_has_response();
  }
}
inline const ::SC2APIProtocol::ResponseSaveReplay& Response::_internal_save_replay() const {
  return *response_.save_replay_;
}
inline ::SC2APIProtocol::ResponseSaveReplay* Response::release_save_replay() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.save_replay)
  if (has_save_replay()) {
    clear_has_response();
      ::SC2APIProtocol::ResponseSaveReplay* temp = response_.save_replay_;
    response_.save_replay_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SC2APIProtocol::ResponseSaveReplay& Response::save_replay() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.save_replay)
  return has_save_replay()
      ? *response_.save_replay_
      : *reinterpret_cast< ::SC2APIProtocol::ResponseSaveReplay*>(&::SC2APIProtocol::_ResponseSaveReplay_default_instance_);
}
inline ::SC2APIProtocol::ResponseSaveReplay* Response::mutable_save_replay() {
  if (!has_save_replay()) {
    clear_response();
    set_has_save_replay();
    response_.save_replay_ = CreateMaybeMessage< ::SC2APIProtocol::ResponseSaveReplay >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.save_replay)
  return response_.save_replay_;
}

// optional .SC2APIProtocol.ResponseReplayInfo replay_info = 16;
inline bool Response::has_replay_info() const {
  return response_case() == kReplayInfo;
}
inline void Response::set_has_replay_info() {
  _oneof_case_[0] = kReplayInfo;
}
inline void Response::clear_replay_info() {
  if (has_replay_info()) {
    delete response_.replay_info_;
    clear_has_response();
  }
}
inline const ::SC2APIProtocol::ResponseReplayInfo& Response::_internal_replay_info() const {
  return *response_.replay_info_;
}
inline ::SC2APIProtocol::ResponseReplayInfo* Response::release_replay_info() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.replay_info)
  if (has_replay_info()) {
    clear_has_response();
      ::SC2APIProtocol::ResponseReplayInfo* temp = response_.replay_info_;
    response_.replay_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SC2APIProtocol::ResponseReplayInfo& Response::replay_info() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.replay_info)
  return has_replay_info()
      ? *response_.replay_info_
      : *reinterpret_cast< ::SC2APIProtocol::ResponseReplayInfo*>(&::SC2APIProtocol::_ResponseReplayInfo_default_instance_);
}
inline ::SC2APIProtocol::ResponseReplayInfo* Response::mutable_replay_info() {
  if (!has_replay_info()) {
    clear_response();
    set_has_replay_info();
    response_.replay_info_ = CreateMaybeMessage< ::SC2APIProtocol::ResponseReplayInfo >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.replay_info)
  return response_.replay_info_;
}

// optional .SC2APIProtocol.ResponseAvailableMaps available_maps = 17;
inline bool Response::has_available_maps() const {
  return response_case() == kAvailableMaps;
}
inline void Response::set_has_available_maps() {
  _oneof_case_[0] = kAvailableMaps;
}
inline void Response::clear_available_maps() {
  if (has_available_maps()) {
    delete response_.available_maps_;
    clear_has_response();
  }
}
inline const ::SC2APIProtocol::ResponseAvailableMaps& Response::_internal_available_maps() const {
  return *response_.available_maps_;
}
inline ::SC2APIProtocol::ResponseAvailableMaps* Response::release_available_maps() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.available_maps)
  if (has_available_maps()) {
    clear_has_response();
      ::SC2APIProtocol::ResponseAvailableMaps* temp = response_.available_maps_;
    response_.available_maps_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SC2APIProtocol::ResponseAvailableMaps& Response::available_maps() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.available_maps)
  return has_available_maps()
      ? *response_.available_maps_
      : *reinterpret_cast< ::SC2APIProtocol::ResponseAvailableMaps*>(&::SC2APIProtocol::_ResponseAvailableMaps_default_instance_);
}
inline ::SC2APIProtocol::ResponseAvailableMaps* Response::mutable_available_maps() {
  if (!has_available_maps()) {
    clear_response();
    set_has_available_maps();
    response_.available_maps_ = CreateMaybeMessage< ::SC2APIProtocol::ResponseAvailableMaps >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.available_maps)
  return response_.available_maps_;
}

// optional .SC2APIProtocol.ResponseSaveMap save_map = 18;
inline bool Response::has_save_map() const {
  return response_case() == kSaveMap;
}
inline void Response::set_has_save_map() {
  _oneof_case_[0] = kSaveMap;
}
inline void Response::clear_save_map() {
  if (has_save_map()) {
    delete response_.save_map_;
    clear_has_response();
  }
}
inline const ::SC2APIProtocol::ResponseSaveMap& Response::_internal_save_map() const {
  return *response_.save_map_;
}
inline ::SC2APIProtocol::ResponseSaveMap* Response::release_save_map() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.save_map)
  if (has_save_map()) {
    clear_has_response();
      ::SC2APIProtocol::ResponseSaveMap* temp = response_.save_map_;
    response_.save_map_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SC2APIProtocol::ResponseSaveMap& Response::save_map() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.save_map)
  return has_save_map()
      ? *response_.save_map_
      : *reinterpret_cast< ::SC2APIProtocol::ResponseSaveMap*>(&::SC2APIProtocol::_ResponseSaveMap_default_instance_);
}
inline ::SC2APIProtocol::ResponseSaveMap* Response::mutable_save_map() {
  if (!has_save_map()) {
    clear_response();
    set_has_save_map();
    response_.save_map_ = CreateMaybeMessage< ::SC2APIProtocol::ResponseSaveMap >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.save_map)
  return response_.save_map_;
}

// optional .SC2APIProtocol.ResponsePing ping = 19;
inline bool Response::has_ping() const {
  return response_case() == kPing;
}
inline void Response::set_has_ping() {
  _oneof_case_[0] = kPing;
}
inline void Response::clear_ping() {
  if (has_ping()) {
    delete response_.ping_;
    clear_has_response();
  }
}
inline const ::SC2APIProtocol::ResponsePing& Response::_internal_ping() const {
  return *response_.ping_;
}
inline ::SC2APIProtocol::ResponsePing* Response::release_ping() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.ping)
  if (has_ping()) {
    clear_has_response();
      ::SC2APIProtocol::ResponsePing* temp = response_.ping_;
    response_.ping_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SC2APIProtocol::ResponsePing& Response::ping() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.ping)
  return has_ping()
      ? *response_.ping_
      : *reinterpret_cast< ::SC2APIProtocol::ResponsePing*>(&::SC2APIProtocol::_ResponsePing_default_instance_);
}
inline ::SC2APIProtocol::ResponsePing* Response::mutable_ping() {
  if (!has_ping()) {
    clear_response();
    set_has_ping();
    response_.ping_ = CreateMaybeMessage< ::SC2APIProtocol::ResponsePing >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.ping)
  return response_.ping_;
}

// optional .SC2APIProtocol.ResponseDebug debug = 20;
inline bool Response::has_debug() const {
  return response_case() == kDebug;
}
inline void Response::set_has_debug() {
  _oneof_case_[0] = kDebug;
}
inline void Response::clear_debug() {
  if (has_debug()) {
    delete response_.debug_;
    clear_has_response();
  }
}
inline const ::SC2APIProtocol::ResponseDebug& Response::_internal_debug() const {
  return *response_.debug_;
}
inline ::SC2APIProtocol::ResponseDebug* Response::release_debug() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Response.debug)
  if (has_debug()) {
    clear_has_response();
      ::SC2APIProtocol::ResponseDebug* temp = response_.debug_;
    response_.debug_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SC2APIProtocol::ResponseDebug& Response::debug() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.debug)
  return has_debug()
      ? *response_.debug_
      : *reinterpret_cast< ::SC2APIProtocol::ResponseDebug*>(&::SC2APIProtocol::_ResponseDebug_default_instance_);
}
inline ::SC2APIProtocol::ResponseDebug* Response::mutable_debug() {
  if (!has_debug()) {
    clear_response();
    set_has_debug();
    response_.debug_ = CreateMaybeMessage< ::SC2APIProtocol::ResponseDebug >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.debug)
  return response_.debug_;
}

// repeated string error = 98;
inline int Response::error_size() const {
  return error_.size();
}
inline void Response::clear_error() {
  error_.Clear();
}
inline const ::std::string& Response::error(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.error)
  return error_.Get(index);
}
inline ::std::string* Response::mutable_error(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Response.error)
  return error_.Mutable(index);
}
inline void Response::set_error(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Response.error)
  error_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Response::set_error(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Response.error)
  error_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Response::set_error(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  error_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.Response.error)
}
inline void Response::set_error(int index, const char* value, size_t size) {
  error_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.Response.error)
}
inline ::std::string* Response::add_error() {
  // @@protoc_insertion_point(field_add_mutable:SC2APIProtocol.Response.error)
  return error_.Add();
}
inline void Response::add_error(const ::std::string& value) {
  error_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:SC2APIProtocol.Response.error)
}
#if LANG_CXX11
inline void Response::add_error(::std::string&& value) {
  error_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:SC2APIProtocol.Response.error)
}
#endif
inline void Response::add_error(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  error_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SC2APIProtocol.Response.error)
}
inline void Response::add_error(const char* value, size_t size) {
  error_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SC2APIProtocol.Response.error)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Response::error() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.Response.error)
  return error_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Response::mutable_error() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.Response.error)
  return &error_;
}

// optional .SC2APIProtocol.Status status = 99;
inline bool Response::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::SC2APIProtocol::Status Response::status() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Response.status)
  return static_cast< ::SC2APIProtocol::Status >(status_);
}
inline void Response::set_status(::SC2APIProtocol::Status value) {
  assert(::SC2APIProtocol::Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Response.status)
}

inline bool Response::has_response() const {
  return response_case() != RESPONSE_NOT_SET;
}
inline void Response::clear_has_response() {
  _oneof_case_[0] = RESPONSE_NOT_SET;
}
inline Response::ResponseCase Response::response_case() const {
  return Response::ResponseCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RequestCreateGame

// optional .SC2APIProtocol.LocalMap local_map = 1;
inline bool RequestCreateGame::has_local_map() const {
  return Map_case() == kLocalMap;
}
inline void RequestCreateGame::set_has_local_map() {
  _oneof_case_[0] = kLocalMap;
}
inline void RequestCreateGame::clear_local_map() {
  if (has_local_map()) {
    delete Map_.local_map_;
    clear_has_Map();
  }
}
inline const ::SC2APIProtocol::LocalMap& RequestCreateGame::_internal_local_map() const {
  return *Map_.local_map_;
}
inline ::SC2APIProtocol::LocalMap* RequestCreateGame::release_local_map() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.RequestCreateGame.local_map)
  if (has_local_map()) {
    clear_has_Map();
      ::SC2APIProtocol::LocalMap* temp = Map_.local_map_;
    Map_.local_map_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SC2APIProtocol::LocalMap& RequestCreateGame::local_map() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestCreateGame.local_map)
  return has_local_map()
      ? *Map_.local_map_
      : *reinterpret_cast< ::SC2APIProtocol::LocalMap*>(&::SC2APIProtocol::_LocalMap_default_instance_);
}
inline ::SC2APIProtocol::LocalMap* RequestCreateGame::mutable_local_map() {
  if (!has_local_map()) {
    clear_Map();
    set_has_local_map();
    Map_.local_map_ = CreateMaybeMessage< ::SC2APIProtocol::LocalMap >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RequestCreateGame.local_map)
  return Map_.local_map_;
}

// optional string battlenet_map_name = 2;
inline bool RequestCreateGame::has_battlenet_map_name() const {
  return Map_case() == kBattlenetMapName;
}
inline void RequestCreateGame::set_has_battlenet_map_name() {
  _oneof_case_[0] = kBattlenetMapName;
}
inline void RequestCreateGame::clear_battlenet_map_name() {
  if (has_battlenet_map_name()) {
    Map_.battlenet_map_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_Map();
  }
}
inline const ::std::string& RequestCreateGame::battlenet_map_name() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestCreateGame.battlenet_map_name)
  if (has_battlenet_map_name()) {
    return Map_.battlenet_map_name_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void RequestCreateGame::set_battlenet_map_name(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestCreateGame.battlenet_map_name)
  if (!has_battlenet_map_name()) {
    clear_Map();
    set_has_battlenet_map_name();
    Map_.battlenet_map_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  Map_.battlenet_map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestCreateGame.battlenet_map_name)
}
#if LANG_CXX11
inline void RequestCreateGame::set_battlenet_map_name(::std::string&& value) {
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestCreateGame.battlenet_map_name)
  if (!has_battlenet_map_name()) {
    clear_Map();
    set_has_battlenet_map_name();
    Map_.battlenet_map_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  Map_.battlenet_map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.RequestCreateGame.battlenet_map_name)
}
#endif
inline void RequestCreateGame::set_battlenet_map_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_battlenet_map_name()) {
    clear_Map();
    set_has_battlenet_map_name();
    Map_.battlenet_map_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  Map_.battlenet_map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.RequestCreateGame.battlenet_map_name)
}
inline void RequestCreateGame::set_battlenet_map_name(const char* value, size_t size) {
  if (!has_battlenet_map_name()) {
    clear_Map();
    set_has_battlenet_map_name();
    Map_.battlenet_map_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  Map_.battlenet_map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.RequestCreateGame.battlenet_map_name)
}
inline ::std::string* RequestCreateGame::mutable_battlenet_map_name() {
  if (!has_battlenet_map_name()) {
    clear_Map();
    set_has_battlenet_map_name();
    Map_.battlenet_map_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RequestCreateGame.battlenet_map_name)
  return Map_.battlenet_map_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestCreateGame::release_battlenet_map_name() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.RequestCreateGame.battlenet_map_name)
  if (has_battlenet_map_name()) {
    clear_has_Map();
    return Map_.battlenet_map_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void RequestCreateGame::set_allocated_battlenet_map_name(::std::string* battlenet_map_name) {
  if (!has_battlenet_map_name()) {
    Map_.battlenet_map_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_Map();
  if (battlenet_map_name != NULL) {
    set_has_battlenet_map_name();
    Map_.battlenet_map_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), battlenet_map_name);
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.RequestCreateGame.battlenet_map_name)
}

// repeated .SC2APIProtocol.PlayerSetup player_setup = 3;
inline int RequestCreateGame::player_setup_size() const {
  return player_setup_.size();
}
inline void RequestCreateGame::clear_player_setup() {
  player_setup_.Clear();
}
inline ::SC2APIProtocol::PlayerSetup* RequestCreateGame::mutable_player_setup(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RequestCreateGame.player_setup)
  return player_setup_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PlayerSetup >*
RequestCreateGame::mutable_player_setup() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.RequestCreateGame.player_setup)
  return &player_setup_;
}
inline const ::SC2APIProtocol::PlayerSetup& RequestCreateGame::player_setup(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestCreateGame.player_setup)
  return player_setup_.Get(index);
}
inline ::SC2APIProtocol::PlayerSetup* RequestCreateGame::add_player_setup() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.RequestCreateGame.player_setup)
  return player_setup_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PlayerSetup >&
RequestCreateGame::player_setup() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.RequestCreateGame.player_setup)
  return player_setup_;
}

// optional bool disable_fog = 4;
inline bool RequestCreateGame::has_disable_fog() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestCreateGame::set_has_disable_fog() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestCreateGame::clear_has_disable_fog() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestCreateGame::clear_disable_fog() {
  disable_fog_ = false;
  clear_has_disable_fog();
}
inline bool RequestCreateGame::disable_fog() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestCreateGame.disable_fog)
  return disable_fog_;
}
inline void RequestCreateGame::set_disable_fog(bool value) {
  set_has_disable_fog();
  disable_fog_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestCreateGame.disable_fog)
}

// optional uint32 random_seed = 5;
inline bool RequestCreateGame::has_random_seed() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestCreateGame::set_has_random_seed() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestCreateGame::clear_has_random_seed() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestCreateGame::clear_random_seed() {
  random_seed_ = 0u;
  clear_has_random_seed();
}
inline ::google::protobuf::uint32 RequestCreateGame::random_seed() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestCreateGame.random_seed)
  return random_seed_;
}
inline void RequestCreateGame::set_random_seed(::google::protobuf::uint32 value) {
  set_has_random_seed();
  random_seed_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestCreateGame.random_seed)
}

// optional bool realtime = 6;
inline bool RequestCreateGame::has_realtime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestCreateGame::set_has_realtime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestCreateGame::clear_has_realtime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestCreateGame::clear_realtime() {
  realtime_ = false;
  clear_has_realtime();
}
inline bool RequestCreateGame::realtime() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestCreateGame.realtime)
  return realtime_;
}
inline void RequestCreateGame::set_realtime(bool value) {
  set_has_realtime();
  realtime_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestCreateGame.realtime)
}

inline bool RequestCreateGame::has_Map() const {
  return Map_case() != MAP_NOT_SET;
}
inline void RequestCreateGame::clear_has_Map() {
  _oneof_case_[0] = MAP_NOT_SET;
}
inline RequestCreateGame::MapCase RequestCreateGame::Map_case() const {
  return RequestCreateGame::MapCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// LocalMap

// optional string map_path = 1;
inline bool LocalMap::has_map_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocalMap::set_has_map_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocalMap::clear_has_map_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocalMap::clear_map_path() {
  map_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_map_path();
}
inline const ::std::string& LocalMap::map_path() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.LocalMap.map_path)
  return map_path_.GetNoArena();
}
inline void LocalMap::set_map_path(const ::std::string& value) {
  set_has_map_path();
  map_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.LocalMap.map_path)
}
#if LANG_CXX11
inline void LocalMap::set_map_path(::std::string&& value) {
  set_has_map_path();
  map_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.LocalMap.map_path)
}
#endif
inline void LocalMap::set_map_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_map_path();
  map_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.LocalMap.map_path)
}
inline void LocalMap::set_map_path(const char* value, size_t size) {
  set_has_map_path();
  map_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.LocalMap.map_path)
}
inline ::std::string* LocalMap::mutable_map_path() {
  set_has_map_path();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.LocalMap.map_path)
  return map_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LocalMap::release_map_path() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.LocalMap.map_path)
  if (!has_map_path()) {
    return NULL;
  }
  clear_has_map_path();
  return map_path_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LocalMap::set_allocated_map_path(::std::string* map_path) {
  if (map_path != NULL) {
    set_has_map_path();
  } else {
    clear_has_map_path();
  }
  map_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map_path);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.LocalMap.map_path)
}

// optional bytes map_data = 7;
inline bool LocalMap::has_map_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LocalMap::set_has_map_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LocalMap::clear_has_map_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LocalMap::clear_map_data() {
  map_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_map_data();
}
inline const ::std::string& LocalMap::map_data() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.LocalMap.map_data)
  return map_data_.GetNoArena();
}
inline void LocalMap::set_map_data(const ::std::string& value) {
  set_has_map_data();
  map_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.LocalMap.map_data)
}
#if LANG_CXX11
inline void LocalMap::set_map_data(::std::string&& value) {
  set_has_map_data();
  map_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.LocalMap.map_data)
}
#endif
inline void LocalMap::set_map_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_map_data();
  map_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.LocalMap.map_data)
}
inline void LocalMap::set_map_data(const void* value, size_t size) {
  set_has_map_data();
  map_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.LocalMap.map_data)
}
inline ::std::string* LocalMap::mutable_map_data() {
  set_has_map_data();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.LocalMap.map_data)
  return map_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LocalMap::release_map_data() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.LocalMap.map_data)
  if (!has_map_data()) {
    return NULL;
  }
  clear_has_map_data();
  return map_data_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LocalMap::set_allocated_map_data(::std::string* map_data) {
  if (map_data != NULL) {
    set_has_map_data();
  } else {
    clear_has_map_data();
  }
  map_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map_data);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.LocalMap.map_data)
}

// -------------------------------------------------------------------

// ResponseCreateGame

// optional .SC2APIProtocol.ResponseCreateGame.Error error = 1;
inline bool ResponseCreateGame::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseCreateGame::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseCreateGame::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseCreateGame::clear_error() {
  error_ = 1;
  clear_has_error();
}
inline ::SC2APIProtocol::ResponseCreateGame_Error ResponseCreateGame::error() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseCreateGame.error)
  return static_cast< ::SC2APIProtocol::ResponseCreateGame_Error >(error_);
}
inline void ResponseCreateGame::set_error(::SC2APIProtocol::ResponseCreateGame_Error value) {
  assert(::SC2APIProtocol::ResponseCreateGame_Error_IsValid(value));
  set_has_error();
  error_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseCreateGame.error)
}

// optional string error_details = 2;
inline bool ResponseCreateGame::has_error_details() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseCreateGame::set_has_error_details() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseCreateGame::clear_has_error_details() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseCreateGame::clear_error_details() {
  error_details_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error_details();
}
inline const ::std::string& ResponseCreateGame::error_details() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseCreateGame.error_details)
  return error_details_.GetNoArena();
}
inline void ResponseCreateGame::set_error_details(const ::std::string& value) {
  set_has_error_details();
  error_details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseCreateGame.error_details)
}
#if LANG_CXX11
inline void ResponseCreateGame::set_error_details(::std::string&& value) {
  set_has_error_details();
  error_details_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.ResponseCreateGame.error_details)
}
#endif
inline void ResponseCreateGame::set_error_details(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_error_details();
  error_details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ResponseCreateGame.error_details)
}
inline void ResponseCreateGame::set_error_details(const char* value, size_t size) {
  set_has_error_details();
  error_details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ResponseCreateGame.error_details)
}
inline ::std::string* ResponseCreateGame::mutable_error_details() {
  set_has_error_details();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseCreateGame.error_details)
  return error_details_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseCreateGame::release_error_details() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ResponseCreateGame.error_details)
  if (!has_error_details()) {
    return NULL;
  }
  clear_has_error_details();
  return error_details_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseCreateGame::set_allocated_error_details(::std::string* error_details) {
  if (error_details != NULL) {
    set_has_error_details();
  } else {
    clear_has_error_details();
  }
  error_details_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_details);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ResponseCreateGame.error_details)
}

// -------------------------------------------------------------------

// RequestJoinGame

// optional .SC2APIProtocol.Race race = 1;
inline bool RequestJoinGame::has_race() const {
  return participation_case() == kRace;
}
inline void RequestJoinGame::set_has_race() {
  _oneof_case_[0] = kRace;
}
inline void RequestJoinGame::clear_race() {
  if (has_race()) {
    participation_.race_ = 0;
    clear_has_participation();
  }
}
inline ::SC2APIProtocol::Race RequestJoinGame::race() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestJoinGame.race)
  if (has_race()) {
    return static_cast< ::SC2APIProtocol::Race >(participation_.race_);
  }
  return static_cast< ::SC2APIProtocol::Race >(0);
}
inline void RequestJoinGame::set_race(::SC2APIProtocol::Race value) {
  assert(::SC2APIProtocol::Race_IsValid(value));
  if (!has_race()) {
    clear_participation();
    set_has_race();
  }
  participation_.race_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestJoinGame.race)
}

// optional uint32 observed_player_id = 2;
inline bool RequestJoinGame::has_observed_player_id() const {
  return participation_case() == kObservedPlayerId;
}
inline void RequestJoinGame::set_has_observed_player_id() {
  _oneof_case_[0] = kObservedPlayerId;
}
inline void RequestJoinGame::clear_observed_player_id() {
  if (has_observed_player_id()) {
    participation_.observed_player_id_ = 0u;
    clear_has_participation();
  }
}
inline ::google::protobuf::uint32 RequestJoinGame::observed_player_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestJoinGame.observed_player_id)
  if (has_observed_player_id()) {
    return participation_.observed_player_id_;
  }
  return 0u;
}
inline void RequestJoinGame::set_observed_player_id(::google::protobuf::uint32 value) {
  if (!has_observed_player_id()) {
    clear_participation();
    set_has_observed_player_id();
  }
  participation_.observed_player_id_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestJoinGame.observed_player_id)
}

// optional .SC2APIProtocol.InterfaceOptions options = 3;
inline bool RequestJoinGame::has_options() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestJoinGame::set_has_options() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestJoinGame::clear_has_options() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestJoinGame::clear_options() {
  if (options_ != NULL) options_->Clear();
  clear_has_options();
}
inline const ::SC2APIProtocol::InterfaceOptions& RequestJoinGame::_internal_options() const {
  return *options_;
}
inline const ::SC2APIProtocol::InterfaceOptions& RequestJoinGame::options() const {
  const ::SC2APIProtocol::InterfaceOptions* p = options_;
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestJoinGame.options)
  return p != NULL ? *p : *reinterpret_cast<const ::SC2APIProtocol::InterfaceOptions*>(
      &::SC2APIProtocol::_InterfaceOptions_default_instance_);
}
inline ::SC2APIProtocol::InterfaceOptions* RequestJoinGame::release_options() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.RequestJoinGame.options)
  clear_has_options();
  ::SC2APIProtocol::InterfaceOptions* temp = options_;
  options_ = NULL;
  return temp;
}
inline ::SC2APIProtocol::InterfaceOptions* RequestJoinGame::mutable_options() {
  set_has_options();
  if (options_ == NULL) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::InterfaceOptions>(GetArenaNoVirtual());
    options_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RequestJoinGame.options)
  return options_;
}
inline void RequestJoinGame::set_allocated_options(::SC2APIProtocol::InterfaceOptions* options) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete options_;
  }
  if (options) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      options = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    set_has_options();
  } else {
    clear_has_options();
  }
  options_ = options;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.RequestJoinGame.options)
}

// optional .SC2APIProtocol.PortSet server_ports = 4;
inline bool RequestJoinGame::has_server_ports() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestJoinGame::set_has_server_ports() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestJoinGame::clear_has_server_ports() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestJoinGame::clear_server_ports() {
  if (server_ports_ != NULL) server_ports_->Clear();
  clear_has_server_ports();
}
inline const ::SC2APIProtocol::PortSet& RequestJoinGame::_internal_server_ports() const {
  return *server_ports_;
}
inline const ::SC2APIProtocol::PortSet& RequestJoinGame::server_ports() const {
  const ::SC2APIProtocol::PortSet* p = server_ports_;
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestJoinGame.server_ports)
  return p != NULL ? *p : *reinterpret_cast<const ::SC2APIProtocol::PortSet*>(
      &::SC2APIProtocol::_PortSet_default_instance_);
}
inline ::SC2APIProtocol::PortSet* RequestJoinGame::release_server_ports() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.RequestJoinGame.server_ports)
  clear_has_server_ports();
  ::SC2APIProtocol::PortSet* temp = server_ports_;
  server_ports_ = NULL;
  return temp;
}
inline ::SC2APIProtocol::PortSet* RequestJoinGame::mutable_server_ports() {
  set_has_server_ports();
  if (server_ports_ == NULL) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::PortSet>(GetArenaNoVirtual());
    server_ports_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RequestJoinGame.server_ports)
  return server_ports_;
}
inline void RequestJoinGame::set_allocated_server_ports(::SC2APIProtocol::PortSet* server_ports) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete server_ports_;
  }
  if (server_ports) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      server_ports = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, server_ports, submessage_arena);
    }
    set_has_server_ports();
  } else {
    clear_has_server_ports();
  }
  server_ports_ = server_ports;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.RequestJoinGame.server_ports)
}

// repeated .SC2APIProtocol.PortSet client_ports = 5;
inline int RequestJoinGame::client_ports_size() const {
  return client_ports_.size();
}
inline void RequestJoinGame::clear_client_ports() {
  client_ports_.Clear();
}
inline ::SC2APIProtocol::PortSet* RequestJoinGame::mutable_client_ports(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RequestJoinGame.client_ports)
  return client_ports_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PortSet >*
RequestJoinGame::mutable_client_ports() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.RequestJoinGame.client_ports)
  return &client_ports_;
}
inline const ::SC2APIProtocol::PortSet& RequestJoinGame::client_ports(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestJoinGame.client_ports)
  return client_ports_.Get(index);
}
inline ::SC2APIProtocol::PortSet* RequestJoinGame::add_client_ports() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.RequestJoinGame.client_ports)
  return client_ports_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PortSet >&
RequestJoinGame::client_ports() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.RequestJoinGame.client_ports)
  return client_ports_;
}

// optional int32 shared_port = 6;
inline bool RequestJoinGame::has_shared_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestJoinGame::set_has_shared_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestJoinGame::clear_has_shared_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestJoinGame::clear_shared_port() {
  shared_port_ = 0;
  clear_has_shared_port();
}
inline ::google::protobuf::int32 RequestJoinGame::shared_port() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestJoinGame.shared_port)
  return shared_port_;
}
inline void RequestJoinGame::set_shared_port(::google::protobuf::int32 value) {
  set_has_shared_port();
  shared_port_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestJoinGame.shared_port)
}

inline bool RequestJoinGame::has_participation() const {
  return participation_case() != PARTICIPATION_NOT_SET;
}
inline void RequestJoinGame::clear_has_participation() {
  _oneof_case_[0] = PARTICIPATION_NOT_SET;
}
inline RequestJoinGame::ParticipationCase RequestJoinGame::participation_case() const {
  return RequestJoinGame::ParticipationCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// PortSet

// optional int32 game_port = 1;
inline bool PortSet::has_game_port() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PortSet::set_has_game_port() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PortSet::clear_has_game_port() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PortSet::clear_game_port() {
  game_port_ = 0;
  clear_has_game_port();
}
inline ::google::protobuf::int32 PortSet::game_port() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PortSet.game_port)
  return game_port_;
}
inline void PortSet::set_game_port(::google::protobuf::int32 value) {
  set_has_game_port();
  game_port_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PortSet.game_port)
}

// optional int32 base_port = 2;
inline bool PortSet::has_base_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PortSet::set_has_base_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PortSet::clear_has_base_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PortSet::clear_base_port() {
  base_port_ = 0;
  clear_has_base_port();
}
inline ::google::protobuf::int32 PortSet::base_port() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PortSet.base_port)
  return base_port_;
}
inline void PortSet::set_base_port(::google::protobuf::int32 value) {
  set_has_base_port();
  base_port_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PortSet.base_port)
}

// -------------------------------------------------------------------

// ResponseJoinGame

// optional uint32 player_id = 1;
inline bool ResponseJoinGame::has_player_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseJoinGame::set_has_player_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseJoinGame::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseJoinGame::clear_player_id() {
  player_id_ = 0u;
  clear_has_player_id();
}
inline ::google::protobuf::uint32 ResponseJoinGame::player_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseJoinGame.player_id)
  return player_id_;
}
inline void ResponseJoinGame::set_player_id(::google::protobuf::uint32 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseJoinGame.player_id)
}

// optional .SC2APIProtocol.ResponseJoinGame.Error error = 2;
inline bool ResponseJoinGame::has_error() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseJoinGame::set_has_error() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseJoinGame::clear_has_error() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseJoinGame::clear_error() {
  error_ = 1;
  clear_has_error();
}
inline ::SC2APIProtocol::ResponseJoinGame_Error ResponseJoinGame::error() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseJoinGame.error)
  return static_cast< ::SC2APIProtocol::ResponseJoinGame_Error >(error_);
}
inline void ResponseJoinGame::set_error(::SC2APIProtocol::ResponseJoinGame_Error value) {
  assert(::SC2APIProtocol::ResponseJoinGame_Error_IsValid(value));
  set_has_error();
  error_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseJoinGame.error)
}

// optional string error_details = 3;
inline bool ResponseJoinGame::has_error_details() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseJoinGame::set_has_error_details() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseJoinGame::clear_has_error_details() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseJoinGame::clear_error_details() {
  error_details_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error_details();
}
inline const ::std::string& ResponseJoinGame::error_details() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseJoinGame.error_details)
  return error_details_.GetNoArena();
}
inline void ResponseJoinGame::set_error_details(const ::std::string& value) {
  set_has_error_details();
  error_details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseJoinGame.error_details)
}
#if LANG_CXX11
inline void ResponseJoinGame::set_error_details(::std::string&& value) {
  set_has_error_details();
  error_details_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.ResponseJoinGame.error_details)
}
#endif
inline void ResponseJoinGame::set_error_details(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_error_details();
  error_details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ResponseJoinGame.error_details)
}
inline void ResponseJoinGame::set_error_details(const char* value, size_t size) {
  set_has_error_details();
  error_details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ResponseJoinGame.error_details)
}
inline ::std::string* ResponseJoinGame::mutable_error_details() {
  set_has_error_details();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseJoinGame.error_details)
  return error_details_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseJoinGame::release_error_details() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ResponseJoinGame.error_details)
  if (!has_error_details()) {
    return NULL;
  }
  clear_has_error_details();
  return error_details_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseJoinGame::set_allocated_error_details(::std::string* error_details) {
  if (error_details != NULL) {
    set_has_error_details();
  } else {
    clear_has_error_details();
  }
  error_details_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_details);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ResponseJoinGame.error_details)
}

// -------------------------------------------------------------------

// RequestRestartGame

// -------------------------------------------------------------------

// ResponseRestartGame

// optional .SC2APIProtocol.ResponseRestartGame.Error error = 1;
inline bool ResponseRestartGame::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseRestartGame::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseRestartGame::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseRestartGame::clear_error() {
  error_ = 1;
  clear_has_error();
}
inline ::SC2APIProtocol::ResponseRestartGame_Error ResponseRestartGame::error() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseRestartGame.error)
  return static_cast< ::SC2APIProtocol::ResponseRestartGame_Error >(error_);
}
inline void ResponseRestartGame::set_error(::SC2APIProtocol::ResponseRestartGame_Error value) {
  assert(::SC2APIProtocol::ResponseRestartGame_Error_IsValid(value));
  set_has_error();
  error_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseRestartGame.error)
}

// optional string error_details = 2;
inline bool ResponseRestartGame::has_error_details() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseRestartGame::set_has_error_details() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseRestartGame::clear_has_error_details() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseRestartGame::clear_error_details() {
  error_details_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error_details();
}
inline const ::std::string& ResponseRestartGame::error_details() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseRestartGame.error_details)
  return error_details_.GetNoArena();
}
inline void ResponseRestartGame::set_error_details(const ::std::string& value) {
  set_has_error_details();
  error_details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseRestartGame.error_details)
}
#if LANG_CXX11
inline void ResponseRestartGame::set_error_details(::std::string&& value) {
  set_has_error_details();
  error_details_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.ResponseRestartGame.error_details)
}
#endif
inline void ResponseRestartGame::set_error_details(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_error_details();
  error_details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ResponseRestartGame.error_details)
}
inline void ResponseRestartGame::set_error_details(const char* value, size_t size) {
  set_has_error_details();
  error_details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ResponseRestartGame.error_details)
}
inline ::std::string* ResponseRestartGame::mutable_error_details() {
  set_has_error_details();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseRestartGame.error_details)
  return error_details_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseRestartGame::release_error_details() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ResponseRestartGame.error_details)
  if (!has_error_details()) {
    return NULL;
  }
  clear_has_error_details();
  return error_details_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseRestartGame::set_allocated_error_details(::std::string* error_details) {
  if (error_details != NULL) {
    set_has_error_details();
  } else {
    clear_has_error_details();
  }
  error_details_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_details);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ResponseRestartGame.error_details)
}

// -------------------------------------------------------------------

// RequestStartReplay

// optional string replay_path = 1;
inline bool RequestStartReplay::has_replay_path() const {
  return replay_case() == kReplayPath;
}
inline void RequestStartReplay::set_has_replay_path() {
  _oneof_case_[0] = kReplayPath;
}
inline void RequestStartReplay::clear_replay_path() {
  if (has_replay_path()) {
    replay_.replay_path_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_replay();
  }
}
inline const ::std::string& RequestStartReplay::replay_path() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestStartReplay.replay_path)
  if (has_replay_path()) {
    return replay_.replay_path_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void RequestStartReplay::set_replay_path(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestStartReplay.replay_path)
  if (!has_replay_path()) {
    clear_replay();
    set_has_replay_path();
    replay_.replay_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestStartReplay.replay_path)
}
#if LANG_CXX11
inline void RequestStartReplay::set_replay_path(::std::string&& value) {
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestStartReplay.replay_path)
  if (!has_replay_path()) {
    clear_replay();
    set_has_replay_path();
    replay_.replay_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.RequestStartReplay.replay_path)
}
#endif
inline void RequestStartReplay::set_replay_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_replay_path()) {
    clear_replay();
    set_has_replay_path();
    replay_.replay_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.RequestStartReplay.replay_path)
}
inline void RequestStartReplay::set_replay_path(const char* value, size_t size) {
  if (!has_replay_path()) {
    clear_replay();
    set_has_replay_path();
    replay_.replay_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.RequestStartReplay.replay_path)
}
inline ::std::string* RequestStartReplay::mutable_replay_path() {
  if (!has_replay_path()) {
    clear_replay();
    set_has_replay_path();
    replay_.replay_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RequestStartReplay.replay_path)
  return replay_.replay_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestStartReplay::release_replay_path() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.RequestStartReplay.replay_path)
  if (has_replay_path()) {
    clear_has_replay();
    return replay_.replay_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void RequestStartReplay::set_allocated_replay_path(::std::string* replay_path) {
  if (!has_replay_path()) {
    replay_.replay_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_replay();
  if (replay_path != NULL) {
    set_has_replay_path();
    replay_.replay_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), replay_path);
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.RequestStartReplay.replay_path)
}

// optional bytes replay_data = 5;
inline bool RequestStartReplay::has_replay_data() const {
  return replay_case() == kReplayData;
}
inline void RequestStartReplay::set_has_replay_data() {
  _oneof_case_[0] = kReplayData;
}
inline void RequestStartReplay::clear_replay_data() {
  if (has_replay_data()) {
    replay_.replay_data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_replay();
  }
}
inline const ::std::string& RequestStartReplay::replay_data() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestStartReplay.replay_data)
  if (has_replay_data()) {
    return replay_.replay_data_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void RequestStartReplay::set_replay_data(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestStartReplay.replay_data)
  if (!has_replay_data()) {
    clear_replay();
    set_has_replay_data();
    replay_.replay_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestStartReplay.replay_data)
}
#if LANG_CXX11
inline void RequestStartReplay::set_replay_data(::std::string&& value) {
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestStartReplay.replay_data)
  if (!has_replay_data()) {
    clear_replay();
    set_has_replay_data();
    replay_.replay_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.RequestStartReplay.replay_data)
}
#endif
inline void RequestStartReplay::set_replay_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_replay_data()) {
    clear_replay();
    set_has_replay_data();
    replay_.replay_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.RequestStartReplay.replay_data)
}
inline void RequestStartReplay::set_replay_data(const void* value, size_t size) {
  if (!has_replay_data()) {
    clear_replay();
    set_has_replay_data();
    replay_.replay_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.RequestStartReplay.replay_data)
}
inline ::std::string* RequestStartReplay::mutable_replay_data() {
  if (!has_replay_data()) {
    clear_replay();
    set_has_replay_data();
    replay_.replay_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RequestStartReplay.replay_data)
  return replay_.replay_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestStartReplay::release_replay_data() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.RequestStartReplay.replay_data)
  if (has_replay_data()) {
    clear_has_replay();
    return replay_.replay_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void RequestStartReplay::set_allocated_replay_data(::std::string* replay_data) {
  if (!has_replay_data()) {
    replay_.replay_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_replay();
  if (replay_data != NULL) {
    set_has_replay_data();
    replay_.replay_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), replay_data);
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.RequestStartReplay.replay_data)
}

// optional bytes map_data = 6;
inline bool RequestStartReplay::has_map_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestStartReplay::set_has_map_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestStartReplay::clear_has_map_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestStartReplay::clear_map_data() {
  map_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_map_data();
}
inline const ::std::string& RequestStartReplay::map_data() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestStartReplay.map_data)
  return map_data_.GetNoArena();
}
inline void RequestStartReplay::set_map_data(const ::std::string& value) {
  set_has_map_data();
  map_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestStartReplay.map_data)
}
#if LANG_CXX11
inline void RequestStartReplay::set_map_data(::std::string&& value) {
  set_has_map_data();
  map_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.RequestStartReplay.map_data)
}
#endif
inline void RequestStartReplay::set_map_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_map_data();
  map_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.RequestStartReplay.map_data)
}
inline void RequestStartReplay::set_map_data(const void* value, size_t size) {
  set_has_map_data();
  map_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.RequestStartReplay.map_data)
}
inline ::std::string* RequestStartReplay::mutable_map_data() {
  set_has_map_data();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RequestStartReplay.map_data)
  return map_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestStartReplay::release_map_data() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.RequestStartReplay.map_data)
  if (!has_map_data()) {
    return NULL;
  }
  clear_has_map_data();
  return map_data_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestStartReplay::set_allocated_map_data(::std::string* map_data) {
  if (map_data != NULL) {
    set_has_map_data();
  } else {
    clear_has_map_data();
  }
  map_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map_data);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.RequestStartReplay.map_data)
}

// optional int32 observed_player_id = 2;
inline bool RequestStartReplay::has_observed_player_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestStartReplay::set_has_observed_player_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestStartReplay::clear_has_observed_player_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestStartReplay::clear_observed_player_id() {
  observed_player_id_ = 0;
  clear_has_observed_player_id();
}
inline ::google::protobuf::int32 RequestStartReplay::observed_player_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestStartReplay.observed_player_id)
  return observed_player_id_;
}
inline void RequestStartReplay::set_observed_player_id(::google::protobuf::int32 value) {
  set_has_observed_player_id();
  observed_player_id_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestStartReplay.observed_player_id)
}

// optional .SC2APIProtocol.InterfaceOptions options = 3;
inline bool RequestStartReplay::has_options() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestStartReplay::set_has_options() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestStartReplay::clear_has_options() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestStartReplay::clear_options() {
  if (options_ != NULL) options_->Clear();
  clear_has_options();
}
inline const ::SC2APIProtocol::InterfaceOptions& RequestStartReplay::_internal_options() const {
  return *options_;
}
inline const ::SC2APIProtocol::InterfaceOptions& RequestStartReplay::options() const {
  const ::SC2APIProtocol::InterfaceOptions* p = options_;
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestStartReplay.options)
  return p != NULL ? *p : *reinterpret_cast<const ::SC2APIProtocol::InterfaceOptions*>(
      &::SC2APIProtocol::_InterfaceOptions_default_instance_);
}
inline ::SC2APIProtocol::InterfaceOptions* RequestStartReplay::release_options() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.RequestStartReplay.options)
  clear_has_options();
  ::SC2APIProtocol::InterfaceOptions* temp = options_;
  options_ = NULL;
  return temp;
}
inline ::SC2APIProtocol::InterfaceOptions* RequestStartReplay::mutable_options() {
  set_has_options();
  if (options_ == NULL) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::InterfaceOptions>(GetArenaNoVirtual());
    options_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RequestStartReplay.options)
  return options_;
}
inline void RequestStartReplay::set_allocated_options(::SC2APIProtocol::InterfaceOptions* options) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete options_;
  }
  if (options) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      options = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    set_has_options();
  } else {
    clear_has_options();
  }
  options_ = options;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.RequestStartReplay.options)
}

// optional bool disable_fog = 4;
inline bool RequestStartReplay::has_disable_fog() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestStartReplay::set_has_disable_fog() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestStartReplay::clear_has_disable_fog() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestStartReplay::clear_disable_fog() {
  disable_fog_ = false;
  clear_has_disable_fog();
}
inline bool RequestStartReplay::disable_fog() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestStartReplay.disable_fog)
  return disable_fog_;
}
inline void RequestStartReplay::set_disable_fog(bool value) {
  set_has_disable_fog();
  disable_fog_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestStartReplay.disable_fog)
}

// optional bool realtime = 7;
inline bool RequestStartReplay::has_realtime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestStartReplay::set_has_realtime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestStartReplay::clear_has_realtime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestStartReplay::clear_realtime() {
  realtime_ = false;
  clear_has_realtime();
}
inline bool RequestStartReplay::realtime() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestStartReplay.realtime)
  return realtime_;
}
inline void RequestStartReplay::set_realtime(bool value) {
  set_has_realtime();
  realtime_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestStartReplay.realtime)
}

inline bool RequestStartReplay::has_replay() const {
  return replay_case() != REPLAY_NOT_SET;
}
inline void RequestStartReplay::clear_has_replay() {
  _oneof_case_[0] = REPLAY_NOT_SET;
}
inline RequestStartReplay::ReplayCase RequestStartReplay::replay_case() const {
  return RequestStartReplay::ReplayCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ResponseStartReplay

// optional .SC2APIProtocol.ResponseStartReplay.Error error = 1;
inline bool ResponseStartReplay::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseStartReplay::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseStartReplay::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseStartReplay::clear_error() {
  error_ = 1;
  clear_has_error();
}
inline ::SC2APIProtocol::ResponseStartReplay_Error ResponseStartReplay::error() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseStartReplay.error)
  return static_cast< ::SC2APIProtocol::ResponseStartReplay_Error >(error_);
}
inline void ResponseStartReplay::set_error(::SC2APIProtocol::ResponseStartReplay_Error value) {
  assert(::SC2APIProtocol::ResponseStartReplay_Error_IsValid(value));
  set_has_error();
  error_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseStartReplay.error)
}

// optional string error_details = 2;
inline bool ResponseStartReplay::has_error_details() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseStartReplay::set_has_error_details() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseStartReplay::clear_has_error_details() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseStartReplay::clear_error_details() {
  error_details_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error_details();
}
inline const ::std::string& ResponseStartReplay::error_details() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseStartReplay.error_details)
  return error_details_.GetNoArena();
}
inline void ResponseStartReplay::set_error_details(const ::std::string& value) {
  set_has_error_details();
  error_details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseStartReplay.error_details)
}
#if LANG_CXX11
inline void ResponseStartReplay::set_error_details(::std::string&& value) {
  set_has_error_details();
  error_details_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.ResponseStartReplay.error_details)
}
#endif
inline void ResponseStartReplay::set_error_details(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_error_details();
  error_details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ResponseStartReplay.error_details)
}
inline void ResponseStartReplay::set_error_details(const char* value, size_t size) {
  set_has_error_details();
  error_details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ResponseStartReplay.error_details)
}
inline ::std::string* ResponseStartReplay::mutable_error_details() {
  set_has_error_details();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseStartReplay.error_details)
  return error_details_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseStartReplay::release_error_details() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ResponseStartReplay.error_details)
  if (!has_error_details()) {
    return NULL;
  }
  clear_has_error_details();
  return error_details_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseStartReplay::set_allocated_error_details(::std::string* error_details) {
  if (error_details != NULL) {
    set_has_error_details();
  } else {
    clear_has_error_details();
  }
  error_details_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_details);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ResponseStartReplay.error_details)
}

// -------------------------------------------------------------------

// RequestLeaveGame

// -------------------------------------------------------------------

// ResponseLeaveGame

// -------------------------------------------------------------------

// RequestQuickSave

// -------------------------------------------------------------------

// ResponseQuickSave

// -------------------------------------------------------------------

// RequestQuickLoad

// -------------------------------------------------------------------

// ResponseQuickLoad

// -------------------------------------------------------------------

// RequestQuit

// -------------------------------------------------------------------

// ResponseQuit

// -------------------------------------------------------------------

// RequestGameInfo

// -------------------------------------------------------------------

// ResponseGameInfo

// optional string map_name = 1;
inline bool ResponseGameInfo::has_map_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseGameInfo::set_has_map_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseGameInfo::clear_has_map_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseGameInfo::clear_map_name() {
  map_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_map_name();
}
inline const ::std::string& ResponseGameInfo::map_name() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseGameInfo.map_name)
  return map_name_.GetNoArena();
}
inline void ResponseGameInfo::set_map_name(const ::std::string& value) {
  set_has_map_name();
  map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseGameInfo.map_name)
}
#if LANG_CXX11
inline void ResponseGameInfo::set_map_name(::std::string&& value) {
  set_has_map_name();
  map_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.ResponseGameInfo.map_name)
}
#endif
inline void ResponseGameInfo::set_map_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_map_name();
  map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ResponseGameInfo.map_name)
}
inline void ResponseGameInfo::set_map_name(const char* value, size_t size) {
  set_has_map_name();
  map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ResponseGameInfo.map_name)
}
inline ::std::string* ResponseGameInfo::mutable_map_name() {
  set_has_map_name();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseGameInfo.map_name)
  return map_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseGameInfo::release_map_name() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ResponseGameInfo.map_name)
  if (!has_map_name()) {
    return NULL;
  }
  clear_has_map_name();
  return map_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseGameInfo::set_allocated_map_name(::std::string* map_name) {
  if (map_name != NULL) {
    set_has_map_name();
  } else {
    clear_has_map_name();
  }
  map_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map_name);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ResponseGameInfo.map_name)
}

// repeated string mod_names = 6;
inline int ResponseGameInfo::mod_names_size() const {
  return mod_names_.size();
}
inline void ResponseGameInfo::clear_mod_names() {
  mod_names_.Clear();
}
inline const ::std::string& ResponseGameInfo::mod_names(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseGameInfo.mod_names)
  return mod_names_.Get(index);
}
inline ::std::string* ResponseGameInfo::mutable_mod_names(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseGameInfo.mod_names)
  return mod_names_.Mutable(index);
}
inline void ResponseGameInfo::set_mod_names(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseGameInfo.mod_names)
  mod_names_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ResponseGameInfo::set_mod_names(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseGameInfo.mod_names)
  mod_names_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ResponseGameInfo::set_mod_names(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  mod_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ResponseGameInfo.mod_names)
}
inline void ResponseGameInfo::set_mod_names(int index, const char* value, size_t size) {
  mod_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ResponseGameInfo.mod_names)
}
inline ::std::string* ResponseGameInfo::add_mod_names() {
  // @@protoc_insertion_point(field_add_mutable:SC2APIProtocol.ResponseGameInfo.mod_names)
  return mod_names_.Add();
}
inline void ResponseGameInfo::add_mod_names(const ::std::string& value) {
  mod_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ResponseGameInfo.mod_names)
}
#if LANG_CXX11
inline void ResponseGameInfo::add_mod_names(::std::string&& value) {
  mod_names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ResponseGameInfo.mod_names)
}
#endif
inline void ResponseGameInfo::add_mod_names(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  mod_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SC2APIProtocol.ResponseGameInfo.mod_names)
}
inline void ResponseGameInfo::add_mod_names(const char* value, size_t size) {
  mod_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SC2APIProtocol.ResponseGameInfo.mod_names)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ResponseGameInfo::mod_names() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ResponseGameInfo.mod_names)
  return mod_names_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ResponseGameInfo::mutable_mod_names() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ResponseGameInfo.mod_names)
  return &mod_names_;
}

// optional string local_map_path = 2;
inline bool ResponseGameInfo::has_local_map_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseGameInfo::set_has_local_map_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseGameInfo::clear_has_local_map_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseGameInfo::clear_local_map_path() {
  local_map_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_local_map_path();
}
inline const ::std::string& ResponseGameInfo::local_map_path() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseGameInfo.local_map_path)
  return local_map_path_.GetNoArena();
}
inline void ResponseGameInfo::set_local_map_path(const ::std::string& value) {
  set_has_local_map_path();
  local_map_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseGameInfo.local_map_path)
}
#if LANG_CXX11
inline void ResponseGameInfo::set_local_map_path(::std::string&& value) {
  set_has_local_map_path();
  local_map_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.ResponseGameInfo.local_map_path)
}
#endif
inline void ResponseGameInfo::set_local_map_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_local_map_path();
  local_map_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ResponseGameInfo.local_map_path)
}
inline void ResponseGameInfo::set_local_map_path(const char* value, size_t size) {
  set_has_local_map_path();
  local_map_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ResponseGameInfo.local_map_path)
}
inline ::std::string* ResponseGameInfo::mutable_local_map_path() {
  set_has_local_map_path();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseGameInfo.local_map_path)
  return local_map_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseGameInfo::release_local_map_path() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ResponseGameInfo.local_map_path)
  if (!has_local_map_path()) {
    return NULL;
  }
  clear_has_local_map_path();
  return local_map_path_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseGameInfo::set_allocated_local_map_path(::std::string* local_map_path) {
  if (local_map_path != NULL) {
    set_has_local_map_path();
  } else {
    clear_has_local_map_path();
  }
  local_map_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), local_map_path);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ResponseGameInfo.local_map_path)
}

// repeated .SC2APIProtocol.PlayerInfo player_info = 3;
inline int ResponseGameInfo::player_info_size() const {
  return player_info_.size();
}
inline void ResponseGameInfo::clear_player_info() {
  player_info_.Clear();
}
inline ::SC2APIProtocol::PlayerInfo* ResponseGameInfo::mutable_player_info(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseGameInfo.player_info)
  return player_info_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PlayerInfo >*
ResponseGameInfo::mutable_player_info() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ResponseGameInfo.player_info)
  return &player_info_;
}
inline const ::SC2APIProtocol::PlayerInfo& ResponseGameInfo::player_info(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseGameInfo.player_info)
  return player_info_.Get(index);
}
inline ::SC2APIProtocol::PlayerInfo* ResponseGameInfo::add_player_info() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ResponseGameInfo.player_info)
  return player_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PlayerInfo >&
ResponseGameInfo::player_info() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ResponseGameInfo.player_info)
  return player_info_;
}

// optional .SC2APIProtocol.StartRaw start_raw = 4;
inline bool ResponseGameInfo::has_start_raw() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseGameInfo::set_has_start_raw() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseGameInfo::clear_has_start_raw() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::SC2APIProtocol::StartRaw& ResponseGameInfo::_internal_start_raw() const {
  return *start_raw_;
}
inline const ::SC2APIProtocol::StartRaw& ResponseGameInfo::start_raw() const {
  const ::SC2APIProtocol::StartRaw* p = start_raw_;
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseGameInfo.start_raw)
  return p != NULL ? *p : *reinterpret_cast<const ::SC2APIProtocol::StartRaw*>(
      &::SC2APIProtocol::_StartRaw_default_instance_);
}
inline ::SC2APIProtocol::StartRaw* ResponseGameInfo::release_start_raw() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ResponseGameInfo.start_raw)
  clear_has_start_raw();
  ::SC2APIProtocol::StartRaw* temp = start_raw_;
  start_raw_ = NULL;
  return temp;
}
inline ::SC2APIProtocol::StartRaw* ResponseGameInfo::mutable_start_raw() {
  set_has_start_raw();
  if (start_raw_ == NULL) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::StartRaw>(GetArenaNoVirtual());
    start_raw_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseGameInfo.start_raw)
  return start_raw_;
}
inline void ResponseGameInfo::set_allocated_start_raw(::SC2APIProtocol::StartRaw* start_raw) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(start_raw_);
  }
  if (start_raw) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      start_raw = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, start_raw, submessage_arena);
    }
    set_has_start_raw();
  } else {
    clear_has_start_raw();
  }
  start_raw_ = start_raw;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ResponseGameInfo.start_raw)
}

// optional .SC2APIProtocol.InterfaceOptions options = 5;
inline bool ResponseGameInfo::has_options() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResponseGameInfo::set_has_options() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResponseGameInfo::clear_has_options() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResponseGameInfo::clear_options() {
  if (options_ != NULL) options_->Clear();
  clear_has_options();
}
inline const ::SC2APIProtocol::InterfaceOptions& ResponseGameInfo::_internal_options() const {
  return *options_;
}
inline const ::SC2APIProtocol::InterfaceOptions& ResponseGameInfo::options() const {
  const ::SC2APIProtocol::InterfaceOptions* p = options_;
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseGameInfo.options)
  return p != NULL ? *p : *reinterpret_cast<const ::SC2APIProtocol::InterfaceOptions*>(
      &::SC2APIProtocol::_InterfaceOptions_default_instance_);
}
inline ::SC2APIProtocol::InterfaceOptions* ResponseGameInfo::release_options() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ResponseGameInfo.options)
  clear_has_options();
  ::SC2APIProtocol::InterfaceOptions* temp = options_;
  options_ = NULL;
  return temp;
}
inline ::SC2APIProtocol::InterfaceOptions* ResponseGameInfo::mutable_options() {
  set_has_options();
  if (options_ == NULL) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::InterfaceOptions>(GetArenaNoVirtual());
    options_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseGameInfo.options)
  return options_;
}
inline void ResponseGameInfo::set_allocated_options(::SC2APIProtocol::InterfaceOptions* options) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete options_;
  }
  if (options) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      options = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    set_has_options();
  } else {
    clear_has_options();
  }
  options_ = options;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ResponseGameInfo.options)
}

// -------------------------------------------------------------------

// RequestObservation

// optional bool disable_fog = 1;
inline bool RequestObservation::has_disable_fog() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestObservation::set_has_disable_fog() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestObservation::clear_has_disable_fog() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestObservation::clear_disable_fog() {
  disable_fog_ = false;
  clear_has_disable_fog();
}
inline bool RequestObservation::disable_fog() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestObservation.disable_fog)
  return disable_fog_;
}
inline void RequestObservation::set_disable_fog(bool value) {
  set_has_disable_fog();
  disable_fog_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestObservation.disable_fog)
}

// -------------------------------------------------------------------

// ResponseObservation

// repeated .SC2APIProtocol.Action actions = 1;
inline int ResponseObservation::actions_size() const {
  return actions_.size();
}
inline void ResponseObservation::clear_actions() {
  actions_.Clear();
}
inline ::SC2APIProtocol::Action* ResponseObservation::mutable_actions(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseObservation.actions)
  return actions_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::Action >*
ResponseObservation::mutable_actions() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ResponseObservation.actions)
  return &actions_;
}
inline const ::SC2APIProtocol::Action& ResponseObservation::actions(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseObservation.actions)
  return actions_.Get(index);
}
inline ::SC2APIProtocol::Action* ResponseObservation::add_actions() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ResponseObservation.actions)
  return actions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::Action >&
ResponseObservation::actions() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ResponseObservation.actions)
  return actions_;
}

// repeated .SC2APIProtocol.ActionError action_errors = 2;
inline int ResponseObservation::action_errors_size() const {
  return action_errors_.size();
}
inline void ResponseObservation::clear_action_errors() {
  action_errors_.Clear();
}
inline ::SC2APIProtocol::ActionError* ResponseObservation::mutable_action_errors(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseObservation.action_errors)
  return action_errors_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::ActionError >*
ResponseObservation::mutable_action_errors() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ResponseObservation.action_errors)
  return &action_errors_;
}
inline const ::SC2APIProtocol::ActionError& ResponseObservation::action_errors(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseObservation.action_errors)
  return action_errors_.Get(index);
}
inline ::SC2APIProtocol::ActionError* ResponseObservation::add_action_errors() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ResponseObservation.action_errors)
  return action_errors_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::ActionError >&
ResponseObservation::action_errors() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ResponseObservation.action_errors)
  return action_errors_;
}

// optional .SC2APIProtocol.Observation observation = 3;
inline bool ResponseObservation::has_observation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseObservation::set_has_observation() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseObservation::clear_has_observation() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseObservation::clear_observation() {
  if (observation_ != NULL) observation_->Clear();
  clear_has_observation();
}
inline const ::SC2APIProtocol::Observation& ResponseObservation::_internal_observation() const {
  return *observation_;
}
inline const ::SC2APIProtocol::Observation& ResponseObservation::observation() const {
  const ::SC2APIProtocol::Observation* p = observation_;
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseObservation.observation)
  return p != NULL ? *p : *reinterpret_cast<const ::SC2APIProtocol::Observation*>(
      &::SC2APIProtocol::_Observation_default_instance_);
}
inline ::SC2APIProtocol::Observation* ResponseObservation::release_observation() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ResponseObservation.observation)
  clear_has_observation();
  ::SC2APIProtocol::Observation* temp = observation_;
  observation_ = NULL;
  return temp;
}
inline ::SC2APIProtocol::Observation* ResponseObservation::mutable_observation() {
  set_has_observation();
  if (observation_ == NULL) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::Observation>(GetArenaNoVirtual());
    observation_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseObservation.observation)
  return observation_;
}
inline void ResponseObservation::set_allocated_observation(::SC2APIProtocol::Observation* observation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete observation_;
  }
  if (observation) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      observation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, observation, submessage_arena);
    }
    set_has_observation();
  } else {
    clear_has_observation();
  }
  observation_ = observation;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ResponseObservation.observation)
}

// repeated .SC2APIProtocol.PlayerResult player_result = 4;
inline int ResponseObservation::player_result_size() const {
  return player_result_.size();
}
inline void ResponseObservation::clear_player_result() {
  player_result_.Clear();
}
inline ::SC2APIProtocol::PlayerResult* ResponseObservation::mutable_player_result(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseObservation.player_result)
  return player_result_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PlayerResult >*
ResponseObservation::mutable_player_result() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ResponseObservation.player_result)
  return &player_result_;
}
inline const ::SC2APIProtocol::PlayerResult& ResponseObservation::player_result(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseObservation.player_result)
  return player_result_.Get(index);
}
inline ::SC2APIProtocol::PlayerResult* ResponseObservation::add_player_result() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ResponseObservation.player_result)
  return player_result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PlayerResult >&
ResponseObservation::player_result() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ResponseObservation.player_result)
  return player_result_;
}

// repeated .SC2APIProtocol.ChatReceived chat = 5;
inline int ResponseObservation::chat_size() const {
  return chat_.size();
}
inline void ResponseObservation::clear_chat() {
  chat_.Clear();
}
inline ::SC2APIProtocol::ChatReceived* ResponseObservation::mutable_chat(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseObservation.chat)
  return chat_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::ChatReceived >*
ResponseObservation::mutable_chat() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ResponseObservation.chat)
  return &chat_;
}
inline const ::SC2APIProtocol::ChatReceived& ResponseObservation::chat(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseObservation.chat)
  return chat_.Get(index);
}
inline ::SC2APIProtocol::ChatReceived* ResponseObservation::add_chat() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ResponseObservation.chat)
  return chat_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::ChatReceived >&
ResponseObservation::chat() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ResponseObservation.chat)
  return chat_;
}

// -------------------------------------------------------------------

// ChatReceived

// optional uint32 player_id = 1;
inline bool ChatReceived::has_player_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChatReceived::set_has_player_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChatReceived::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChatReceived::clear_player_id() {
  player_id_ = 0u;
  clear_has_player_id();
}
inline ::google::protobuf::uint32 ChatReceived::player_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ChatReceived.player_id)
  return player_id_;
}
inline void ChatReceived::set_player_id(::google::protobuf::uint32 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ChatReceived.player_id)
}

// optional string message = 2;
inline bool ChatReceived::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChatReceived::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChatReceived::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChatReceived::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& ChatReceived::message() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ChatReceived.message)
  return message_.GetNoArena();
}
inline void ChatReceived::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ChatReceived.message)
}
#if LANG_CXX11
inline void ChatReceived::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.ChatReceived.message)
}
#endif
inline void ChatReceived::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ChatReceived.message)
}
inline void ChatReceived::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ChatReceived.message)
}
inline ::std::string* ChatReceived::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ChatReceived.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChatReceived::release_message() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ChatReceived.message)
  if (!has_message()) {
    return NULL;
  }
  clear_has_message();
  return message_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChatReceived::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ChatReceived.message)
}

// -------------------------------------------------------------------

// RequestAction

// repeated .SC2APIProtocol.Action actions = 1;
inline int RequestAction::actions_size() const {
  return actions_.size();
}
inline void RequestAction::clear_actions() {
  actions_.Clear();
}
inline ::SC2APIProtocol::Action* RequestAction::mutable_actions(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RequestAction.actions)
  return actions_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::Action >*
RequestAction::mutable_actions() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.RequestAction.actions)
  return &actions_;
}
inline const ::SC2APIProtocol::Action& RequestAction::actions(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestAction.actions)
  return actions_.Get(index);
}
inline ::SC2APIProtocol::Action* RequestAction::add_actions() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.RequestAction.actions)
  return actions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::Action >&
RequestAction::actions() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.RequestAction.actions)
  return actions_;
}

// -------------------------------------------------------------------

// ResponseAction

// repeated .SC2APIProtocol.ActionResult result = 1;
inline int ResponseAction::result_size() const {
  return result_.size();
}
inline void ResponseAction::clear_result() {
  result_.Clear();
}
inline ::SC2APIProtocol::ActionResult ResponseAction::result(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseAction.result)
  return static_cast< ::SC2APIProtocol::ActionResult >(result_.Get(index));
}
inline void ResponseAction::set_result(int index, ::SC2APIProtocol::ActionResult value) {
  assert(::SC2APIProtocol::ActionResult_IsValid(value));
  result_.Set(index, value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseAction.result)
}
inline void ResponseAction::add_result(::SC2APIProtocol::ActionResult value) {
  assert(::SC2APIProtocol::ActionResult_IsValid(value));
  result_.Add(value);
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ResponseAction.result)
}
inline const ::google::protobuf::RepeatedField<int>&
ResponseAction::result() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ResponseAction.result)
  return result_;
}
inline ::google::protobuf::RepeatedField<int>*
ResponseAction::mutable_result() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ResponseAction.result)
  return &result_;
}

// -------------------------------------------------------------------

// RequestObserverAction

// repeated .SC2APIProtocol.ObserverAction actions = 1;
inline int RequestObserverAction::actions_size() const {
  return actions_.size();
}
inline void RequestObserverAction::clear_actions() {
  actions_.Clear();
}
inline ::SC2APIProtocol::ObserverAction* RequestObserverAction::mutable_actions(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RequestObserverAction.actions)
  return actions_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::ObserverAction >*
RequestObserverAction::mutable_actions() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.RequestObserverAction.actions)
  return &actions_;
}
inline const ::SC2APIProtocol::ObserverAction& RequestObserverAction::actions(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestObserverAction.actions)
  return actions_.Get(index);
}
inline ::SC2APIProtocol::ObserverAction* RequestObserverAction::add_actions() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.RequestObserverAction.actions)
  return actions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::ObserverAction >&
RequestObserverAction::actions() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.RequestObserverAction.actions)
  return actions_;
}

// -------------------------------------------------------------------

// ResponseObserverAction

// -------------------------------------------------------------------

// RequestStep

// optional uint32 count = 1;
inline bool RequestStep::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestStep::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestStep::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestStep::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 RequestStep::count() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestStep.count)
  return count_;
}
inline void RequestStep::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestStep.count)
}

// -------------------------------------------------------------------

// ResponseStep

// -------------------------------------------------------------------

// RequestData

// optional bool ability_id = 1;
inline bool RequestData::has_ability_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestData::set_has_ability_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestData::clear_has_ability_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestData::clear_ability_id() {
  ability_id_ = false;
  clear_has_ability_id();
}
inline bool RequestData::ability_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestData.ability_id)
  return ability_id_;
}
inline void RequestData::set_ability_id(bool value) {
  set_has_ability_id();
  ability_id_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestData.ability_id)
}

// optional bool unit_type_id = 2;
inline bool RequestData::has_unit_type_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestData::set_has_unit_type_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestData::clear_has_unit_type_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestData::clear_unit_type_id() {
  unit_type_id_ = false;
  clear_has_unit_type_id();
}
inline bool RequestData::unit_type_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestData.unit_type_id)
  return unit_type_id_;
}
inline void RequestData::set_unit_type_id(bool value) {
  set_has_unit_type_id();
  unit_type_id_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestData.unit_type_id)
}

// optional bool upgrade_id = 3;
inline bool RequestData::has_upgrade_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestData::set_has_upgrade_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestData::clear_has_upgrade_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestData::clear_upgrade_id() {
  upgrade_id_ = false;
  clear_has_upgrade_id();
}
inline bool RequestData::upgrade_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestData.upgrade_id)
  return upgrade_id_;
}
inline void RequestData::set_upgrade_id(bool value) {
  set_has_upgrade_id();
  upgrade_id_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestData.upgrade_id)
}

// optional bool buff_id = 4;
inline bool RequestData::has_buff_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestData::set_has_buff_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestData::clear_has_buff_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestData::clear_buff_id() {
  buff_id_ = false;
  clear_has_buff_id();
}
inline bool RequestData::buff_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestData.buff_id)
  return buff_id_;
}
inline void RequestData::set_buff_id(bool value) {
  set_has_buff_id();
  buff_id_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestData.buff_id)
}

// optional bool effect_id = 5;
inline bool RequestData::has_effect_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestData::set_has_effect_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestData::clear_has_effect_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestData::clear_effect_id() {
  effect_id_ = false;
  clear_has_effect_id();
}
inline bool RequestData::effect_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestData.effect_id)
  return effect_id_;
}
inline void RequestData::set_effect_id(bool value) {
  set_has_effect_id();
  effect_id_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestData.effect_id)
}

// -------------------------------------------------------------------

// ResponseData

// repeated .SC2APIProtocol.AbilityData abilities = 1;
inline int ResponseData::abilities_size() const {
  return abilities_.size();
}
inline ::SC2APIProtocol::AbilityData* ResponseData::mutable_abilities(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseData.abilities)
  return abilities_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::AbilityData >*
ResponseData::mutable_abilities() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ResponseData.abilities)
  return &abilities_;
}
inline const ::SC2APIProtocol::AbilityData& ResponseData::abilities(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseData.abilities)
  return abilities_.Get(index);
}
inline ::SC2APIProtocol::AbilityData* ResponseData::add_abilities() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ResponseData.abilities)
  return abilities_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::AbilityData >&
ResponseData::abilities() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ResponseData.abilities)
  return abilities_;
}

// repeated .SC2APIProtocol.UnitTypeData units = 2;
inline int ResponseData::units_size() const {
  return units_.size();
}
inline ::SC2APIProtocol::UnitTypeData* ResponseData::mutable_units(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseData.units)
  return units_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::UnitTypeData >*
ResponseData::mutable_units() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ResponseData.units)
  return &units_;
}
inline const ::SC2APIProtocol::UnitTypeData& ResponseData::units(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseData.units)
  return units_.Get(index);
}
inline ::SC2APIProtocol::UnitTypeData* ResponseData::add_units() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ResponseData.units)
  return units_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::UnitTypeData >&
ResponseData::units() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ResponseData.units)
  return units_;
}

// repeated .SC2APIProtocol.UpgradeData upgrades = 3;
inline int ResponseData::upgrades_size() const {
  return upgrades_.size();
}
inline ::SC2APIProtocol::UpgradeData* ResponseData::mutable_upgrades(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseData.upgrades)
  return upgrades_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::UpgradeData >*
ResponseData::mutable_upgrades() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ResponseData.upgrades)
  return &upgrades_;
}
inline const ::SC2APIProtocol::UpgradeData& ResponseData::upgrades(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseData.upgrades)
  return upgrades_.Get(index);
}
inline ::SC2APIProtocol::UpgradeData* ResponseData::add_upgrades() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ResponseData.upgrades)
  return upgrades_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::UpgradeData >&
ResponseData::upgrades() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ResponseData.upgrades)
  return upgrades_;
}

// repeated .SC2APIProtocol.BuffData buffs = 4;
inline int ResponseData::buffs_size() const {
  return buffs_.size();
}
inline ::SC2APIProtocol::BuffData* ResponseData::mutable_buffs(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseData.buffs)
  return buffs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::BuffData >*
ResponseData::mutable_buffs() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ResponseData.buffs)
  return &buffs_;
}
inline const ::SC2APIProtocol::BuffData& ResponseData::buffs(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseData.buffs)
  return buffs_.Get(index);
}
inline ::SC2APIProtocol::BuffData* ResponseData::add_buffs() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ResponseData.buffs)
  return buffs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::BuffData >&
ResponseData::buffs() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ResponseData.buffs)
  return buffs_;
}

// repeated .SC2APIProtocol.EffectData effects = 5;
inline int ResponseData::effects_size() const {
  return effects_.size();
}
inline ::SC2APIProtocol::EffectData* ResponseData::mutable_effects(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseData.effects)
  return effects_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::EffectData >*
ResponseData::mutable_effects() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ResponseData.effects)
  return &effects_;
}
inline const ::SC2APIProtocol::EffectData& ResponseData::effects(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseData.effects)
  return effects_.Get(index);
}
inline ::SC2APIProtocol::EffectData* ResponseData::add_effects() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ResponseData.effects)
  return effects_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::EffectData >&
ResponseData::effects() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ResponseData.effects)
  return effects_;
}

// -------------------------------------------------------------------

// RequestSaveReplay

// -------------------------------------------------------------------

// ResponseSaveReplay

// optional bytes data = 1;
inline bool ResponseSaveReplay::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseSaveReplay::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseSaveReplay::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseSaveReplay::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
inline const ::std::string& ResponseSaveReplay::data() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseSaveReplay.data)
  return data_.GetNoArena();
}
inline void ResponseSaveReplay::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseSaveReplay.data)
}
#if LANG_CXX11
inline void ResponseSaveReplay::set_data(::std::string&& value) {
  set_has_data();
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.ResponseSaveReplay.data)
}
#endif
inline void ResponseSaveReplay::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ResponseSaveReplay.data)
}
inline void ResponseSaveReplay::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ResponseSaveReplay.data)
}
inline ::std::string* ResponseSaveReplay::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseSaveReplay.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseSaveReplay::release_data() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ResponseSaveReplay.data)
  if (!has_data()) {
    return NULL;
  }
  clear_has_data();
  return data_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseSaveReplay::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ResponseSaveReplay.data)
}

// -------------------------------------------------------------------

// RequestReplayInfo

// optional string replay_path = 1;
inline bool RequestReplayInfo::has_replay_path() const {
  return replay_case() == kReplayPath;
}
inline void RequestReplayInfo::set_has_replay_path() {
  _oneof_case_[0] = kReplayPath;
}
inline void RequestReplayInfo::clear_replay_path() {
  if (has_replay_path()) {
    replay_.replay_path_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_replay();
  }
}
inline const ::std::string& RequestReplayInfo::replay_path() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestReplayInfo.replay_path)
  if (has_replay_path()) {
    return replay_.replay_path_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void RequestReplayInfo::set_replay_path(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestReplayInfo.replay_path)
  if (!has_replay_path()) {
    clear_replay();
    set_has_replay_path();
    replay_.replay_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestReplayInfo.replay_path)
}
#if LANG_CXX11
inline void RequestReplayInfo::set_replay_path(::std::string&& value) {
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestReplayInfo.replay_path)
  if (!has_replay_path()) {
    clear_replay();
    set_has_replay_path();
    replay_.replay_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.RequestReplayInfo.replay_path)
}
#endif
inline void RequestReplayInfo::set_replay_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_replay_path()) {
    clear_replay();
    set_has_replay_path();
    replay_.replay_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.RequestReplayInfo.replay_path)
}
inline void RequestReplayInfo::set_replay_path(const char* value, size_t size) {
  if (!has_replay_path()) {
    clear_replay();
    set_has_replay_path();
    replay_.replay_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.RequestReplayInfo.replay_path)
}
inline ::std::string* RequestReplayInfo::mutable_replay_path() {
  if (!has_replay_path()) {
    clear_replay();
    set_has_replay_path();
    replay_.replay_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RequestReplayInfo.replay_path)
  return replay_.replay_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestReplayInfo::release_replay_path() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.RequestReplayInfo.replay_path)
  if (has_replay_path()) {
    clear_has_replay();
    return replay_.replay_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void RequestReplayInfo::set_allocated_replay_path(::std::string* replay_path) {
  if (!has_replay_path()) {
    replay_.replay_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_replay();
  if (replay_path != NULL) {
    set_has_replay_path();
    replay_.replay_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), replay_path);
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.RequestReplayInfo.replay_path)
}

// optional bytes replay_data = 2;
inline bool RequestReplayInfo::has_replay_data() const {
  return replay_case() == kReplayData;
}
inline void RequestReplayInfo::set_has_replay_data() {
  _oneof_case_[0] = kReplayData;
}
inline void RequestReplayInfo::clear_replay_data() {
  if (has_replay_data()) {
    replay_.replay_data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_replay();
  }
}
inline const ::std::string& RequestReplayInfo::replay_data() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestReplayInfo.replay_data)
  if (has_replay_data()) {
    return replay_.replay_data_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void RequestReplayInfo::set_replay_data(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestReplayInfo.replay_data)
  if (!has_replay_data()) {
    clear_replay();
    set_has_replay_data();
    replay_.replay_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestReplayInfo.replay_data)
}
#if LANG_CXX11
inline void RequestReplayInfo::set_replay_data(::std::string&& value) {
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestReplayInfo.replay_data)
  if (!has_replay_data()) {
    clear_replay();
    set_has_replay_data();
    replay_.replay_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.RequestReplayInfo.replay_data)
}
#endif
inline void RequestReplayInfo::set_replay_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_replay_data()) {
    clear_replay();
    set_has_replay_data();
    replay_.replay_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.RequestReplayInfo.replay_data)
}
inline void RequestReplayInfo::set_replay_data(const void* value, size_t size) {
  if (!has_replay_data()) {
    clear_replay();
    set_has_replay_data();
    replay_.replay_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  replay_.replay_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.RequestReplayInfo.replay_data)
}
inline ::std::string* RequestReplayInfo::mutable_replay_data() {
  if (!has_replay_data()) {
    clear_replay();
    set_has_replay_data();
    replay_.replay_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RequestReplayInfo.replay_data)
  return replay_.replay_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestReplayInfo::release_replay_data() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.RequestReplayInfo.replay_data)
  if (has_replay_data()) {
    clear_has_replay();
    return replay_.replay_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void RequestReplayInfo::set_allocated_replay_data(::std::string* replay_data) {
  if (!has_replay_data()) {
    replay_.replay_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_replay();
  if (replay_data != NULL) {
    set_has_replay_data();
    replay_.replay_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), replay_data);
  }
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.RequestReplayInfo.replay_data)
}

// optional bool download_data = 3;
inline bool RequestReplayInfo::has_download_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestReplayInfo::set_has_download_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestReplayInfo::clear_has_download_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestReplayInfo::clear_download_data() {
  download_data_ = false;
  clear_has_download_data();
}
inline bool RequestReplayInfo::download_data() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestReplayInfo.download_data)
  return download_data_;
}
inline void RequestReplayInfo::set_download_data(bool value) {
  set_has_download_data();
  download_data_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestReplayInfo.download_data)
}

inline bool RequestReplayInfo::has_replay() const {
  return replay_case() != REPLAY_NOT_SET;
}
inline void RequestReplayInfo::clear_has_replay() {
  _oneof_case_[0] = REPLAY_NOT_SET;
}
inline RequestReplayInfo::ReplayCase RequestReplayInfo::replay_case() const {
  return RequestReplayInfo::ReplayCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// PlayerInfoExtra

// optional .SC2APIProtocol.PlayerInfo player_info = 1;
inline bool PlayerInfoExtra::has_player_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerInfoExtra::set_has_player_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerInfoExtra::clear_has_player_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerInfoExtra::clear_player_info() {
  if (player_info_ != NULL) player_info_->Clear();
  clear_has_player_info();
}
inline const ::SC2APIProtocol::PlayerInfo& PlayerInfoExtra::_internal_player_info() const {
  return *player_info_;
}
inline const ::SC2APIProtocol::PlayerInfo& PlayerInfoExtra::player_info() const {
  const ::SC2APIProtocol::PlayerInfo* p = player_info_;
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerInfoExtra.player_info)
  return p != NULL ? *p : *reinterpret_cast<const ::SC2APIProtocol::PlayerInfo*>(
      &::SC2APIProtocol::_PlayerInfo_default_instance_);
}
inline ::SC2APIProtocol::PlayerInfo* PlayerInfoExtra::release_player_info() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.PlayerInfoExtra.player_info)
  clear_has_player_info();
  ::SC2APIProtocol::PlayerInfo* temp = player_info_;
  player_info_ = NULL;
  return temp;
}
inline ::SC2APIProtocol::PlayerInfo* PlayerInfoExtra::mutable_player_info() {
  set_has_player_info();
  if (player_info_ == NULL) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::PlayerInfo>(GetArenaNoVirtual());
    player_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.PlayerInfoExtra.player_info)
  return player_info_;
}
inline void PlayerInfoExtra::set_allocated_player_info(::SC2APIProtocol::PlayerInfo* player_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete player_info_;
  }
  if (player_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      player_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, player_info, submessage_arena);
    }
    set_has_player_info();
  } else {
    clear_has_player_info();
  }
  player_info_ = player_info;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.PlayerInfoExtra.player_info)
}

// optional .SC2APIProtocol.PlayerResult player_result = 2;
inline bool PlayerInfoExtra::has_player_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerInfoExtra::set_has_player_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerInfoExtra::clear_has_player_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerInfoExtra::clear_player_result() {
  if (player_result_ != NULL) player_result_->Clear();
  clear_has_player_result();
}
inline const ::SC2APIProtocol::PlayerResult& PlayerInfoExtra::_internal_player_result() const {
  return *player_result_;
}
inline const ::SC2APIProtocol::PlayerResult& PlayerInfoExtra::player_result() const {
  const ::SC2APIProtocol::PlayerResult* p = player_result_;
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerInfoExtra.player_result)
  return p != NULL ? *p : *reinterpret_cast<const ::SC2APIProtocol::PlayerResult*>(
      &::SC2APIProtocol::_PlayerResult_default_instance_);
}
inline ::SC2APIProtocol::PlayerResult* PlayerInfoExtra::release_player_result() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.PlayerInfoExtra.player_result)
  clear_has_player_result();
  ::SC2APIProtocol::PlayerResult* temp = player_result_;
  player_result_ = NULL;
  return temp;
}
inline ::SC2APIProtocol::PlayerResult* PlayerInfoExtra::mutable_player_result() {
  set_has_player_result();
  if (player_result_ == NULL) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::PlayerResult>(GetArenaNoVirtual());
    player_result_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.PlayerInfoExtra.player_result)
  return player_result_;
}
inline void PlayerInfoExtra::set_allocated_player_result(::SC2APIProtocol::PlayerResult* player_result) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete player_result_;
  }
  if (player_result) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      player_result = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, player_result, submessage_arena);
    }
    set_has_player_result();
  } else {
    clear_has_player_result();
  }
  player_result_ = player_result;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.PlayerInfoExtra.player_result)
}

// optional int32 player_mmr = 3;
inline bool PlayerInfoExtra::has_player_mmr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerInfoExtra::set_has_player_mmr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerInfoExtra::clear_has_player_mmr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerInfoExtra::clear_player_mmr() {
  player_mmr_ = 0;
  clear_has_player_mmr();
}
inline ::google::protobuf::int32 PlayerInfoExtra::player_mmr() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerInfoExtra.player_mmr)
  return player_mmr_;
}
inline void PlayerInfoExtra::set_player_mmr(::google::protobuf::int32 value) {
  set_has_player_mmr();
  player_mmr_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerInfoExtra.player_mmr)
}

// optional int32 player_apm = 4;
inline bool PlayerInfoExtra::has_player_apm() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerInfoExtra::set_has_player_apm() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerInfoExtra::clear_has_player_apm() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerInfoExtra::clear_player_apm() {
  player_apm_ = 0;
  clear_has_player_apm();
}
inline ::google::protobuf::int32 PlayerInfoExtra::player_apm() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerInfoExtra.player_apm)
  return player_apm_;
}
inline void PlayerInfoExtra::set_player_apm(::google::protobuf::int32 value) {
  set_has_player_apm();
  player_apm_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerInfoExtra.player_apm)
}

// -------------------------------------------------------------------

// ResponseReplayInfo

// optional string map_name = 1;
inline bool ResponseReplayInfo::has_map_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseReplayInfo::set_has_map_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseReplayInfo::clear_has_map_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseReplayInfo::clear_map_name() {
  map_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_map_name();
}
inline const ::std::string& ResponseReplayInfo::map_name() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseReplayInfo.map_name)
  return map_name_.GetNoArena();
}
inline void ResponseReplayInfo::set_map_name(const ::std::string& value) {
  set_has_map_name();
  map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseReplayInfo.map_name)
}
#if LANG_CXX11
inline void ResponseReplayInfo::set_map_name(::std::string&& value) {
  set_has_map_name();
  map_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.ResponseReplayInfo.map_name)
}
#endif
inline void ResponseReplayInfo::set_map_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_map_name();
  map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ResponseReplayInfo.map_name)
}
inline void ResponseReplayInfo::set_map_name(const char* value, size_t size) {
  set_has_map_name();
  map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ResponseReplayInfo.map_name)
}
inline ::std::string* ResponseReplayInfo::mutable_map_name() {
  set_has_map_name();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseReplayInfo.map_name)
  return map_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseReplayInfo::release_map_name() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ResponseReplayInfo.map_name)
  if (!has_map_name()) {
    return NULL;
  }
  clear_has_map_name();
  return map_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseReplayInfo::set_allocated_map_name(::std::string* map_name) {
  if (map_name != NULL) {
    set_has_map_name();
  } else {
    clear_has_map_name();
  }
  map_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map_name);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ResponseReplayInfo.map_name)
}

// optional string local_map_path = 2;
inline bool ResponseReplayInfo::has_local_map_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseReplayInfo::set_has_local_map_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseReplayInfo::clear_has_local_map_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseReplayInfo::clear_local_map_path() {
  local_map_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_local_map_path();
}
inline const ::std::string& ResponseReplayInfo::local_map_path() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseReplayInfo.local_map_path)
  return local_map_path_.GetNoArena();
}
inline void ResponseReplayInfo::set_local_map_path(const ::std::string& value) {
  set_has_local_map_path();
  local_map_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseReplayInfo.local_map_path)
}
#if LANG_CXX11
inline void ResponseReplayInfo::set_local_map_path(::std::string&& value) {
  set_has_local_map_path();
  local_map_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.ResponseReplayInfo.local_map_path)
}
#endif
inline void ResponseReplayInfo::set_local_map_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_local_map_path();
  local_map_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ResponseReplayInfo.local_map_path)
}
inline void ResponseReplayInfo::set_local_map_path(const char* value, size_t size) {
  set_has_local_map_path();
  local_map_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ResponseReplayInfo.local_map_path)
}
inline ::std::string* ResponseReplayInfo::mutable_local_map_path() {
  set_has_local_map_path();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseReplayInfo.local_map_path)
  return local_map_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseReplayInfo::release_local_map_path() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ResponseReplayInfo.local_map_path)
  if (!has_local_map_path()) {
    return NULL;
  }
  clear_has_local_map_path();
  return local_map_path_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseReplayInfo::set_allocated_local_map_path(::std::string* local_map_path) {
  if (local_map_path != NULL) {
    set_has_local_map_path();
  } else {
    clear_has_local_map_path();
  }
  local_map_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), local_map_path);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ResponseReplayInfo.local_map_path)
}

// repeated .SC2APIProtocol.PlayerInfoExtra player_info = 3;
inline int ResponseReplayInfo::player_info_size() const {
  return player_info_.size();
}
inline void ResponseReplayInfo::clear_player_info() {
  player_info_.Clear();
}
inline ::SC2APIProtocol::PlayerInfoExtra* ResponseReplayInfo::mutable_player_info(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseReplayInfo.player_info)
  return player_info_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PlayerInfoExtra >*
ResponseReplayInfo::mutable_player_info() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ResponseReplayInfo.player_info)
  return &player_info_;
}
inline const ::SC2APIProtocol::PlayerInfoExtra& ResponseReplayInfo::player_info(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseReplayInfo.player_info)
  return player_info_.Get(index);
}
inline ::SC2APIProtocol::PlayerInfoExtra* ResponseReplayInfo::add_player_info() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ResponseReplayInfo.player_info)
  return player_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::PlayerInfoExtra >&
ResponseReplayInfo::player_info() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ResponseReplayInfo.player_info)
  return player_info_;
}

// optional uint32 game_duration_loops = 4;
inline bool ResponseReplayInfo::has_game_duration_loops() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ResponseReplayInfo::set_has_game_duration_loops() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ResponseReplayInfo::clear_has_game_duration_loops() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ResponseReplayInfo::clear_game_duration_loops() {
  game_duration_loops_ = 0u;
  clear_has_game_duration_loops();
}
inline ::google::protobuf::uint32 ResponseReplayInfo::game_duration_loops() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseReplayInfo.game_duration_loops)
  return game_duration_loops_;
}
inline void ResponseReplayInfo::set_game_duration_loops(::google::protobuf::uint32 value) {
  set_has_game_duration_loops();
  game_duration_loops_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseReplayInfo.game_duration_loops)
}

// optional float game_duration_seconds = 5;
inline bool ResponseReplayInfo::has_game_duration_seconds() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ResponseReplayInfo::set_has_game_duration_seconds() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ResponseReplayInfo::clear_has_game_duration_seconds() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ResponseReplayInfo::clear_game_duration_seconds() {
  game_duration_seconds_ = 0;
  clear_has_game_duration_seconds();
}
inline float ResponseReplayInfo::game_duration_seconds() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseReplayInfo.game_duration_seconds)
  return game_duration_seconds_;
}
inline void ResponseReplayInfo::set_game_duration_seconds(float value) {
  set_has_game_duration_seconds();
  game_duration_seconds_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseReplayInfo.game_duration_seconds)
}

// optional string game_version = 6;
inline bool ResponseReplayInfo::has_game_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseReplayInfo::set_has_game_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseReplayInfo::clear_has_game_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseReplayInfo::clear_game_version() {
  game_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_game_version();
}
inline const ::std::string& ResponseReplayInfo::game_version() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseReplayInfo.game_version)
  return game_version_.GetNoArena();
}
inline void ResponseReplayInfo::set_game_version(const ::std::string& value) {
  set_has_game_version();
  game_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseReplayInfo.game_version)
}
#if LANG_CXX11
inline void ResponseReplayInfo::set_game_version(::std::string&& value) {
  set_has_game_version();
  game_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.ResponseReplayInfo.game_version)
}
#endif
inline void ResponseReplayInfo::set_game_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_game_version();
  game_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ResponseReplayInfo.game_version)
}
inline void ResponseReplayInfo::set_game_version(const char* value, size_t size) {
  set_has_game_version();
  game_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ResponseReplayInfo.game_version)
}
inline ::std::string* ResponseReplayInfo::mutable_game_version() {
  set_has_game_version();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseReplayInfo.game_version)
  return game_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseReplayInfo::release_game_version() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ResponseReplayInfo.game_version)
  if (!has_game_version()) {
    return NULL;
  }
  clear_has_game_version();
  return game_version_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseReplayInfo::set_allocated_game_version(::std::string* game_version) {
  if (game_version != NULL) {
    set_has_game_version();
  } else {
    clear_has_game_version();
  }
  game_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), game_version);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ResponseReplayInfo.game_version)
}

// optional string data_version = 11;
inline bool ResponseReplayInfo::has_data_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResponseReplayInfo::set_has_data_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResponseReplayInfo::clear_has_data_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResponseReplayInfo::clear_data_version() {
  data_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data_version();
}
inline const ::std::string& ResponseReplayInfo::data_version() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseReplayInfo.data_version)
  return data_version_.GetNoArena();
}
inline void ResponseReplayInfo::set_data_version(const ::std::string& value) {
  set_has_data_version();
  data_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseReplayInfo.data_version)
}
#if LANG_CXX11
inline void ResponseReplayInfo::set_data_version(::std::string&& value) {
  set_has_data_version();
  data_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.ResponseReplayInfo.data_version)
}
#endif
inline void ResponseReplayInfo::set_data_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data_version();
  data_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ResponseReplayInfo.data_version)
}
inline void ResponseReplayInfo::set_data_version(const char* value, size_t size) {
  set_has_data_version();
  data_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ResponseReplayInfo.data_version)
}
inline ::std::string* ResponseReplayInfo::mutable_data_version() {
  set_has_data_version();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseReplayInfo.data_version)
  return data_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseReplayInfo::release_data_version() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ResponseReplayInfo.data_version)
  if (!has_data_version()) {
    return NULL;
  }
  clear_has_data_version();
  return data_version_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseReplayInfo::set_allocated_data_version(::std::string* data_version) {
  if (data_version != NULL) {
    set_has_data_version();
  } else {
    clear_has_data_version();
  }
  data_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data_version);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ResponseReplayInfo.data_version)
}

// optional uint32 data_build = 7;
inline bool ResponseReplayInfo::has_data_build() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ResponseReplayInfo::set_has_data_build() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ResponseReplayInfo::clear_has_data_build() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ResponseReplayInfo::clear_data_build() {
  data_build_ = 0u;
  clear_has_data_build();
}
inline ::google::protobuf::uint32 ResponseReplayInfo::data_build() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseReplayInfo.data_build)
  return data_build_;
}
inline void ResponseReplayInfo::set_data_build(::google::protobuf::uint32 value) {
  set_has_data_build();
  data_build_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseReplayInfo.data_build)
}

// optional uint32 base_build = 8;
inline bool ResponseReplayInfo::has_base_build() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ResponseReplayInfo::set_has_base_build() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ResponseReplayInfo::clear_has_base_build() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ResponseReplayInfo::clear_base_build() {
  base_build_ = 0u;
  clear_has_base_build();
}
inline ::google::protobuf::uint32 ResponseReplayInfo::base_build() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseReplayInfo.base_build)
  return base_build_;
}
inline void ResponseReplayInfo::set_base_build(::google::protobuf::uint32 value) {
  set_has_base_build();
  base_build_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseReplayInfo.base_build)
}

// optional .SC2APIProtocol.ResponseReplayInfo.Error error = 9;
inline bool ResponseReplayInfo::has_error() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ResponseReplayInfo::set_has_error() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ResponseReplayInfo::clear_has_error() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ResponseReplayInfo::clear_error() {
  error_ = 1;
  clear_has_error();
}
inline ::SC2APIProtocol::ResponseReplayInfo_Error ResponseReplayInfo::error() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseReplayInfo.error)
  return static_cast< ::SC2APIProtocol::ResponseReplayInfo_Error >(error_);
}
inline void ResponseReplayInfo::set_error(::SC2APIProtocol::ResponseReplayInfo_Error value) {
  assert(::SC2APIProtocol::ResponseReplayInfo_Error_IsValid(value));
  set_has_error();
  error_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseReplayInfo.error)
}

// optional string error_details = 10;
inline bool ResponseReplayInfo::has_error_details() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResponseReplayInfo::set_has_error_details() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResponseReplayInfo::clear_has_error_details() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResponseReplayInfo::clear_error_details() {
  error_details_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error_details();
}
inline const ::std::string& ResponseReplayInfo::error_details() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseReplayInfo.error_details)
  return error_details_.GetNoArena();
}
inline void ResponseReplayInfo::set_error_details(const ::std::string& value) {
  set_has_error_details();
  error_details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseReplayInfo.error_details)
}
#if LANG_CXX11
inline void ResponseReplayInfo::set_error_details(::std::string&& value) {
  set_has_error_details();
  error_details_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.ResponseReplayInfo.error_details)
}
#endif
inline void ResponseReplayInfo::set_error_details(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_error_details();
  error_details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ResponseReplayInfo.error_details)
}
inline void ResponseReplayInfo::set_error_details(const char* value, size_t size) {
  set_has_error_details();
  error_details_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ResponseReplayInfo.error_details)
}
inline ::std::string* ResponseReplayInfo::mutable_error_details() {
  set_has_error_details();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseReplayInfo.error_details)
  return error_details_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseReplayInfo::release_error_details() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ResponseReplayInfo.error_details)
  if (!has_error_details()) {
    return NULL;
  }
  clear_has_error_details();
  return error_details_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseReplayInfo::set_allocated_error_details(::std::string* error_details) {
  if (error_details != NULL) {
    set_has_error_details();
  } else {
    clear_has_error_details();
  }
  error_details_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_details);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ResponseReplayInfo.error_details)
}

// -------------------------------------------------------------------

// RequestAvailableMaps

// -------------------------------------------------------------------

// ResponseAvailableMaps

// repeated string local_map_paths = 1;
inline int ResponseAvailableMaps::local_map_paths_size() const {
  return local_map_paths_.size();
}
inline void ResponseAvailableMaps::clear_local_map_paths() {
  local_map_paths_.Clear();
}
inline const ::std::string& ResponseAvailableMaps::local_map_paths(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseAvailableMaps.local_map_paths)
  return local_map_paths_.Get(index);
}
inline ::std::string* ResponseAvailableMaps::mutable_local_map_paths(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseAvailableMaps.local_map_paths)
  return local_map_paths_.Mutable(index);
}
inline void ResponseAvailableMaps::set_local_map_paths(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseAvailableMaps.local_map_paths)
  local_map_paths_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ResponseAvailableMaps::set_local_map_paths(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseAvailableMaps.local_map_paths)
  local_map_paths_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ResponseAvailableMaps::set_local_map_paths(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  local_map_paths_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ResponseAvailableMaps.local_map_paths)
}
inline void ResponseAvailableMaps::set_local_map_paths(int index, const char* value, size_t size) {
  local_map_paths_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ResponseAvailableMaps.local_map_paths)
}
inline ::std::string* ResponseAvailableMaps::add_local_map_paths() {
  // @@protoc_insertion_point(field_add_mutable:SC2APIProtocol.ResponseAvailableMaps.local_map_paths)
  return local_map_paths_.Add();
}
inline void ResponseAvailableMaps::add_local_map_paths(const ::std::string& value) {
  local_map_paths_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ResponseAvailableMaps.local_map_paths)
}
#if LANG_CXX11
inline void ResponseAvailableMaps::add_local_map_paths(::std::string&& value) {
  local_map_paths_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ResponseAvailableMaps.local_map_paths)
}
#endif
inline void ResponseAvailableMaps::add_local_map_paths(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  local_map_paths_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SC2APIProtocol.ResponseAvailableMaps.local_map_paths)
}
inline void ResponseAvailableMaps::add_local_map_paths(const char* value, size_t size) {
  local_map_paths_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SC2APIProtocol.ResponseAvailableMaps.local_map_paths)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ResponseAvailableMaps::local_map_paths() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ResponseAvailableMaps.local_map_paths)
  return local_map_paths_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ResponseAvailableMaps::mutable_local_map_paths() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ResponseAvailableMaps.local_map_paths)
  return &local_map_paths_;
}

// repeated string battlenet_map_names = 2;
inline int ResponseAvailableMaps::battlenet_map_names_size() const {
  return battlenet_map_names_.size();
}
inline void ResponseAvailableMaps::clear_battlenet_map_names() {
  battlenet_map_names_.Clear();
}
inline const ::std::string& ResponseAvailableMaps::battlenet_map_names(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseAvailableMaps.battlenet_map_names)
  return battlenet_map_names_.Get(index);
}
inline ::std::string* ResponseAvailableMaps::mutable_battlenet_map_names(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponseAvailableMaps.battlenet_map_names)
  return battlenet_map_names_.Mutable(index);
}
inline void ResponseAvailableMaps::set_battlenet_map_names(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseAvailableMaps.battlenet_map_names)
  battlenet_map_names_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ResponseAvailableMaps::set_battlenet_map_names(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseAvailableMaps.battlenet_map_names)
  battlenet_map_names_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ResponseAvailableMaps::set_battlenet_map_names(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  battlenet_map_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ResponseAvailableMaps.battlenet_map_names)
}
inline void ResponseAvailableMaps::set_battlenet_map_names(int index, const char* value, size_t size) {
  battlenet_map_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ResponseAvailableMaps.battlenet_map_names)
}
inline ::std::string* ResponseAvailableMaps::add_battlenet_map_names() {
  // @@protoc_insertion_point(field_add_mutable:SC2APIProtocol.ResponseAvailableMaps.battlenet_map_names)
  return battlenet_map_names_.Add();
}
inline void ResponseAvailableMaps::add_battlenet_map_names(const ::std::string& value) {
  battlenet_map_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ResponseAvailableMaps.battlenet_map_names)
}
#if LANG_CXX11
inline void ResponseAvailableMaps::add_battlenet_map_names(::std::string&& value) {
  battlenet_map_names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ResponseAvailableMaps.battlenet_map_names)
}
#endif
inline void ResponseAvailableMaps::add_battlenet_map_names(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  battlenet_map_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SC2APIProtocol.ResponseAvailableMaps.battlenet_map_names)
}
inline void ResponseAvailableMaps::add_battlenet_map_names(const char* value, size_t size) {
  battlenet_map_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SC2APIProtocol.ResponseAvailableMaps.battlenet_map_names)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ResponseAvailableMaps::battlenet_map_names() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ResponseAvailableMaps.battlenet_map_names)
  return battlenet_map_names_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ResponseAvailableMaps::mutable_battlenet_map_names() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ResponseAvailableMaps.battlenet_map_names)
  return &battlenet_map_names_;
}

// -------------------------------------------------------------------

// RequestSaveMap

// optional string map_path = 1;
inline bool RequestSaveMap::has_map_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestSaveMap::set_has_map_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestSaveMap::clear_has_map_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestSaveMap::clear_map_path() {
  map_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_map_path();
}
inline const ::std::string& RequestSaveMap::map_path() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestSaveMap.map_path)
  return map_path_.GetNoArena();
}
inline void RequestSaveMap::set_map_path(const ::std::string& value) {
  set_has_map_path();
  map_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestSaveMap.map_path)
}
#if LANG_CXX11
inline void RequestSaveMap::set_map_path(::std::string&& value) {
  set_has_map_path();
  map_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.RequestSaveMap.map_path)
}
#endif
inline void RequestSaveMap::set_map_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_map_path();
  map_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.RequestSaveMap.map_path)
}
inline void RequestSaveMap::set_map_path(const char* value, size_t size) {
  set_has_map_path();
  map_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.RequestSaveMap.map_path)
}
inline ::std::string* RequestSaveMap::mutable_map_path() {
  set_has_map_path();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RequestSaveMap.map_path)
  return map_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestSaveMap::release_map_path() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.RequestSaveMap.map_path)
  if (!has_map_path()) {
    return NULL;
  }
  clear_has_map_path();
  return map_path_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestSaveMap::set_allocated_map_path(::std::string* map_path) {
  if (map_path != NULL) {
    set_has_map_path();
  } else {
    clear_has_map_path();
  }
  map_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map_path);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.RequestSaveMap.map_path)
}

// optional bytes map_data = 2;
inline bool RequestSaveMap::has_map_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestSaveMap::set_has_map_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestSaveMap::clear_has_map_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestSaveMap::clear_map_data() {
  map_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_map_data();
}
inline const ::std::string& RequestSaveMap::map_data() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestSaveMap.map_data)
  return map_data_.GetNoArena();
}
inline void RequestSaveMap::set_map_data(const ::std::string& value) {
  set_has_map_data();
  map_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.RequestSaveMap.map_data)
}
#if LANG_CXX11
inline void RequestSaveMap::set_map_data(::std::string&& value) {
  set_has_map_data();
  map_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.RequestSaveMap.map_data)
}
#endif
inline void RequestSaveMap::set_map_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_map_data();
  map_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.RequestSaveMap.map_data)
}
inline void RequestSaveMap::set_map_data(const void* value, size_t size) {
  set_has_map_data();
  map_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.RequestSaveMap.map_data)
}
inline ::std::string* RequestSaveMap::mutable_map_data() {
  set_has_map_data();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RequestSaveMap.map_data)
  return map_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestSaveMap::release_map_data() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.RequestSaveMap.map_data)
  if (!has_map_data()) {
    return NULL;
  }
  clear_has_map_data();
  return map_data_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestSaveMap::set_allocated_map_data(::std::string* map_data) {
  if (map_data != NULL) {
    set_has_map_data();
  } else {
    clear_has_map_data();
  }
  map_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map_data);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.RequestSaveMap.map_data)
}

// -------------------------------------------------------------------

// ResponseSaveMap

// optional .SC2APIProtocol.ResponseSaveMap.Error error = 1;
inline bool ResponseSaveMap::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseSaveMap::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseSaveMap::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseSaveMap::clear_error() {
  error_ = 1;
  clear_has_error();
}
inline ::SC2APIProtocol::ResponseSaveMap_Error ResponseSaveMap::error() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponseSaveMap.error)
  return static_cast< ::SC2APIProtocol::ResponseSaveMap_Error >(error_);
}
inline void ResponseSaveMap::set_error(::SC2APIProtocol::ResponseSaveMap_Error value) {
  assert(::SC2APIProtocol::ResponseSaveMap_Error_IsValid(value));
  set_has_error();
  error_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponseSaveMap.error)
}

// -------------------------------------------------------------------

// RequestPing

// -------------------------------------------------------------------

// ResponsePing

// optional string game_version = 1;
inline bool ResponsePing::has_game_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponsePing::set_has_game_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponsePing::clear_has_game_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponsePing::clear_game_version() {
  game_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_game_version();
}
inline const ::std::string& ResponsePing::game_version() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponsePing.game_version)
  return game_version_.GetNoArena();
}
inline void ResponsePing::set_game_version(const ::std::string& value) {
  set_has_game_version();
  game_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponsePing.game_version)
}
#if LANG_CXX11
inline void ResponsePing::set_game_version(::std::string&& value) {
  set_has_game_version();
  game_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.ResponsePing.game_version)
}
#endif
inline void ResponsePing::set_game_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_game_version();
  game_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ResponsePing.game_version)
}
inline void ResponsePing::set_game_version(const char* value, size_t size) {
  set_has_game_version();
  game_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ResponsePing.game_version)
}
inline ::std::string* ResponsePing::mutable_game_version() {
  set_has_game_version();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponsePing.game_version)
  return game_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponsePing::release_game_version() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ResponsePing.game_version)
  if (!has_game_version()) {
    return NULL;
  }
  clear_has_game_version();
  return game_version_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponsePing::set_allocated_game_version(::std::string* game_version) {
  if (game_version != NULL) {
    set_has_game_version();
  } else {
    clear_has_game_version();
  }
  game_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), game_version);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ResponsePing.game_version)
}

// optional string data_version = 2;
inline bool ResponsePing::has_data_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponsePing::set_has_data_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponsePing::clear_has_data_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponsePing::clear_data_version() {
  data_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data_version();
}
inline const ::std::string& ResponsePing::data_version() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponsePing.data_version)
  return data_version_.GetNoArena();
}
inline void ResponsePing::set_data_version(const ::std::string& value) {
  set_has_data_version();
  data_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponsePing.data_version)
}
#if LANG_CXX11
inline void ResponsePing::set_data_version(::std::string&& value) {
  set_has_data_version();
  data_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.ResponsePing.data_version)
}
#endif
inline void ResponsePing::set_data_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data_version();
  data_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ResponsePing.data_version)
}
inline void ResponsePing::set_data_version(const char* value, size_t size) {
  set_has_data_version();
  data_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ResponsePing.data_version)
}
inline ::std::string* ResponsePing::mutable_data_version() {
  set_has_data_version();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ResponsePing.data_version)
  return data_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponsePing::release_data_version() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ResponsePing.data_version)
  if (!has_data_version()) {
    return NULL;
  }
  clear_has_data_version();
  return data_version_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponsePing::set_allocated_data_version(::std::string* data_version) {
  if (data_version != NULL) {
    set_has_data_version();
  } else {
    clear_has_data_version();
  }
  data_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data_version);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ResponsePing.data_version)
}

// optional uint32 data_build = 3;
inline bool ResponsePing::has_data_build() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponsePing::set_has_data_build() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponsePing::clear_has_data_build() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponsePing::clear_data_build() {
  data_build_ = 0u;
  clear_has_data_build();
}
inline ::google::protobuf::uint32 ResponsePing::data_build() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponsePing.data_build)
  return data_build_;
}
inline void ResponsePing::set_data_build(::google::protobuf::uint32 value) {
  set_has_data_build();
  data_build_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponsePing.data_build)
}

// optional uint32 base_build = 4;
inline bool ResponsePing::has_base_build() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResponsePing::set_has_base_build() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResponsePing::clear_has_base_build() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResponsePing::clear_base_build() {
  base_build_ = 0u;
  clear_has_base_build();
}
inline ::google::protobuf::uint32 ResponsePing::base_build() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ResponsePing.base_build)
  return base_build_;
}
inline void ResponsePing::set_base_build(::google::protobuf::uint32 value) {
  set_has_base_build();
  base_build_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ResponsePing.base_build)
}

// -------------------------------------------------------------------

// RequestDebug

// repeated .SC2APIProtocol.DebugCommand debug = 1;
inline int RequestDebug::debug_size() const {
  return debug_.size();
}
inline ::SC2APIProtocol::DebugCommand* RequestDebug::mutable_debug(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.RequestDebug.debug)
  return debug_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::DebugCommand >*
RequestDebug::mutable_debug() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.RequestDebug.debug)
  return &debug_;
}
inline const ::SC2APIProtocol::DebugCommand& RequestDebug::debug(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.RequestDebug.debug)
  return debug_.Get(index);
}
inline ::SC2APIProtocol::DebugCommand* RequestDebug::add_debug() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.RequestDebug.debug)
  return debug_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::DebugCommand >&
RequestDebug::debug() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.RequestDebug.debug)
  return debug_;
}

// -------------------------------------------------------------------

// ResponseDebug

// -------------------------------------------------------------------

// PlayerSetup

// optional .SC2APIProtocol.PlayerType type = 1;
inline bool PlayerSetup::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerSetup::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerSetup::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerSetup::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::SC2APIProtocol::PlayerType PlayerSetup::type() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerSetup.type)
  return static_cast< ::SC2APIProtocol::PlayerType >(type_);
}
inline void PlayerSetup::set_type(::SC2APIProtocol::PlayerType value) {
  assert(::SC2APIProtocol::PlayerType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerSetup.type)
}

// optional .SC2APIProtocol.Race race = 2;
inline bool PlayerSetup::has_race() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerSetup::set_has_race() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerSetup::clear_has_race() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerSetup::clear_race() {
  race_ = 0;
  clear_has_race();
}
inline ::SC2APIProtocol::Race PlayerSetup::race() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerSetup.race)
  return static_cast< ::SC2APIProtocol::Race >(race_);
}
inline void PlayerSetup::set_race(::SC2APIProtocol::Race value) {
  assert(::SC2APIProtocol::Race_IsValid(value));
  set_has_race();
  race_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerSetup.race)
}

// optional .SC2APIProtocol.Difficulty difficulty = 3;
inline bool PlayerSetup::has_difficulty() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerSetup::set_has_difficulty() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerSetup::clear_has_difficulty() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerSetup::clear_difficulty() {
  difficulty_ = 1;
  clear_has_difficulty();
}
inline ::SC2APIProtocol::Difficulty PlayerSetup::difficulty() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerSetup.difficulty)
  return static_cast< ::SC2APIProtocol::Difficulty >(difficulty_);
}
inline void PlayerSetup::set_difficulty(::SC2APIProtocol::Difficulty value) {
  assert(::SC2APIProtocol::Difficulty_IsValid(value));
  set_has_difficulty();
  difficulty_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerSetup.difficulty)
}

// -------------------------------------------------------------------

// SpatialCameraSetup

// optional float width = 1;
inline bool SpatialCameraSetup::has_width() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SpatialCameraSetup::set_has_width() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SpatialCameraSetup::clear_has_width() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SpatialCameraSetup::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline float SpatialCameraSetup::width() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.SpatialCameraSetup.width)
  return width_;
}
inline void SpatialCameraSetup::set_width(float value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.SpatialCameraSetup.width)
}

// optional .SC2APIProtocol.Size2DI resolution = 2;
inline bool SpatialCameraSetup::has_resolution() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SpatialCameraSetup::set_has_resolution() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SpatialCameraSetup::clear_has_resolution() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::SC2APIProtocol::Size2DI& SpatialCameraSetup::_internal_resolution() const {
  return *resolution_;
}
inline const ::SC2APIProtocol::Size2DI& SpatialCameraSetup::resolution() const {
  const ::SC2APIProtocol::Size2DI* p = resolution_;
  // @@protoc_insertion_point(field_get:SC2APIProtocol.SpatialCameraSetup.resolution)
  return p != NULL ? *p : *reinterpret_cast<const ::SC2APIProtocol::Size2DI*>(
      &::SC2APIProtocol::_Size2DI_default_instance_);
}
inline ::SC2APIProtocol::Size2DI* SpatialCameraSetup::release_resolution() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.SpatialCameraSetup.resolution)
  clear_has_resolution();
  ::SC2APIProtocol::Size2DI* temp = resolution_;
  resolution_ = NULL;
  return temp;
}
inline ::SC2APIProtocol::Size2DI* SpatialCameraSetup::mutable_resolution() {
  set_has_resolution();
  if (resolution_ == NULL) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::Size2DI>(GetArenaNoVirtual());
    resolution_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.SpatialCameraSetup.resolution)
  return resolution_;
}
inline void SpatialCameraSetup::set_allocated_resolution(::SC2APIProtocol::Size2DI* resolution) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(resolution_);
  }
  if (resolution) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      resolution = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, resolution, submessage_arena);
    }
    set_has_resolution();
  } else {
    clear_has_resolution();
  }
  resolution_ = resolution;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.SpatialCameraSetup.resolution)
}

// optional .SC2APIProtocol.Size2DI minimap_resolution = 3;
inline bool SpatialCameraSetup::has_minimap_resolution() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SpatialCameraSetup::set_has_minimap_resolution() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SpatialCameraSetup::clear_has_minimap_resolution() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::SC2APIProtocol::Size2DI& SpatialCameraSetup::_internal_minimap_resolution() const {
  return *minimap_resolution_;
}
inline const ::SC2APIProtocol::Size2DI& SpatialCameraSetup::minimap_resolution() const {
  const ::SC2APIProtocol::Size2DI* p = minimap_resolution_;
  // @@protoc_insertion_point(field_get:SC2APIProtocol.SpatialCameraSetup.minimap_resolution)
  return p != NULL ? *p : *reinterpret_cast<const ::SC2APIProtocol::Size2DI*>(
      &::SC2APIProtocol::_Size2DI_default_instance_);
}
inline ::SC2APIProtocol::Size2DI* SpatialCameraSetup::release_minimap_resolution() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.SpatialCameraSetup.minimap_resolution)
  clear_has_minimap_resolution();
  ::SC2APIProtocol::Size2DI* temp = minimap_resolution_;
  minimap_resolution_ = NULL;
  return temp;
}
inline ::SC2APIProtocol::Size2DI* SpatialCameraSetup::mutable_minimap_resolution() {
  set_has_minimap_resolution();
  if (minimap_resolution_ == NULL) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::Size2DI>(GetArenaNoVirtual());
    minimap_resolution_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.SpatialCameraSetup.minimap_resolution)
  return minimap_resolution_;
}
inline void SpatialCameraSetup::set_allocated_minimap_resolution(::SC2APIProtocol::Size2DI* minimap_resolution) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(minimap_resolution_);
  }
  if (minimap_resolution) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      minimap_resolution = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, minimap_resolution, submessage_arena);
    }
    set_has_minimap_resolution();
  } else {
    clear_has_minimap_resolution();
  }
  minimap_resolution_ = minimap_resolution;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.SpatialCameraSetup.minimap_resolution)
}

// -------------------------------------------------------------------

// InterfaceOptions

// optional bool raw = 1;
inline bool InterfaceOptions::has_raw() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InterfaceOptions::set_has_raw() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InterfaceOptions::clear_has_raw() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InterfaceOptions::clear_raw() {
  raw_ = false;
  clear_has_raw();
}
inline bool InterfaceOptions::raw() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.InterfaceOptions.raw)
  return raw_;
}
inline void InterfaceOptions::set_raw(bool value) {
  set_has_raw();
  raw_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.InterfaceOptions.raw)
}

// optional bool score = 2;
inline bool InterfaceOptions::has_score() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InterfaceOptions::set_has_score() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InterfaceOptions::clear_has_score() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InterfaceOptions::clear_score() {
  score_ = false;
  clear_has_score();
}
inline bool InterfaceOptions::score() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.InterfaceOptions.score)
  return score_;
}
inline void InterfaceOptions::set_score(bool value) {
  set_has_score();
  score_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.InterfaceOptions.score)
}

// optional .SC2APIProtocol.SpatialCameraSetup feature_layer = 3;
inline bool InterfaceOptions::has_feature_layer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InterfaceOptions::set_has_feature_layer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InterfaceOptions::clear_has_feature_layer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InterfaceOptions::clear_feature_layer() {
  if (feature_layer_ != NULL) feature_layer_->Clear();
  clear_has_feature_layer();
}
inline const ::SC2APIProtocol::SpatialCameraSetup& InterfaceOptions::_internal_feature_layer() const {
  return *feature_layer_;
}
inline const ::SC2APIProtocol::SpatialCameraSetup& InterfaceOptions::feature_layer() const {
  const ::SC2APIProtocol::SpatialCameraSetup* p = feature_layer_;
  // @@protoc_insertion_point(field_get:SC2APIProtocol.InterfaceOptions.feature_layer)
  return p != NULL ? *p : *reinterpret_cast<const ::SC2APIProtocol::SpatialCameraSetup*>(
      &::SC2APIProtocol::_SpatialCameraSetup_default_instance_);
}
inline ::SC2APIProtocol::SpatialCameraSetup* InterfaceOptions::release_feature_layer() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.InterfaceOptions.feature_layer)
  clear_has_feature_layer();
  ::SC2APIProtocol::SpatialCameraSetup* temp = feature_layer_;
  feature_layer_ = NULL;
  return temp;
}
inline ::SC2APIProtocol::SpatialCameraSetup* InterfaceOptions::mutable_feature_layer() {
  set_has_feature_layer();
  if (feature_layer_ == NULL) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::SpatialCameraSetup>(GetArenaNoVirtual());
    feature_layer_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.InterfaceOptions.feature_layer)
  return feature_layer_;
}
inline void InterfaceOptions::set_allocated_feature_layer(::SC2APIProtocol::SpatialCameraSetup* feature_layer) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete feature_layer_;
  }
  if (feature_layer) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      feature_layer = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, feature_layer, submessage_arena);
    }
    set_has_feature_layer();
  } else {
    clear_has_feature_layer();
  }
  feature_layer_ = feature_layer;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.InterfaceOptions.feature_layer)
}

// optional .SC2APIProtocol.SpatialCameraSetup render = 4;
inline bool InterfaceOptions::has_render() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InterfaceOptions::set_has_render() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InterfaceOptions::clear_has_render() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InterfaceOptions::clear_render() {
  if (render_ != NULL) render_->Clear();
  clear_has_render();
}
inline const ::SC2APIProtocol::SpatialCameraSetup& InterfaceOptions::_internal_render() const {
  return *render_;
}
inline const ::SC2APIProtocol::SpatialCameraSetup& InterfaceOptions::render() const {
  const ::SC2APIProtocol::SpatialCameraSetup* p = render_;
  // @@protoc_insertion_point(field_get:SC2APIProtocol.InterfaceOptions.render)
  return p != NULL ? *p : *reinterpret_cast<const ::SC2APIProtocol::SpatialCameraSetup*>(
      &::SC2APIProtocol::_SpatialCameraSetup_default_instance_);
}
inline ::SC2APIProtocol::SpatialCameraSetup* InterfaceOptions::release_render() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.InterfaceOptions.render)
  clear_has_render();
  ::SC2APIProtocol::SpatialCameraSetup* temp = render_;
  render_ = NULL;
  return temp;
}
inline ::SC2APIProtocol::SpatialCameraSetup* InterfaceOptions::mutable_render() {
  set_has_render();
  if (render_ == NULL) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::SpatialCameraSetup>(GetArenaNoVirtual());
    render_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.InterfaceOptions.render)
  return render_;
}
inline void InterfaceOptions::set_allocated_render(::SC2APIProtocol::SpatialCameraSetup* render) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete render_;
  }
  if (render) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      render = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, render, submessage_arena);
    }
    set_has_render();
  } else {
    clear_has_render();
  }
  render_ = render;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.InterfaceOptions.render)
}

// -------------------------------------------------------------------

// PlayerInfo

// optional uint32 player_id = 1;
inline bool PlayerInfo::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerInfo::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerInfo::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerInfo::clear_player_id() {
  player_id_ = 0u;
  clear_has_player_id();
}
inline ::google::protobuf::uint32 PlayerInfo::player_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerInfo.player_id)
  return player_id_;
}
inline void PlayerInfo::set_player_id(::google::protobuf::uint32 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerInfo.player_id)
}

// optional .SC2APIProtocol.PlayerType type = 2;
inline bool PlayerInfo::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerInfo::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerInfo::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::SC2APIProtocol::PlayerType PlayerInfo::type() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerInfo.type)
  return static_cast< ::SC2APIProtocol::PlayerType >(type_);
}
inline void PlayerInfo::set_type(::SC2APIProtocol::PlayerType value) {
  assert(::SC2APIProtocol::PlayerType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerInfo.type)
}

// optional .SC2APIProtocol.Race race_requested = 3;
inline bool PlayerInfo::has_race_requested() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerInfo::set_has_race_requested() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerInfo::clear_has_race_requested() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerInfo::clear_race_requested() {
  race_requested_ = 0;
  clear_has_race_requested();
}
inline ::SC2APIProtocol::Race PlayerInfo::race_requested() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerInfo.race_requested)
  return static_cast< ::SC2APIProtocol::Race >(race_requested_);
}
inline void PlayerInfo::set_race_requested(::SC2APIProtocol::Race value) {
  assert(::SC2APIProtocol::Race_IsValid(value));
  set_has_race_requested();
  race_requested_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerInfo.race_requested)
}

// optional .SC2APIProtocol.Race race_actual = 4;
inline bool PlayerInfo::has_race_actual() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerInfo::set_has_race_actual() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerInfo::clear_has_race_actual() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerInfo::clear_race_actual() {
  race_actual_ = 0;
  clear_has_race_actual();
}
inline ::SC2APIProtocol::Race PlayerInfo::race_actual() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerInfo.race_actual)
  return static_cast< ::SC2APIProtocol::Race >(race_actual_);
}
inline void PlayerInfo::set_race_actual(::SC2APIProtocol::Race value) {
  assert(::SC2APIProtocol::Race_IsValid(value));
  set_has_race_actual();
  race_actual_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerInfo.race_actual)
}

// optional .SC2APIProtocol.Difficulty difficulty = 5;
inline bool PlayerInfo::has_difficulty() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlayerInfo::set_has_difficulty() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlayerInfo::clear_has_difficulty() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlayerInfo::clear_difficulty() {
  difficulty_ = 1;
  clear_has_difficulty();
}
inline ::SC2APIProtocol::Difficulty PlayerInfo::difficulty() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerInfo.difficulty)
  return static_cast< ::SC2APIProtocol::Difficulty >(difficulty_);
}
inline void PlayerInfo::set_difficulty(::SC2APIProtocol::Difficulty value) {
  assert(::SC2APIProtocol::Difficulty_IsValid(value));
  set_has_difficulty();
  difficulty_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerInfo.difficulty)
}

// -------------------------------------------------------------------

// PlayerCommon

// optional uint32 player_id = 1;
inline bool PlayerCommon::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerCommon::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerCommon::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerCommon::clear_player_id() {
  player_id_ = 0u;
  clear_has_player_id();
}
inline ::google::protobuf::uint32 PlayerCommon::player_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerCommon.player_id)
  return player_id_;
}
inline void PlayerCommon::set_player_id(::google::protobuf::uint32 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerCommon.player_id)
}

// optional uint32 minerals = 2;
inline bool PlayerCommon::has_minerals() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerCommon::set_has_minerals() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerCommon::clear_has_minerals() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerCommon::clear_minerals() {
  minerals_ = 0u;
  clear_has_minerals();
}
inline ::google::protobuf::uint32 PlayerCommon::minerals() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerCommon.minerals)
  return minerals_;
}
inline void PlayerCommon::set_minerals(::google::protobuf::uint32 value) {
  set_has_minerals();
  minerals_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerCommon.minerals)
}

// optional uint32 vespene = 3;
inline bool PlayerCommon::has_vespene() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerCommon::set_has_vespene() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerCommon::clear_has_vespene() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerCommon::clear_vespene() {
  vespene_ = 0u;
  clear_has_vespene();
}
inline ::google::protobuf::uint32 PlayerCommon::vespene() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerCommon.vespene)
  return vespene_;
}
inline void PlayerCommon::set_vespene(::google::protobuf::uint32 value) {
  set_has_vespene();
  vespene_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerCommon.vespene)
}

// optional uint32 food_cap = 4;
inline bool PlayerCommon::has_food_cap() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerCommon::set_has_food_cap() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerCommon::clear_has_food_cap() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerCommon::clear_food_cap() {
  food_cap_ = 0u;
  clear_has_food_cap();
}
inline ::google::protobuf::uint32 PlayerCommon::food_cap() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerCommon.food_cap)
  return food_cap_;
}
inline void PlayerCommon::set_food_cap(::google::protobuf::uint32 value) {
  set_has_food_cap();
  food_cap_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerCommon.food_cap)
}

// optional uint32 food_used = 5;
inline bool PlayerCommon::has_food_used() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlayerCommon::set_has_food_used() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlayerCommon::clear_has_food_used() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlayerCommon::clear_food_used() {
  food_used_ = 0u;
  clear_has_food_used();
}
inline ::google::protobuf::uint32 PlayerCommon::food_used() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerCommon.food_used)
  return food_used_;
}
inline void PlayerCommon::set_food_used(::google::protobuf::uint32 value) {
  set_has_food_used();
  food_used_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerCommon.food_used)
}

// optional uint32 food_army = 6;
inline bool PlayerCommon::has_food_army() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PlayerCommon::set_has_food_army() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PlayerCommon::clear_has_food_army() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PlayerCommon::clear_food_army() {
  food_army_ = 0u;
  clear_has_food_army();
}
inline ::google::protobuf::uint32 PlayerCommon::food_army() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerCommon.food_army)
  return food_army_;
}
inline void PlayerCommon::set_food_army(::google::protobuf::uint32 value) {
  set_has_food_army();
  food_army_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerCommon.food_army)
}

// optional uint32 food_workers = 7;
inline bool PlayerCommon::has_food_workers() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PlayerCommon::set_has_food_workers() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PlayerCommon::clear_has_food_workers() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PlayerCommon::clear_food_workers() {
  food_workers_ = 0u;
  clear_has_food_workers();
}
inline ::google::protobuf::uint32 PlayerCommon::food_workers() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerCommon.food_workers)
  return food_workers_;
}
inline void PlayerCommon::set_food_workers(::google::protobuf::uint32 value) {
  set_has_food_workers();
  food_workers_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerCommon.food_workers)
}

// optional uint32 idle_worker_count = 8;
inline bool PlayerCommon::has_idle_worker_count() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PlayerCommon::set_has_idle_worker_count() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PlayerCommon::clear_has_idle_worker_count() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PlayerCommon::clear_idle_worker_count() {
  idle_worker_count_ = 0u;
  clear_has_idle_worker_count();
}
inline ::google::protobuf::uint32 PlayerCommon::idle_worker_count() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerCommon.idle_worker_count)
  return idle_worker_count_;
}
inline void PlayerCommon::set_idle_worker_count(::google::protobuf::uint32 value) {
  set_has_idle_worker_count();
  idle_worker_count_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerCommon.idle_worker_count)
}

// optional uint32 army_count = 9;
inline bool PlayerCommon::has_army_count() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PlayerCommon::set_has_army_count() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PlayerCommon::clear_has_army_count() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PlayerCommon::clear_army_count() {
  army_count_ = 0u;
  clear_has_army_count();
}
inline ::google::protobuf::uint32 PlayerCommon::army_count() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerCommon.army_count)
  return army_count_;
}
inline void PlayerCommon::set_army_count(::google::protobuf::uint32 value) {
  set_has_army_count();
  army_count_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerCommon.army_count)
}

// optional uint32 warp_gate_count = 10;
inline bool PlayerCommon::has_warp_gate_count() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PlayerCommon::set_has_warp_gate_count() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PlayerCommon::clear_has_warp_gate_count() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PlayerCommon::clear_warp_gate_count() {
  warp_gate_count_ = 0u;
  clear_has_warp_gate_count();
}
inline ::google::protobuf::uint32 PlayerCommon::warp_gate_count() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerCommon.warp_gate_count)
  return warp_gate_count_;
}
inline void PlayerCommon::set_warp_gate_count(::google::protobuf::uint32 value) {
  set_has_warp_gate_count();
  warp_gate_count_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerCommon.warp_gate_count)
}

// optional uint32 larva_count = 11;
inline bool PlayerCommon::has_larva_count() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PlayerCommon::set_has_larva_count() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PlayerCommon::clear_has_larva_count() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PlayerCommon::clear_larva_count() {
  larva_count_ = 0u;
  clear_has_larva_count();
}
inline ::google::protobuf::uint32 PlayerCommon::larva_count() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerCommon.larva_count)
  return larva_count_;
}
inline void PlayerCommon::set_larva_count(::google::protobuf::uint32 value) {
  set_has_larva_count();
  larva_count_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerCommon.larva_count)
}

// -------------------------------------------------------------------

// Observation

// optional uint32 game_loop = 9;
inline bool Observation::has_game_loop() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Observation::set_has_game_loop() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Observation::clear_has_game_loop() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Observation::clear_game_loop() {
  game_loop_ = 0u;
  clear_has_game_loop();
}
inline ::google::protobuf::uint32 Observation::game_loop() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Observation.game_loop)
  return game_loop_;
}
inline void Observation::set_game_loop(::google::protobuf::uint32 value) {
  set_has_game_loop();
  game_loop_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Observation.game_loop)
}

// optional .SC2APIProtocol.PlayerCommon player_common = 1;
inline bool Observation::has_player_common() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Observation::set_has_player_common() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Observation::clear_has_player_common() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Observation::clear_player_common() {
  if (player_common_ != NULL) player_common_->Clear();
  clear_has_player_common();
}
inline const ::SC2APIProtocol::PlayerCommon& Observation::_internal_player_common() const {
  return *player_common_;
}
inline const ::SC2APIProtocol::PlayerCommon& Observation::player_common() const {
  const ::SC2APIProtocol::PlayerCommon* p = player_common_;
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Observation.player_common)
  return p != NULL ? *p : *reinterpret_cast<const ::SC2APIProtocol::PlayerCommon*>(
      &::SC2APIProtocol::_PlayerCommon_default_instance_);
}
inline ::SC2APIProtocol::PlayerCommon* Observation::release_player_common() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Observation.player_common)
  clear_has_player_common();
  ::SC2APIProtocol::PlayerCommon* temp = player_common_;
  player_common_ = NULL;
  return temp;
}
inline ::SC2APIProtocol::PlayerCommon* Observation::mutable_player_common() {
  set_has_player_common();
  if (player_common_ == NULL) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::PlayerCommon>(GetArenaNoVirtual());
    player_common_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Observation.player_common)
  return player_common_;
}
inline void Observation::set_allocated_player_common(::SC2APIProtocol::PlayerCommon* player_common) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete player_common_;
  }
  if (player_common) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      player_common = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, player_common, submessage_arena);
    }
    set_has_player_common();
  } else {
    clear_has_player_common();
  }
  player_common_ = player_common;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Observation.player_common)
}

// repeated .SC2APIProtocol.Alert alerts = 10;
inline int Observation::alerts_size() const {
  return alerts_.size();
}
inline void Observation::clear_alerts() {
  alerts_.Clear();
}
inline ::SC2APIProtocol::Alert Observation::alerts(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Observation.alerts)
  return static_cast< ::SC2APIProtocol::Alert >(alerts_.Get(index));
}
inline void Observation::set_alerts(int index, ::SC2APIProtocol::Alert value) {
  assert(::SC2APIProtocol::Alert_IsValid(value));
  alerts_.Set(index, value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.Observation.alerts)
}
inline void Observation::add_alerts(::SC2APIProtocol::Alert value) {
  assert(::SC2APIProtocol::Alert_IsValid(value));
  alerts_.Add(value);
  // @@protoc_insertion_point(field_add:SC2APIProtocol.Observation.alerts)
}
inline const ::google::protobuf::RepeatedField<int>&
Observation::alerts() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.Observation.alerts)
  return alerts_;
}
inline ::google::protobuf::RepeatedField<int>*
Observation::mutable_alerts() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.Observation.alerts)
  return &alerts_;
}

// repeated .SC2APIProtocol.AvailableAbility abilities = 3;
inline int Observation::abilities_size() const {
  return abilities_.size();
}
inline ::SC2APIProtocol::AvailableAbility* Observation::mutable_abilities(int index) {
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Observation.abilities)
  return abilities_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::AvailableAbility >*
Observation::mutable_abilities() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.Observation.abilities)
  return &abilities_;
}
inline const ::SC2APIProtocol::AvailableAbility& Observation::abilities(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Observation.abilities)
  return abilities_.Get(index);
}
inline ::SC2APIProtocol::AvailableAbility* Observation::add_abilities() {
  // @@protoc_insertion_point(field_add:SC2APIProtocol.Observation.abilities)
  return abilities_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SC2APIProtocol::AvailableAbility >&
Observation::abilities() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.Observation.abilities)
  return abilities_;
}

// optional .SC2APIProtocol.Score score = 4;
inline bool Observation::has_score() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Observation::set_has_score() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Observation::clear_has_score() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::SC2APIProtocol::Score& Observation::_internal_score() const {
  return *score_;
}
inline const ::SC2APIProtocol::Score& Observation::score() const {
  const ::SC2APIProtocol::Score* p = score_;
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Observation.score)
  return p != NULL ? *p : *reinterpret_cast<const ::SC2APIProtocol::Score*>(
      &::SC2APIProtocol::_Score_default_instance_);
}
inline ::SC2APIProtocol::Score* Observation::release_score() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Observation.score)
  clear_has_score();
  ::SC2APIProtocol::Score* temp = score_;
  score_ = NULL;
  return temp;
}
inline ::SC2APIProtocol::Score* Observation::mutable_score() {
  set_has_score();
  if (score_ == NULL) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::Score>(GetArenaNoVirtual());
    score_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Observation.score)
  return score_;
}
inline void Observation::set_allocated_score(::SC2APIProtocol::Score* score) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(score_);
  }
  if (score) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      score = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, score, submessage_arena);
    }
    set_has_score();
  } else {
    clear_has_score();
  }
  score_ = score;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Observation.score)
}

// optional .SC2APIProtocol.ObservationRaw raw_data = 5;
inline bool Observation::has_raw_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Observation::set_has_raw_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Observation::clear_has_raw_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::SC2APIProtocol::ObservationRaw& Observation::_internal_raw_data() const {
  return *raw_data_;
}
inline const ::SC2APIProtocol::ObservationRaw& Observation::raw_data() const {
  const ::SC2APIProtocol::ObservationRaw* p = raw_data_;
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Observation.raw_data)
  return p != NULL ? *p : *reinterpret_cast<const ::SC2APIProtocol::ObservationRaw*>(
      &::SC2APIProtocol::_ObservationRaw_default_instance_);
}
inline ::SC2APIProtocol::ObservationRaw* Observation::release_raw_data() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Observation.raw_data)
  clear_has_raw_data();
  ::SC2APIProtocol::ObservationRaw* temp = raw_data_;
  raw_data_ = NULL;
  return temp;
}
inline ::SC2APIProtocol::ObservationRaw* Observation::mutable_raw_data() {
  set_has_raw_data();
  if (raw_data_ == NULL) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ObservationRaw>(GetArenaNoVirtual());
    raw_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Observation.raw_data)
  return raw_data_;
}
inline void Observation::set_allocated_raw_data(::SC2APIProtocol::ObservationRaw* raw_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(raw_data_);
  }
  if (raw_data) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      raw_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, raw_data, submessage_arena);
    }
    set_has_raw_data();
  } else {
    clear_has_raw_data();
  }
  raw_data_ = raw_data;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Observation.raw_data)
}

// optional .SC2APIProtocol.ObservationFeatureLayer feature_layer_data = 6;
inline bool Observation::has_feature_layer_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Observation::set_has_feature_layer_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Observation::clear_has_feature_layer_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::SC2APIProtocol::ObservationFeatureLayer& Observation::_internal_feature_layer_data() const {
  return *feature_layer_data_;
}
inline const ::SC2APIProtocol::ObservationFeatureLayer& Observation::feature_layer_data() const {
  const ::SC2APIProtocol::ObservationFeatureLayer* p = feature_layer_data_;
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Observation.feature_layer_data)
  return p != NULL ? *p : *reinterpret_cast<const ::SC2APIProtocol::ObservationFeatureLayer*>(
      &::SC2APIProtocol::_ObservationFeatureLayer_default_instance_);
}
inline ::SC2APIProtocol::ObservationFeatureLayer* Observation::release_feature_layer_data() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Observation.feature_layer_data)
  clear_has_feature_layer_data();
  ::SC2APIProtocol::ObservationFeatureLayer* temp = feature_layer_data_;
  feature_layer_data_ = NULL;
  return temp;
}
inline ::SC2APIProtocol::ObservationFeatureLayer* Observation::mutable_feature_layer_data() {
  set_has_feature_layer_data();
  if (feature_layer_data_ == NULL) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ObservationFeatureLayer>(GetArenaNoVirtual());
    feature_layer_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Observation.feature_layer_data)
  return feature_layer_data_;
}
inline void Observation::set_allocated_feature_layer_data(::SC2APIProtocol::ObservationFeatureLayer* feature_layer_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(feature_layer_data_);
  }
  if (feature_layer_data) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      feature_layer_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, feature_layer_data, submessage_arena);
    }
    set_has_feature_layer_data();
  } else {
    clear_has_feature_layer_data();
  }
  feature_layer_data_ = feature_layer_data;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Observation.feature_layer_data)
}

// optional .SC2APIProtocol.ObservationRender render_data = 7;
inline bool Observation::has_render_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Observation::set_has_render_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Observation::clear_has_render_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::SC2APIProtocol::ObservationRender& Observation::_internal_render_data() const {
  return *render_data_;
}
inline const ::SC2APIProtocol::ObservationRender& Observation::render_data() const {
  const ::SC2APIProtocol::ObservationRender* p = render_data_;
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Observation.render_data)
  return p != NULL ? *p : *reinterpret_cast<const ::SC2APIProtocol::ObservationRender*>(
      &::SC2APIProtocol::_ObservationRender_default_instance_);
}
inline ::SC2APIProtocol::ObservationRender* Observation::release_render_data() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Observation.render_data)
  clear_has_render_data();
  ::SC2APIProtocol::ObservationRender* temp = render_data_;
  render_data_ = NULL;
  return temp;
}
inline ::SC2APIProtocol::ObservationRender* Observation::mutable_render_data() {
  set_has_render_data();
  if (render_data_ == NULL) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ObservationRender>(GetArenaNoVirtual());
    render_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Observation.render_data)
  return render_data_;
}
inline void Observation::set_allocated_render_data(::SC2APIProtocol::ObservationRender* render_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(render_data_);
  }
  if (render_data) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      render_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, render_data, submessage_arena);
    }
    set_has_render_data();
  } else {
    clear_has_render_data();
  }
  render_data_ = render_data;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Observation.render_data)
}

// optional .SC2APIProtocol.ObservationUI ui_data = 8;
inline bool Observation::has_ui_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Observation::set_has_ui_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Observation::clear_has_ui_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::SC2APIProtocol::ObservationUI& Observation::_internal_ui_data() const {
  return *ui_data_;
}
inline const ::SC2APIProtocol::ObservationUI& Observation::ui_data() const {
  const ::SC2APIProtocol::ObservationUI* p = ui_data_;
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Observation.ui_data)
  return p != NULL ? *p : *reinterpret_cast<const ::SC2APIProtocol::ObservationUI*>(
      &::SC2APIProtocol::_ObservationUI_default_instance_);
}
inline ::SC2APIProtocol::ObservationUI* Observation::release_ui_data() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Observation.ui_data)
  clear_has_ui_data();
  ::SC2APIProtocol::ObservationUI* temp = ui_data_;
  ui_data_ = NULL;
  return temp;
}
inline ::SC2APIProtocol::ObservationUI* Observation::mutable_ui_data() {
  set_has_ui_data();
  if (ui_data_ == NULL) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ObservationUI>(GetArenaNoVirtual());
    ui_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Observation.ui_data)
  return ui_data_;
}
inline void Observation::set_allocated_ui_data(::SC2APIProtocol::ObservationUI* ui_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ui_data_);
  }
  if (ui_data) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ui_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ui_data, submessage_arena);
    }
    set_has_ui_data();
  } else {
    clear_has_ui_data();
  }
  ui_data_ = ui_data;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Observation.ui_data)
}

// -------------------------------------------------------------------

// Action

// optional .SC2APIProtocol.ActionRaw action_raw = 1;
inline bool Action::has_action_raw() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Action::set_has_action_raw() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Action::clear_has_action_raw() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::SC2APIProtocol::ActionRaw& Action::_internal_action_raw() const {
  return *action_raw_;
}
inline const ::SC2APIProtocol::ActionRaw& Action::action_raw() const {
  const ::SC2APIProtocol::ActionRaw* p = action_raw_;
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Action.action_raw)
  return p != NULL ? *p : *reinterpret_cast<const ::SC2APIProtocol::ActionRaw*>(
      &::SC2APIProtocol::_ActionRaw_default_instance_);
}
inline ::SC2APIProtocol::ActionRaw* Action::release_action_raw() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Action.action_raw)
  clear_has_action_raw();
  ::SC2APIProtocol::ActionRaw* temp = action_raw_;
  action_raw_ = NULL;
  return temp;
}
inline ::SC2APIProtocol::ActionRaw* Action::mutable_action_raw() {
  set_has_action_raw();
  if (action_raw_ == NULL) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ActionRaw>(GetArenaNoVirtual());
    action_raw_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Action.action_raw)
  return action_raw_;
}
inline void Action::set_allocated_action_raw(::SC2APIProtocol::ActionRaw* action_raw) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(action_raw_);
  }
  if (action_raw) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      action_raw = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, action_raw, submessage_arena);
    }
    set_has_action_raw();
  } else {
    clear_has_action_raw();
  }
  action_raw_ = action_raw;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Action.action_raw)
}

// optional .SC2APIProtocol.ActionSpatial action_feature_layer = 2;
inline bool Action::has_action_feature_layer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Action::set_has_action_feature_layer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Action::clear_has_action_feature_layer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::SC2APIProtocol::ActionSpatial& Action::_internal_action_feature_layer() const {
  return *action_feature_layer_;
}
inline const ::SC2APIProtocol::ActionSpatial& Action::action_feature_layer() const {
  const ::SC2APIProtocol::ActionSpatial* p = action_feature_layer_;
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Action.action_feature_layer)
  return p != NULL ? *p : *reinterpret_cast<const ::SC2APIProtocol::ActionSpatial*>(
      &::SC2APIProtocol::_ActionSpatial_default_instance_);
}
inline ::SC2APIProtocol::ActionSpatial* Action::release_action_feature_layer() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Action.action_feature_layer)
  clear_has_action_feature_layer();
  ::SC2APIProtocol::ActionSpatial* temp = action_feature_layer_;
  action_feature_layer_ = NULL;
  return temp;
}
inline ::SC2APIProtocol::ActionSpatial* Action::mutable_action_feature_layer() {
  set_has_action_feature_layer();
  if (action_feature_layer_ == NULL) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ActionSpatial>(GetArenaNoVirtual());
    action_feature_layer_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Action.action_feature_layer)
  return action_feature_layer_;
}
inline void Action::set_allocated_action_feature_layer(::SC2APIProtocol::ActionSpatial* action_feature_layer) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(action_feature_layer_);
  }
  if (action_feature_layer) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      action_feature_layer = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, action_feature_layer, submessage_arena);
    }
    set_has_action_feature_layer();
  } else {
    clear_has_action_feature_layer();
  }
  action_feature_layer_ = action_feature_layer;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Action.action_feature_layer)
}

// optional .SC2APIProtocol.ActionSpatial action_render = 3;
inline bool Action::has_action_render() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Action::set_has_action_render() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Action::clear_has_action_render() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::SC2APIProtocol::ActionSpatial& Action::_internal_action_render() const {
  return *action_render_;
}
inline const ::SC2APIProtocol::ActionSpatial& Action::action_render() const {
  const ::SC2APIProtocol::ActionSpatial* p = action_render_;
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Action.action_render)
  return p != NULL ? *p : *reinterpret_cast<const ::SC2APIProtocol::ActionSpatial*>(
      &::SC2APIProtocol::_ActionSpatial_default_instance_);
}
inline ::SC2APIProtocol::ActionSpatial* Action::release_action_render() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Action.action_render)
  clear_has_action_render();
  ::SC2APIProtocol::ActionSpatial* temp = action_render_;
  action_render_ = NULL;
  return temp;
}
inline ::SC2APIProtocol::ActionSpatial* Action::mutable_action_render() {
  set_has_action_render();
  if (action_render_ == NULL) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ActionSpatial>(GetArenaNoVirtual());
    action_render_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Action.action_render)
  return action_render_;
}
inline void Action::set_allocated_action_render(::SC2APIProtocol::ActionSpatial* action_render) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(action_render_);
  }
  if (action_render) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      action_render = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, action_render, submessage_arena);
    }
    set_has_action_render();
  } else {
    clear_has_action_render();
  }
  action_render_ = action_render;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Action.action_render)
}

// optional .SC2APIProtocol.ActionUI action_ui = 4;
inline bool Action::has_action_ui() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Action::set_has_action_ui() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Action::clear_has_action_ui() {
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::SC2APIProtocol::ActionUI& Action::_internal_action_ui() const {
  return *action_ui_;
}
inline const ::SC2APIProtocol::ActionUI& Action::action_ui() const {
  const ::SC2APIProtocol::ActionUI* p = action_ui_;
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Action.action_ui)
  return p != NULL ? *p : *reinterpret_cast<const ::SC2APIProtocol::ActionUI*>(
      &::SC2APIProtocol::_ActionUI_default_instance_);
}
inline ::SC2APIProtocol::ActionUI* Action::release_action_ui() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Action.action_ui)
  clear_has_action_ui();
  ::SC2APIProtocol::ActionUI* temp = action_ui_;
  action_ui_ = NULL;
  return temp;
}
inline ::SC2APIProtocol::ActionUI* Action::mutable_action_ui() {
  set_has_action_ui();
  if (action_ui_ == NULL) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ActionUI>(GetArenaNoVirtual());
    action_ui_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Action.action_ui)
  return action_ui_;
}
inline void Action::set_allocated_action_ui(::SC2APIProtocol::ActionUI* action_ui) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(action_ui_);
  }
  if (action_ui) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      action_ui = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, action_ui, submessage_arena);
    }
    set_has_action_ui();
  } else {
    clear_has_action_ui();
  }
  action_ui_ = action_ui;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Action.action_ui)
}

// optional .SC2APIProtocol.ActionChat action_chat = 6;
inline bool Action::has_action_chat() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Action::set_has_action_chat() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Action::clear_has_action_chat() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Action::clear_action_chat() {
  if (action_chat_ != NULL) action_chat_->Clear();
  clear_has_action_chat();
}
inline const ::SC2APIProtocol::ActionChat& Action::_internal_action_chat() const {
  return *action_chat_;
}
inline const ::SC2APIProtocol::ActionChat& Action::action_chat() const {
  const ::SC2APIProtocol::ActionChat* p = action_chat_;
  // @@protoc_insertion_point(field_get:SC2APIProtocol.Action.action_chat)
  return p != NULL ? *p : *reinterpret_cast<const ::SC2APIProtocol::ActionChat*>(
      &::SC2APIProtocol::_ActionChat_default_instance_);
}
inline ::SC2APIProtocol::ActionChat* Action::release_action_chat() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.Action.action_chat)
  clear_has_action_chat();
  ::SC2APIProtocol::ActionChat* temp = action_chat_;
  action_chat_ = NULL;
  return temp;
}
inline ::SC2APIProtocol::ActionChat* Action::mutable_action_chat() {
  set_has_action_chat();
  if (action_chat_ == NULL) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::ActionChat>(GetArenaNoVirtual());
    action_chat_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.Action.action_chat)
  return action_chat_;
}
inline void Action::set_allocated_action_chat(::SC2APIProtocol::ActionChat* action_chat) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete action_chat_;
  }
  if (action_chat) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      action_chat = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, action_chat, submessage_arena);
    }
    set_has_action_chat();
  } else {
    clear_has_action_chat();
  }
  action_chat_ = action_chat;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.Action.action_chat)
}

// -------------------------------------------------------------------

// ActionChat

// optional .SC2APIProtocol.ActionChat.Channel channel = 1;
inline bool ActionChat::has_channel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActionChat::set_has_channel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActionChat::clear_has_channel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActionChat::clear_channel() {
  channel_ = 1;
  clear_has_channel();
}
inline ::SC2APIProtocol::ActionChat_Channel ActionChat::channel() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionChat.channel)
  return static_cast< ::SC2APIProtocol::ActionChat_Channel >(channel_);
}
inline void ActionChat::set_channel(::SC2APIProtocol::ActionChat_Channel value) {
  assert(::SC2APIProtocol::ActionChat_Channel_IsValid(value));
  set_has_channel();
  channel_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ActionChat.channel)
}

// optional string message = 2;
inline bool ActionChat::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActionChat::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActionChat::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActionChat::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& ActionChat::message() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionChat.message)
  return message_.GetNoArena();
}
inline void ActionChat::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ActionChat.message)
}
#if LANG_CXX11
inline void ActionChat::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SC2APIProtocol.ActionChat.message)
}
#endif
inline void ActionChat::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SC2APIProtocol.ActionChat.message)
}
inline void ActionChat::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SC2APIProtocol.ActionChat.message)
}
inline ::std::string* ActionChat::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ActionChat.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ActionChat::release_message() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ActionChat.message)
  if (!has_message()) {
    return NULL;
  }
  clear_has_message();
  return message_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ActionChat::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ActionChat.message)
}

// -------------------------------------------------------------------

// ActionError

// optional uint64 unit_tag = 1;
inline bool ActionError::has_unit_tag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActionError::set_has_unit_tag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActionError::clear_has_unit_tag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActionError::clear_unit_tag() {
  unit_tag_ = GOOGLE_ULONGLONG(0);
  clear_has_unit_tag();
}
inline ::google::protobuf::uint64 ActionError::unit_tag() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionError.unit_tag)
  return unit_tag_;
}
inline void ActionError::set_unit_tag(::google::protobuf::uint64 value) {
  set_has_unit_tag();
  unit_tag_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ActionError.unit_tag)
}

// optional uint64 ability_id = 2;
inline bool ActionError::has_ability_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActionError::set_has_ability_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActionError::clear_has_ability_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActionError::clear_ability_id() {
  ability_id_ = GOOGLE_ULONGLONG(0);
  clear_has_ability_id();
}
inline ::google::protobuf::uint64 ActionError::ability_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionError.ability_id)
  return ability_id_;
}
inline void ActionError::set_ability_id(::google::protobuf::uint64 value) {
  set_has_ability_id();
  ability_id_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ActionError.ability_id)
}

// optional .SC2APIProtocol.ActionResult result = 3;
inline bool ActionError::has_result() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ActionError::set_has_result() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ActionError::clear_has_result() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ActionError::clear_result() {
  result_ = 1;
  clear_has_result();
}
inline ::SC2APIProtocol::ActionResult ActionError::result() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionError.result)
  return static_cast< ::SC2APIProtocol::ActionResult >(result_);
}
inline void ActionError::set_result(::SC2APIProtocol::ActionResult value) {
  assert(::SC2APIProtocol::ActionResult_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ActionError.result)
}

// -------------------------------------------------------------------

// ObserverAction

// optional .SC2APIProtocol.ActionObserverPlayerPerspective player_perspective = 1;
inline bool ObserverAction::has_player_perspective() const {
  return action_case() == kPlayerPerspective;
}
inline void ObserverAction::set_has_player_perspective() {
  _oneof_case_[0] = kPlayerPerspective;
}
inline void ObserverAction::clear_player_perspective() {
  if (has_player_perspective()) {
    delete action_.player_perspective_;
    clear_has_action();
  }
}
inline const ::SC2APIProtocol::ActionObserverPlayerPerspective& ObserverAction::_internal_player_perspective() const {
  return *action_.player_perspective_;
}
inline ::SC2APIProtocol::ActionObserverPlayerPerspective* ObserverAction::release_player_perspective() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ObserverAction.player_perspective)
  if (has_player_perspective()) {
    clear_has_action();
      ::SC2APIProtocol::ActionObserverPlayerPerspective* temp = action_.player_perspective_;
    action_.player_perspective_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SC2APIProtocol::ActionObserverPlayerPerspective& ObserverAction::player_perspective() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ObserverAction.player_perspective)
  return has_player_perspective()
      ? *action_.player_perspective_
      : *reinterpret_cast< ::SC2APIProtocol::ActionObserverPlayerPerspective*>(&::SC2APIProtocol::_ActionObserverPlayerPerspective_default_instance_);
}
inline ::SC2APIProtocol::ActionObserverPlayerPerspective* ObserverAction::mutable_player_perspective() {
  if (!has_player_perspective()) {
    clear_action();
    set_has_player_perspective();
    action_.player_perspective_ = CreateMaybeMessage< ::SC2APIProtocol::ActionObserverPlayerPerspective >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ObserverAction.player_perspective)
  return action_.player_perspective_;
}

// optional .SC2APIProtocol.ActionObserverCameraMove camera_move = 2;
inline bool ObserverAction::has_camera_move() const {
  return action_case() == kCameraMove;
}
inline void ObserverAction::set_has_camera_move() {
  _oneof_case_[0] = kCameraMove;
}
inline void ObserverAction::clear_camera_move() {
  if (has_camera_move()) {
    delete action_.camera_move_;
    clear_has_action();
  }
}
inline const ::SC2APIProtocol::ActionObserverCameraMove& ObserverAction::_internal_camera_move() const {
  return *action_.camera_move_;
}
inline ::SC2APIProtocol::ActionObserverCameraMove* ObserverAction::release_camera_move() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ObserverAction.camera_move)
  if (has_camera_move()) {
    clear_has_action();
      ::SC2APIProtocol::ActionObserverCameraMove* temp = action_.camera_move_;
    action_.camera_move_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SC2APIProtocol::ActionObserverCameraMove& ObserverAction::camera_move() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ObserverAction.camera_move)
  return has_camera_move()
      ? *action_.camera_move_
      : *reinterpret_cast< ::SC2APIProtocol::ActionObserverCameraMove*>(&::SC2APIProtocol::_ActionObserverCameraMove_default_instance_);
}
inline ::SC2APIProtocol::ActionObserverCameraMove* ObserverAction::mutable_camera_move() {
  if (!has_camera_move()) {
    clear_action();
    set_has_camera_move();
    action_.camera_move_ = CreateMaybeMessage< ::SC2APIProtocol::ActionObserverCameraMove >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ObserverAction.camera_move)
  return action_.camera_move_;
}

// optional .SC2APIProtocol.ActionObserverCameraFollowPlayer camera_follow_player = 3;
inline bool ObserverAction::has_camera_follow_player() const {
  return action_case() == kCameraFollowPlayer;
}
inline void ObserverAction::set_has_camera_follow_player() {
  _oneof_case_[0] = kCameraFollowPlayer;
}
inline void ObserverAction::clear_camera_follow_player() {
  if (has_camera_follow_player()) {
    delete action_.camera_follow_player_;
    clear_has_action();
  }
}
inline const ::SC2APIProtocol::ActionObserverCameraFollowPlayer& ObserverAction::_internal_camera_follow_player() const {
  return *action_.camera_follow_player_;
}
inline ::SC2APIProtocol::ActionObserverCameraFollowPlayer* ObserverAction::release_camera_follow_player() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ObserverAction.camera_follow_player)
  if (has_camera_follow_player()) {
    clear_has_action();
      ::SC2APIProtocol::ActionObserverCameraFollowPlayer* temp = action_.camera_follow_player_;
    action_.camera_follow_player_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SC2APIProtocol::ActionObserverCameraFollowPlayer& ObserverAction::camera_follow_player() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ObserverAction.camera_follow_player)
  return has_camera_follow_player()
      ? *action_.camera_follow_player_
      : *reinterpret_cast< ::SC2APIProtocol::ActionObserverCameraFollowPlayer*>(&::SC2APIProtocol::_ActionObserverCameraFollowPlayer_default_instance_);
}
inline ::SC2APIProtocol::ActionObserverCameraFollowPlayer* ObserverAction::mutable_camera_follow_player() {
  if (!has_camera_follow_player()) {
    clear_action();
    set_has_camera_follow_player();
    action_.camera_follow_player_ = CreateMaybeMessage< ::SC2APIProtocol::ActionObserverCameraFollowPlayer >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ObserverAction.camera_follow_player)
  return action_.camera_follow_player_;
}

// optional .SC2APIProtocol.ActionObserverCameraFollowUnits camera_follow_units = 4;
inline bool ObserverAction::has_camera_follow_units() const {
  return action_case() == kCameraFollowUnits;
}
inline void ObserverAction::set_has_camera_follow_units() {
  _oneof_case_[0] = kCameraFollowUnits;
}
inline void ObserverAction::clear_camera_follow_units() {
  if (has_camera_follow_units()) {
    delete action_.camera_follow_units_;
    clear_has_action();
  }
}
inline const ::SC2APIProtocol::ActionObserverCameraFollowUnits& ObserverAction::_internal_camera_follow_units() const {
  return *action_.camera_follow_units_;
}
inline ::SC2APIProtocol::ActionObserverCameraFollowUnits* ObserverAction::release_camera_follow_units() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ObserverAction.camera_follow_units)
  if (has_camera_follow_units()) {
    clear_has_action();
      ::SC2APIProtocol::ActionObserverCameraFollowUnits* temp = action_.camera_follow_units_;
    action_.camera_follow_units_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SC2APIProtocol::ActionObserverCameraFollowUnits& ObserverAction::camera_follow_units() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ObserverAction.camera_follow_units)
  return has_camera_follow_units()
      ? *action_.camera_follow_units_
      : *reinterpret_cast< ::SC2APIProtocol::ActionObserverCameraFollowUnits*>(&::SC2APIProtocol::_ActionObserverCameraFollowUnits_default_instance_);
}
inline ::SC2APIProtocol::ActionObserverCameraFollowUnits* ObserverAction::mutable_camera_follow_units() {
  if (!has_camera_follow_units()) {
    clear_action();
    set_has_camera_follow_units();
    action_.camera_follow_units_ = CreateMaybeMessage< ::SC2APIProtocol::ActionObserverCameraFollowUnits >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ObserverAction.camera_follow_units)
  return action_.camera_follow_units_;
}

inline bool ObserverAction::has_action() const {
  return action_case() != ACTION_NOT_SET;
}
inline void ObserverAction::clear_has_action() {
  _oneof_case_[0] = ACTION_NOT_SET;
}
inline ObserverAction::ActionCase ObserverAction::action_case() const {
  return ObserverAction::ActionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ActionObserverPlayerPerspective

// optional uint32 player_id = 1;
inline bool ActionObserverPlayerPerspective::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActionObserverPlayerPerspective::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActionObserverPlayerPerspective::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActionObserverPlayerPerspective::clear_player_id() {
  player_id_ = 0u;
  clear_has_player_id();
}
inline ::google::protobuf::uint32 ActionObserverPlayerPerspective::player_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionObserverPlayerPerspective.player_id)
  return player_id_;
}
inline void ActionObserverPlayerPerspective::set_player_id(::google::protobuf::uint32 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ActionObserverPlayerPerspective.player_id)
}

// -------------------------------------------------------------------

// ActionObserverCameraMove

// optional .SC2APIProtocol.Point2D world_pos = 1;
inline bool ActionObserverCameraMove::has_world_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActionObserverCameraMove::set_has_world_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActionObserverCameraMove::clear_has_world_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::SC2APIProtocol::Point2D& ActionObserverCameraMove::_internal_world_pos() const {
  return *world_pos_;
}
inline const ::SC2APIProtocol::Point2D& ActionObserverCameraMove::world_pos() const {
  const ::SC2APIProtocol::Point2D* p = world_pos_;
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionObserverCameraMove.world_pos)
  return p != NULL ? *p : *reinterpret_cast<const ::SC2APIProtocol::Point2D*>(
      &::SC2APIProtocol::_Point2D_default_instance_);
}
inline ::SC2APIProtocol::Point2D* ActionObserverCameraMove::release_world_pos() {
  // @@protoc_insertion_point(field_release:SC2APIProtocol.ActionObserverCameraMove.world_pos)
  clear_has_world_pos();
  ::SC2APIProtocol::Point2D* temp = world_pos_;
  world_pos_ = NULL;
  return temp;
}
inline ::SC2APIProtocol::Point2D* ActionObserverCameraMove::mutable_world_pos() {
  set_has_world_pos();
  if (world_pos_ == NULL) {
    auto* p = CreateMaybeMessage<::SC2APIProtocol::Point2D>(GetArenaNoVirtual());
    world_pos_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SC2APIProtocol.ActionObserverCameraMove.world_pos)
  return world_pos_;
}
inline void ActionObserverCameraMove::set_allocated_world_pos(::SC2APIProtocol::Point2D* world_pos) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(world_pos_);
  }
  if (world_pos) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      world_pos = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, world_pos, submessage_arena);
    }
    set_has_world_pos();
  } else {
    clear_has_world_pos();
  }
  world_pos_ = world_pos;
  // @@protoc_insertion_point(field_set_allocated:SC2APIProtocol.ActionObserverCameraMove.world_pos)
}

// optional float distance = 2;
inline bool ActionObserverCameraMove::has_distance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActionObserverCameraMove::set_has_distance() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActionObserverCameraMove::clear_has_distance() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActionObserverCameraMove::clear_distance() {
  distance_ = 0;
  clear_has_distance();
}
inline float ActionObserverCameraMove::distance() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionObserverCameraMove.distance)
  return distance_;
}
inline void ActionObserverCameraMove::set_distance(float value) {
  set_has_distance();
  distance_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ActionObserverCameraMove.distance)
}

// -------------------------------------------------------------------

// ActionObserverCameraFollowPlayer

// optional uint32 player_id = 1;
inline bool ActionObserverCameraFollowPlayer::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActionObserverCameraFollowPlayer::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActionObserverCameraFollowPlayer::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActionObserverCameraFollowPlayer::clear_player_id() {
  player_id_ = 0u;
  clear_has_player_id();
}
inline ::google::protobuf::uint32 ActionObserverCameraFollowPlayer::player_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionObserverCameraFollowPlayer.player_id)
  return player_id_;
}
inline void ActionObserverCameraFollowPlayer::set_player_id(::google::protobuf::uint32 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ActionObserverCameraFollowPlayer.player_id)
}

// -------------------------------------------------------------------

// ActionObserverCameraFollowUnits

// repeated uint64 unit_tags = 1;
inline int ActionObserverCameraFollowUnits::unit_tags_size() const {
  return unit_tags_.size();
}
inline void ActionObserverCameraFollowUnits::clear_unit_tags() {
  unit_tags_.Clear();
}
inline ::google::protobuf::uint64 ActionObserverCameraFollowUnits::unit_tags(int index) const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.ActionObserverCameraFollowUnits.unit_tags)
  return unit_tags_.Get(index);
}
inline void ActionObserverCameraFollowUnits::set_unit_tags(int index, ::google::protobuf::uint64 value) {
  unit_tags_.Set(index, value);
  // @@protoc_insertion_point(field_set:SC2APIProtocol.ActionObserverCameraFollowUnits.unit_tags)
}
inline void ActionObserverCameraFollowUnits::add_unit_tags(::google::protobuf::uint64 value) {
  unit_tags_.Add(value);
  // @@protoc_insertion_point(field_add:SC2APIProtocol.ActionObserverCameraFollowUnits.unit_tags)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
ActionObserverCameraFollowUnits::unit_tags() const {
  // @@protoc_insertion_point(field_list:SC2APIProtocol.ActionObserverCameraFollowUnits.unit_tags)
  return unit_tags_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
ActionObserverCameraFollowUnits::mutable_unit_tags() {
  // @@protoc_insertion_point(field_mutable_list:SC2APIProtocol.ActionObserverCameraFollowUnits.unit_tags)
  return &unit_tags_;
}

// -------------------------------------------------------------------

// PlayerResult

// optional uint32 player_id = 1;
inline bool PlayerResult::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerResult::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerResult::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerResult::clear_player_id() {
  player_id_ = 0u;
  clear_has_player_id();
}
inline ::google::protobuf::uint32 PlayerResult::player_id() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerResult.player_id)
  return player_id_;
}
inline void PlayerResult::set_player_id(::google::protobuf::uint32 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerResult.player_id)
}

// optional .SC2APIProtocol.Result result = 2;
inline bool PlayerResult::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerResult::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerResult::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerResult::clear_result() {
  result_ = 1;
  clear_has_result();
}
inline ::SC2APIProtocol::Result PlayerResult::result() const {
  // @@protoc_insertion_point(field_get:SC2APIProtocol.PlayerResult.result)
  return static_cast< ::SC2APIProtocol::Result >(result_);
}
inline void PlayerResult::set_result(::SC2APIProtocol::Result value) {
  assert(::SC2APIProtocol::Result_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:SC2APIProtocol.PlayerResult.result)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace SC2APIProtocol

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::SC2APIProtocol::ResponseCreateGame_Error> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::ResponseCreateGame_Error>() {
  return ::SC2APIProtocol::ResponseCreateGame_Error_descriptor();
}
template <> struct is_proto_enum< ::SC2APIProtocol::ResponseJoinGame_Error> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::ResponseJoinGame_Error>() {
  return ::SC2APIProtocol::ResponseJoinGame_Error_descriptor();
}
template <> struct is_proto_enum< ::SC2APIProtocol::ResponseRestartGame_Error> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::ResponseRestartGame_Error>() {
  return ::SC2APIProtocol::ResponseRestartGame_Error_descriptor();
}
template <> struct is_proto_enum< ::SC2APIProtocol::ResponseStartReplay_Error> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::ResponseStartReplay_Error>() {
  return ::SC2APIProtocol::ResponseStartReplay_Error_descriptor();
}
template <> struct is_proto_enum< ::SC2APIProtocol::ResponseReplayInfo_Error> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::ResponseReplayInfo_Error>() {
  return ::SC2APIProtocol::ResponseReplayInfo_Error_descriptor();
}
template <> struct is_proto_enum< ::SC2APIProtocol::ResponseSaveMap_Error> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::ResponseSaveMap_Error>() {
  return ::SC2APIProtocol::ResponseSaveMap_Error_descriptor();
}
template <> struct is_proto_enum< ::SC2APIProtocol::ActionChat_Channel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::ActionChat_Channel>() {
  return ::SC2APIProtocol::ActionChat_Channel_descriptor();
}
template <> struct is_proto_enum< ::SC2APIProtocol::Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::Status>() {
  return ::SC2APIProtocol::Status_descriptor();
}
template <> struct is_proto_enum< ::SC2APIProtocol::Difficulty> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::Difficulty>() {
  return ::SC2APIProtocol::Difficulty_descriptor();
}
template <> struct is_proto_enum< ::SC2APIProtocol::PlayerType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::PlayerType>() {
  return ::SC2APIProtocol::PlayerType_descriptor();
}
template <> struct is_proto_enum< ::SC2APIProtocol::Alert> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::Alert>() {
  return ::SC2APIProtocol::Alert_descriptor();
}
template <> struct is_proto_enum< ::SC2APIProtocol::Result> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SC2APIProtocol::Result>() {
  return ::SC2APIProtocol::Result_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_s2clientprotocol_2fsc2api_2eproto
